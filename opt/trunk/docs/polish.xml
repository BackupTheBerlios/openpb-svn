<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE book PUBLIC "-//Norman Walsh//DTD DocBk XML V4.4//EN"
                         "dtds/docbookx.dtd">
<book id="opt" lang="pl">
	<bookinfo id="bookinfo">
		<title>Open Power Template</title>
		<subtitle>Dokumentacja - wersja 1.1.3</subtitle>
		<authorgroup id="authors">
			<author>
				<firstname>Tomasz</firstname>
				<surname>Jędrzejewski</surname>
			</author>
			<author>
				<firstname>Tomasz</firstname>
				<surname>Szczupliński</surname>
			</author>
		</authorgroup>
		<copyright>
			<year>2006-2007</year>
			<holder>Tomasz Jędrzejewski, Tomasz Szczupliński</holder>
		</copyright>
	</bookinfo>
	<title>Open Power Template</title>
	<preface id="preface">
		<title>Przedmowa</title>
		<para>Open Power Template jest systemem szablonów stworzonym w PHP i prawdopodobnie jedynym, który docelowo wspiera
		PHP 5. Podczas jego projektowania wybraliśmy dla niego dwa główne priorytety: szybkość i elastyczność. Uważamy, że
		udało nam się spełnić oba te warunki. OPT wykorzystuje niezwykle efektywny algorytm przetwarzania szablonu, który
		kompiluje go do postaci kodu PHP, a następnie składuje na HDD w celu późniejszego wykorzystania, dzięki czemu kompilacja
		wykonywana jest tylko w przypadku wprowadzania jakichś zmian. W kwestii elastyczności możesz zmieniać tu dosłownie
		wszystko: od zbioru instrukcji poprzez format składni aż do... całego parsera! Tak! Możesz usunąć oryginalne serce
		biblioteki i, korzystając z dostępnego zestawu narzędzi, stworzyć własne bazujące na kompilatorze OPT. </para>
		<para>Jeśli chodzi o możliwości, OPT dostarcza zarówno nisko- jak i wysokopoziomowe struktury składni. Używając
		zaczerpniętych z języków programowania <emphasis>if</emphasis> czy <emphasis>foreach</emphasis> czynią twe życie
		prostszym i przyjemniejszym poprzez automatyczne wykonywanie wszystkich niezbędnych i pracochłonnych czynności.
		Pełna lista możliwości zawiera:</para>
		<orderedlist>
			<listitem>W pełni elastyczna składnia szablonów. Ustawiać można zarówno kształt znaczników, jak i format parametrów. </listitem>
			<listitem>Tryb kompatybilności z XML-em, gdzie OPT używa dodatkowych wzorowanych na XML'u znaczników. Pozwala to na
			pracę z validatorami W3C oraz edytorami WYSIWYG.</listitem>
			<listitem>Struktury kontrolne, np. if, for, foreach oraz wyrażenia znane z języków programowania.</listitem>
			<listitem>Wysokopoziomowe struktury ułatwiające tworzenie szablonów. Nie wymagają prawie żadnej wiedzy o
			programowaniu.</listitem>
			<listitem>Instrukcja do renderingu drzew.</listitem>
			<listitem>Komponenty ułatwiające tworzenie np. formularzy.</listitem>
			<listitem>Wsparcie dla złożonych typów PHP: tablic i obiektów (wraz z wywoływaniem metod).</listitem>
			<listitem>Wysoka wydajność. Kod jest dobrze zoptymalizowany, a instalacja narzędzi typu Zend Optimizer
			bezpośrednio wpływa także na wykonywanie szablonu, który jest prekompilowany do postaci kodu PHP.</listitem>
			<listitem>Wbudowane wsparcie dla i18n.</listitem>
			<listitem>Zorientowana obiektowo architektura.</listitem>
			<listitem>Wsparcie dla własnych funkcji, instrukcji i komponentów.</listitem>
			<listitem>Łatwość integracji konfiguracji OPT z konfiguracją twojej witryny.</listitem>
			<listitem>Menedżer nagłówków HTTP.</listitem>
			<listitem>Wsparcie dla kompresji GZip.</listitem>
			<listitem>Cache'owanie danych wyjściowych.</listitem>
			<listitem>Wsparcie dla filtrów szablonu.</listitem>
			<listitem>Wsparcie dla własnych źródeł danych (pozwalających np. na umieszczanie szablonów w bazie danych).</listitem>
			<listitem>Wbudowana konsola debugowa.</listitem>
			<listitem>OPT API, przy pomocy którego można zbudować własny parser bazujący na kompilatorze OPT.</listitem>
			<listitem>Dodatkowe narzędzia wspomagające korzystanie z biblioteki.</listitem>		
		</orderedlist>
		<para>Ilość możliwości może rodzić pytanie, czy nie powoduje to spadku wydajności. Dla OPT nie jest to problem -
		podstawowa część kodu jest stosunkowo niewielka, natomiast reszta jest ładowana dynamicznie w miarę potrzeb. W celu
		dalszej optymalizacji, możesz skorzystać z wbudowanego narzędzia "OPT Configurator", dzięki któremu szybko usuniesz
		z kodu źródłowego te funkcje, z których nie korzystasz i które niepotrzebnie zwiększają jego objętość.</para>
		<para>Biblioteka jest dostępna na zasadach licencji GNU Lesser General Public License. Możesz jej używać i modyfikować
		za darmo, nawet w komercyjnych projektach pod warunkiem, że nie usuwasz notek o prawach autorskich i nie zarabiasz
		pieniędzy na samym fakcie użycia OPT lub jego dystrybucji.</para>
		<para>Open Power Template jest częścią większego projektu: Open Power Board. Celem projektu jest stworzenie systemu forów
		dyskusyjnych dobrej jakości opartego o założenia open-source. Istnieje więcej projektów z gałęzi Open Power. Open Power Forms
		jest oficjalnym dodatkiem dla OPT pozwalającym na tworzenie w pełni dynamicznych formularzy HTML połączonych z sprawdzaniem
		poprawności danych oraz gromadzeniem informacji o użytkownikach. Open Power Driver jest warstwą dla biblioteki PDO
		(PHP Data Objects library) z niemal identycznym API rozszerzonym o opcje cachowania. Wszystkie te projekty są tworzone przez
		polską społeczność PHP, jednak nie zapominamy tutaj też o innych narodowościach.</para>
		<para>Zanim zaczniemy, pamiętaj o jednej rzeczy... <emphasis>OPT nie jest klonem Smarty™</emphasis>.</para>	
	</preface>
	<chapter id="installation">
		<title>Instalacja</title>
		<para>Open Power Template wymaga serwera z obsługą PHP 5.0.0 or lub nowszego. Zalecana jest również obecność rozszerzenia
		Zlib, jeśli chcemy korzystać z kompresji gZip.</para>
		<para>Uwaga: każde wydanie jest testowane w miarę możliwości także na najnowszym dostępnym snapshocie PHP6.</para>
		<sect1 id="installation.simple">
			<title>Prosta instalacja</title>
			<para>Typowa instalacja wykonywana jest w dwóch etapach. Pierwszym jest kopiowanie plików. Projekt
			zawiera szereg skryptów PHP o nazwach <filename>opt.filename.php</filename>. Te pliki muszą być
			przeniesione do drzewa katalogowego Twojego projektu. Tworzysz dla nich dedykowany katalog lub
			mieszasz z innymi. Zaleca się, aby do katalogu nie można było dostać się z poziomu przeglądarki.
			Na przechowywanie szablonów musisz utworzyć dwa katalogi, które mogą się nazywać np. <filename>templates</filename>
			oraz <filename>templates_c</filename>. Pierwszy przechowuje wszystkie szablony, jakich używamy na
			naszej stronie WWW, podczas gdy drugi jest rodzajem bufora dla parsera, gdzie trzyma on skompilowane
			wersje szablonów, co przyspiesza ich wykonywanie.</para>
			<para>Drugi krok to napisanie skryptu:</para>
			<orderedlist>
				<listitem>Ustaw stałą <constant>OPT_DIR</constant>, wpisując do niej ścieżkę do plików biblioteki.
				W przypadku jej braku OPT inicjuje ją domyślną wartością ustawioną na aktualny katalog. <emphasis>Nie zalecamy</emphasis> recommend
				inicjować tej stałej wartością pustą:
				<programlisting><![CDATA[define('OPT_DIR', '');]]></programlisting>
				Może to spowodować (i najczęściej powoduje) wolniejsze ładowanie się biblioteki, ponieważ PHP domyślnie przeszukuje wtedy
				wszystkie ścieżki zdefiniowane w "include_path".
				</listitem>
				<listitem>Dołącz plik <filename>opt.class.php</filename> zawierający główną klasę biblioteki.</listitem>
				<listitem>Umieść resztę kodu w bloku <emphasis>try{ ... } catch(){ ... }</emphasis>. OPT raportuje
				błędy jako wyjątki PHP i musimy je przechowytywać. Jeśli nie masz ochoty pisać własnej ich obsługi,
				możesz skorzystać ze standardowej funkcji <function>optErrorHandler()</function>.</listitem>
				<listitem>Utwórz obiekt klasy <classname>optClass</classname>.</listitem>
				<listitem>Utwórz konfigurację. Możesz ustawić ją ręcznie, wpisując wartości do odpowiednich pól (przynajmniej "root" i "compile"
				wskazujące na dwa omówione wyżej katalogi), lub załadować je metodą <function>loadConfig()</function>.</listitem>
				<listitem>Możesz wysłać nagłówki HTTP za pomocą metody <function>httpHeaders()</function>, lecz nie jest to konieczne.</listitem>			
			</orderedlist>
			<para>Twój skrypt jest teraz gotowy do pracy. Może on wyglądać tak:</para>
			<example id="example.installation.simple">
				<title>Przykładowy skrypt OPT</title>
				<programlisting><![CDATA[<?php 
  // ustaw ścieżkę do biblioteki
  define('OPT_DIR', '../lib/'); 
  // załaduj bibliotekę
  require(OPT_DIR.'opt.class.php'); 
  try{  
    // utwórz obiekt parsera
    $tpl = new optClass; 
    // skonfiguruj OPT
    $tpl -> root = './templates/'; 
    $tpl -> compile = './templates_c/'; 
    $tpl -> gzipCompression = 1; 
    // wyślij nagłówki 
    $tpl -> httpHeaders(OPT_HTML);  
  
    // przetwórz szablon
    $tpl -> assign('current_date', date('d.m.Y, H:i'));  
    $tpl -> parse('example1.tpl');  
  }catch(optException $exception){  
    optErrorHandler($exception);  
  }  
?>				]]></programlisting>
			</example>
			<para>Zauważ, w jaki sposób konfigurujemy bibliotekę. Zwyczajnie ustawiamy odpowiednim publicznym polom
			klasy żądane wartości. <emphasis>root</emphasis> to ścieżka do plików źródłowych z szablonami. <emphasis>compile</emphasis> wskazuje
			na drugi z utworzonych katalogów, gdzie przechowywane są skompilowane szablony. Trzecia dyrektywa, <emphasis>gzipCompression</emphasis> włącza
			kompresję gZip wysyłanej zawartości, o ile przeglądarka klienta ją obsługuje. Przyspiesza to transfer strony, lecz
			wymaga obsługi kompresji gZip przez serwer.</para>
			<para>Konfiguracja może być też zapisana jako tablica:</para>
			<programlisting><![CDATA[$config = array(
	'root' => './templates/',
	'compile' => './templates_c/',
	'gzipCompression' => 1
);
$tpl -> loadConfig($config);]]></programlisting>
			<para>Lub jako zewnętrzny plik:</para>
			<programlisting><![CDATA[; <?php die(); ?>
; Konfiguracja OPT
root = "./templates/"
compile = "./templates_c/"
gzipCompression = 1]]></programlisting>
			<para>Który ładujemy tak:</para>
			<programlisting><![CDATA[$tpl -> loadConfig('my_config.php');]]></programlisting>
		</sect1>
		<sect1 id="installation.advanced">
			<title>Zaawansowana instalacja.</title>
			<para>W przeciwieństwie do innych systemów szablonów PHP5, OPT nie posiada domyślnie zaimplementowanego
			wzorca singleton. Dzięki temu programista nie jest zmuszany do jego użycia, a ponadto może też szybko
			i bezproblemowo rozszerzyć klasę <classname>optClass</classname> o dodatkowe metody i dodać ten wzorzec
			ręcznie, jeśli go rzeczywiście potrzebuje. Popatrzmy na przykładowy kod rozszerzający domyślną klasę,
			dodając tam kilka często używanych metod:</para>
			<example id="example.installation.advanced">
				<title>Zaawansowana instalacja</title>
				<programlisting><![CDATA[<?php 
	define('OPT_DIR', '../lib/');
	require(OPT_DIR.'opt.class.php');
	
	class myParser extends optClass
	{
		public $pageTitle;

		public function __construct()
		{
			$this -> root = './templates/';
			$this -> compile = './templates_c/';
			$this -> cache = './cache/';
			$this -> gzipCompression = 1;
			$this -> httpHeaders(OPT_HTML); 
		} // end __construct();
		
		public function display($template)
		{
			$this -> assign('pageTitle', $this -> pageTitle);
			$this -> parse('overall_header.tpl');
			$this -> parse($template);
			$this -> parse('overall_footer.tpl');
		} // end display();
	}
 
	try
	{ 
		$tpl = new myParser;
		$tpl -> pageTitle = 'My page';
		$tpl -> assign('current_date', date('d.m.Y, H:i')); 
		$tpl -> display('document.tpl');
	}
	catch(optException $exception)
	{ 
		optErrorHandler($exception); 
	}
?>				]]></programlisting>
			</example>
			<para>W ten sposób możesz szybko dodawać do parsera nowe możliwości lub ułatwiać sobie życie, tworząc metody
			dla kilku często wykonywanych operacji.</para>
		</sect1>
		<sect1 id="installation.opt_api">
			<title>OPT API</title>
			<para>OPT jest zaprojektowany do pracy z każdym rodzajem informacji tekstowej, nie tylko z dokumentami XML.
			Jego celem jest także tak duża rozszerzalność, jak to tylko możliwe. Dlatego istnieje OPT API. Jest to maksymalnie
			uproszczona wersja parsera, która pomaga zbudować własny parser oparty o kompilator OPT. Przydaje się, jeśli
			przykładowo chcesz za pomocą szablonów obsługiwać wzory e-maili wysyłanych do klientów w Twoim serwisie. Nie
			potrzeba tutaj kompresji gZip, nagłówków HTTP itd., więc używasz wyłącznie kompilatora i uproszczonego parsera.</para>
			<para>OPT API zawiera wszystkie podstawowe metody, jak <function>assign()</function> czy <function>fetch()</function>.
			Popatrzmy na skrypt:</para>
			<example id="example.installation.opt_api">
				<title>OPT API usage</title>
				<programlisting><![CDATA[<?php 
	define('OPT_DIR', '../lib/');
	require(OPT_DIR.'opt.api.php');
	
	class optParser extends optApi
	{
		// Twój kod idzie tutaj
	}

	try{ 
		$tpl = new optParser; 
		$tpl -> root = './templates/';
		$tpl -> compile = './templates_c/';
		$tpl -> assign('current_date', date('d.m.Y'));
		$tpl -> parse('my_template.tpl');
	}
	catch(optException $exception)
	{ 
		optErrorHandler($exception); 
	}
?>				]]></programlisting>
			</example>
			<para>Dyrektywa <emphasis>compile</emphasis> jest wymagana przez kompilator, więc nawet taki uproszczony parser
			powinien udostępniać przechowywanie skompilowanych wersji na HDD. Każdorazowa kompilacja jest kilka razy wolniejsza
			od wykonywania prekompilowanej wersji.</para>
		</sect1>
	</chapter>
	<chapter id="syntax">
		<title>Składnia</title>
		<para>W tym rozdziale opiszemy składnię używaną w szablonach. Jest ona wzorowana na języku XML, więc jeśli
		znasz go, z pewnością znajdziesz tu wiele znajomych rozwiązań. OPT ma jednak pracować z każdym rodzajem
		informacji tekstowej, przez co pojawia się też kilka różnic. Istnieje też tryb emulacji zwany <emphasis>Trybem składni XML</emphasis>,
		gdzie znaczniki mogą wyglądać identycznie, jak w języku XML, z tym że należy brać poprawkę, że jest to tylko emulacja
		i parser sam z siebie nie raportuje części błędów składniowych języka XML (aczkolwiek pilnowanie, czy znaczniki są
		otwierane i zamykane we właściwej kolejności, jest zaimplementowane).</para>
		<para>Na początku dokumentacja podaje podstawowe wiadomości o znacznikach i komentarzach. Następnie objaśniane są
		bloki i wyrażenia, by  później opisać dostępne funkcje, instrukcje oraz komponenty i zakończyć opisem trybu składni XML.</para>
		<para>Ten rozdział przeznaczony jest głównie dla osób zajmujących się tworzeniem szablonów. Wiemy, że niektórzy z nich
		mogą nie znać się na programowaniu, podczas gdy OPT, nie ukrywając, posiada takie możliwości języka programowania. Jeśli
		jesteś taką osobą, pamiętaj, że w tym systemie szablonów nie musisz znać i używać wszystkich typowo programistycznych opcji
		(najprawdopodobniej wystarczą Ci jedynie elementarne podstawy). Staraliśmy się, aby opisy były jak najprostsze do zrozumienia,
		jednakże musimy też z racji, iż jest to dokumentacja, opisać wszystkie cechy składni. Dlatego tekst został dodatkowo
		oznaczony kolorowymi paskami określającymi, dla kogo dany fragment jest przeznaczony:</para>
		<itemizedlist>
			<listitem>Brak paska - dla wszystkich</listitem>
			<listitem>Pomarańczowy pasek - cecha związana z programowaniem, lecz łatwa do zrozumienia i czasem może się przydać.</listitem>
			<listitem>Czerwony pasek - bardziej skomplikowana cecha programistyczna, która wymaga trochę doświadczenia. Najprawdopodobniej
				nie będziesz musiał jej używać.</listitem>
			<listitem>Niebieski pasek - w niektórych miejscach musieliśmy zamieścić opis dla programistów PHP z informacjami,
				jak obsługiwać daną rzecz po stronie skryptu PHP. Te fragmenty oznaczone są właśnie tym paskiem i twórca szablonów
				w ogóle nie musi zawracać sobie nimi głowy.</listitem>
		</itemizedlist>
		
		<para><emphasis>Uwaga:</emphasis> nadrzędnym celem OPT jest prostota. Choć po stronie szablonów dostępne są
		wszystkie niezbędne programistyczne narzędzia, powinno się ich używać tylko wtedy, gdy nie ma już naprawdę
		żadnego innego sposobu osiągnięcia żądanego celu. OPT posiada wszystko, co potrzebne, aby szablony były schludne
		i łatwe do zrozumienia (komponenty, sekcje, itd.) i polecamy tworzenie szablonów właśnie w tym duchu.</para>
		<sect1 id="syntax.introduction">
			<title>Wstęp</title>
			<para>Szablon jest pojedynczym plikiem z zawartością tekstową i znacznikami OPT. Są one przetwarzane przez
			kompilator i informują, w jaki sposób wstawiać dane ze skryptu w tekst. W wyniku tego otrzymujemy gotowy
			do użycia dokument.</para>
			<para>Wszystkie znaczniki OPT zamknięte są wewnątrz ograniczników. Domyślnie są to <emphasis>{</emphasis> oraz
			<emphasis>}</emphasis>, lecz mogą zostać zmienione. Tryb składni XML dodaje ograniczniki identyczne, jak w języku XML,
			z tym że jest to tylko emulacja. W dokumentacji będziemy przyjmowali, że używasz domyślnych, klamrowych ograniczników.
			Oto kilka przykładowych znaczników:</para>
			<programlisting><![CDATA[{znacznik}
{wielolinijkowy
	znacznik}	]]></programlisting>
			<para>Znacznik nigdy nie może w swojej treści zawierać żadnego ogranicznika, kod <emphasis>{znacznik } znacznik}</emphasis>
			jest nieprawidłowy.</para>
			<para>Przetwarzanie szablonu składa się z dwóch etapów. Pierwszy jest nazywany <emphasis>kompilacją</emphasis>.
			Szablon jest tutaj tłumaczony na łatwiejszy i szybszy do wykonania kod PHP za pomocą grupy specjalnych algorytmów.
			Kompilacja jest robiona tylko wtedy, kiedy nastąpią jakieś zmiany w treści szablonu. Drugi etap to wykonanie. Skompilowany
			i załadowany z dysku szablon jest wykonywany przez parser PHP, w wyniku czego otrzymujemy gotowy dokument wyjściowy
			(np. plik HTML z treścią strony gotowy do wysłania do przeglądarki). Większość instrukcji OPT pracuje w obu tych etapach,
			tzn. podczas kompilacji mówią parserowi, jaki kod PHP należy wygenerować na miejsce znacznika, natomiast w trakcie wykonywania
			przetwarzany jest tenże kod, dzięki czemu ma miejsce jakaś dynamiczna akcja. Istnieje jednak nieduża grupa instrukcji aktywnych
			tylko na etapie kompilacji, które w skompilowanym szablonie nie pozostawiają żadnyuch śladów swego istnienia. Używa się
			ich przede wszystkim do manipulacji samym szablonem. Takie instrukcje zostały odpowiednio oznakowane w dokumentacji.</para>
		</sect1>
		<sect1 id="syntax.comments">
			<title>Komentarze</title>
			<para>Komentarze OPT umieszczone są w nawiasach klamrowych z gwiazdkami na końcu i początku. Mogą zawierać zarówno statyczny tekst,
			jak i znaczniki OPT. Treść komentarzy nie jest przetwarzana, a ponadto jest gubiona w trakcie kompilacji. Można ich
			używać do sporządzania wewnętrznych notatek lub do testowania i usuwania błędów.</para>
			<example id="example.syntax.comments">
				<title>Komentarze w szablonach</title>
				<programlisting><![CDATA[{* To jest komentarz jednolinijkowy *}
{* To jest komentarz
wielolinijkowy *}
<p>To jest statyczny kod</p>
{* Pokaż blok $date w tym miejscu *}
{$date}
&lt;!-- Ten komentarz jest już wysyłany do przeglądarki --&gt;]]></programlisting>
			</example>
		</sect1>
		<sect1 id="syntax.blocks">
			<title>Bloki i zmienne</title>
			<para>Blokiem nazywamy miejsce w szablonie, w które szablon może wstawić jakieś dane wygenerowane
			przez Twoją aplikację. Blok zaczyna się od znaku dolara, a dalsza część jego nazwy może zawierać
			liczby, litery, znaki podkreślenia, dokładnie identycznie jak zmienne w PHP. Blok reprezentuje
			zarówno wartości skalarne (liczby, ciągi tekstowe) oraz złożone typy: tablice oraz obiekty.
			Wartości przypisywane są blokom z poziomu skryptu za pomocą metody <function>optClass::assign()</function>.
			
			Poniższy przykładowy szablon pozwala na wyświetlenie w statycznym kodzie dynamicznie zmieniającej
			się nazwy przedmiotu przekazanej ze skryptu:</para>
			<example id="example.syntax.blocks1">
				<title>Prosty blok</title>
				<programlisting><![CDATA[<p>Witaj, przyjacielu! Czy potrzebujesz {$przedmiot}?</p>]]></programlisting>
			</example>
			<para>Jeśli teraz skrypt przypisze blokowi  <emphasis>$przedmiot</emphasis> wartość "okulary przeciwsłoneczne",
			internauta zobaczy:</para>
			<programlisting><![CDATA[<p>Witaj, przyjacielu! Czy potrzebujesz okularów przeciwsłonecznych?</p>]]></programlisting>
			<mark type="orange">
			<para>Jak wspominaliśmy, bloki mogą przechowywać nie tylko wartości skalarne, ale i złożone struktury
			znane z PHP: tablice oraz obiekty. Tablica jest zbiorem zmiennych zgrupowanych pod tą samą nazwą. Przykładowo,
			zamiast pisać <emphasis>$osoba_imie, $osoba_nazwisko</emphasis>, robimy <emphasis>$osoba.imie, $osoba.nazwisko</emphasis>.
			Niektórzy powiedzą, że to praktycznie to samo, lecz główna różnica leży w kodzie PHP i możliwościach. Od strony kodu
			dane są prościej przypisywane do szablonów, a ponadto tablica sama w sobie jest jednym wielkim blokiem i jeśli trzeba,
			można napisać po prostu <emphasis>$osoba</emphasis>, aby przekazać gdzieś wszystkie informacje o facecie za jednym
			zamachem. Skonsultuj się z Twoim programistą PHP, gdzie będziecie używać tablic..</para>
			<para>Tablice pozwalają również na dodanie większego dynamizmu. Załóżmy, że mamy dwie takie: <variable>$tytuly</variable> i
			<variable>$wartosci</variable>. Zawierają różne rodzaje informacji, lecz my posiadamy jeszcze jeden blok: <variable>$ktory</variable>.
			W nim zapisane jest, który konkretnie element tablicy chcemy wyświetlić. OPT pozwala w tym miejscu na następującą operację:</para>
			<example id="example.syntax.blocks2">
				<title>Blocks and arrays</title>
				<programlisting><![CDATA[<p><strong>{$tytuly[$ktory]}</strong>: {$wartosci[$ktory]}</p>]]></programlisting>
			</example>
			<para>Kod ten mówi nam: weź z tablicy <variable>$tytuly</variable> element, którego identyfikator (czyli tzw. indeks) masz zapisany
			w bloku <variable>$what</variable>. Identyfikatorami wartości w tablicach mogą być zarówno liczby, jak i ciągi
			tekstowe. Lista możliwych odwołań do danych tablicy pokazana jest poniżej:</para>
			<programlisting><![CDATA[{$foo}           {* wyświetla proste dane (liczby, teksty) *}
{$foo[4]}        {* wyświetl 5-ty element tablicy indeksowanej od zera. *}
{$foo.bar}       {* wyświetl element tablicy o indeksie "bar" *}
{$foo[bar]}      {* wyświetl element tablicy o indeksie "bar" *}
{$foo.bar[pub]}  {* wyświetl element "pub" z tablicy umieszczonej pod indeksem "bar" w tablicy "foo". *}
{$foo[$bar]}     {* wyświetl z tablicy $foo element, którego indeks jest zapisany w bloku $bar *}]]></programlisting>
			<para>Notacja z kropkami może być używana, jeśli indeksy określone są statycznie w kodzie.
			Notacja nawiasowa pozwala nam używać dynamicznych indeksów (zapisanych w innym bloku). Zauważmy,
			że obie notacje można w pewnym stopniu mieszać, przechodząc z notacji kropkowej na tablicową
			(ale nie na odwrót). Zapis <emphasis>$foo[bar].joe</emphasis> nie jest dozwolony.</para>
			</mark>
			<mark type="red">
			<para>Kolejnym złożonym typem wspieranym przez OPT są obiekty. Zazwyczaj nie ma potrzeby używania
			ich w szablonach, lecz niektórym programistom ich obecność może wydać się niezbędna. Obiekt jest
			czymś więcej, niż tablica. Nie tylko grupuje on w sobie nieco danych, ale zawiera również <emphasis>metody</emphasis>
			mówiące, w jaki sposób te dane można przetwarzać. Metody mogą pobierać parametry zarówno statyczne,
			np. "5", "Maciek", jak i dynamiczne, zapisane w innych blokach czy generowane przez inne metody.
			Poniższy kod pokazuje sposoby odwoływania się do wnętrza obiektów w OPT:</para>
			<programlisting><![CDATA[{$foo->bar}			{* pole "bar" obiektu $foo *}
{$foo->method()}			{* wywołanie metody "method()" dla danych obiektu $foo *}
{$foo->method(5)}			{* jw, ze statycznym parametrem *}
{$foo->method($bar)}		{* jw, z dynamicznym parametrem *}
{$foo->method($abc, $def)}	{* metoda z więcej, niż jednym parametrem. *}]]></programlisting>
			<para>Nie zapomnij skonsultować się ze swoim programistą w sprawie elementów składni,
			których będziecie używać.</para>
			</mark>
			<para>W OPT tylko jedna nazwa bloku jest zarezerwowana: <emphasis>$opt</emphasis>. Dzięki niej
			możemy uzyskać szereg użytecznych informacji niedostępnych w inny sposób. Należy dodać, że
			programiści mogą rozszerzać funkcjonalność tego bloku, tak więc dalsze możliwości zostaną
			omówione w późniejszych rozdziałach:</para>
			<programlisting><![CDATA[$opt.get.nazwa - pobiera parametr "nazwa" z adresu URL
$opt.post.nazwa - pobiera parametr "nazwa" przysłany z formularza
$opt.cookie.nazwa - pobiera ciastko "nazwa"
$opt.session.nazwa - pobiera z sesji zmienną "nazwa"
$opt.server.nazwa - pobiera informację o żądaniu HTTP opatrzoną nazwą "nazwa"
$opt.env.nazwa - pobiera informacje środowiskowe o nazwie "nazwa"
$opt.request.nazwa - zwraca parametr "nazwa" z adresu URL, formularza lub ciastek.
$opt.now - zwraca aktualny czas w sekundach od 1.1.1970.
$opt.const.nazwa - zwraca wartość stałej PHP o nazwie "nazwa"
$opt.version - zwraca numer wersji OPT]]></programlisting>
			<para>Niekiedy sam system szablonów musi zapisać gdzieś jakieś informacje do późniejszego
			użycia przez szablon, lecz jak wspomnieliśmy wcześniej, zwykłe bloki tworzy programista z
			poziomu skryptu. Dane generowane przez OPT zapisywane są w innym rodzaju "pojemników", zwanych
			<emphasis>zmiennymi</emphasis>. Ich nazwa rozpoczyna się znakiem małpy, a dalsze użycie jest niemal
			identyczne, jak w przypadku zwykłyuch bloków. Zmienne zostały wprowadzone, aby uniknąć konfliktów
			nazw między pojemnikami z danymi generowanymi przez szablon, a tworzonymi przez programistę blokami.
			W poniższym przykładzie tworzymy zmienną tekstową i wyświetlamy jej zawartość:</para>
			<example id="example.syntax.blocks3">
				<title>Variables</title>
				<programlisting><![CDATA[{var=zmienna; "Wartość zmiennej"}
<p>{@zmienna}</p>]]></programlisting>
			</example>
			<para>Pierwsza linijka tworzy nową zmienną. Jej znaczenie zostanie omówione później.</para>
			<mark type="red">
			<para>OPT umożliwia bezpośredni dostęp do swojej konfiguracji poprzez udostępnienie specjalnej
			składni dla dyrektyw konfiguracyjnych. Ich nazwy poprzedzone są znakiem hasza (#),np. <emphasis>{#root}</emphasis> - 
			spowoduje to wyświetlenie ścieżki, w której zapisane są szablony.</para>			
			</mark>
			<para>Niektóre witryny mogą posiadać wielojęzyczny interfejs. System sam wybiera komunikat, jaki
			ma się w danym miejscu wyświetlić, w zależności od wybranej wersji językowej. OPT posiada specjalny
			rodzaj bloków dla tego rodzaju danych. Zwane są one <emphasis>blokami językowymi</emphasis> i
			pozwalają na bezpośrednie pobieranie komunikatów z systemu językowego. Każdy komunikat ma swój
			identyfikator oraz przypisany jest do pewnej grupy, zatem odwołanie się do niego za pomocą bloku
			językowego będzie wyglądać następująco: <emphasis>{$grupa@identyfikator}</emphasis>. Obsługa wielojęzykowości
			została wytłumaczona w dalszej części dokumentacji.</para>
		</sect1>
		<sect1 id="syntax.expressions">
			<title>Wyrażenia</title>
			<mark type="orange">
			<para>Bloki i zmienne mogą być łączone w większe struktury zwane wyrażeniami. Przypuśćmy, że do
			szablonu przekazane zostały dwa bloki z liczbą aktywnych i nieaktywnych użytkowników. Czy mimo tego
			nadal jest możliwe wyświetlenie również łącznej ich liczby bez konieczności przekazywania kolejnego
			bloku? Odpowiedź brzmi: tak. Popatrzmy na przykład:</para>
			<example id="example.syntax.expressions1">
				<title>Dodawanie w OPT</title>
				<programlisting><![CDATA[<p>Aktywne konta: {$aktywne}</p>
<p>Nieaktywne konta: {$nieaktywne}</p>
<p>Łącznie kont: {$aktywne + $nieaktywne}</p>]]></programlisting>
			</example>
			<para>Jak widać, dwa bloki zostały połączone operatorem dodawania, dzięki czemu w miejscu
			nawiasów klamrowych ukaże nam się suma dwóch wartości. OPT pozwala na budowanie złożonych wyrażeń
			z użyciem wielu różnych operatorów.</para>
			<para>Wyrażenie składa się z:</para>
			<orderedlist>
				<listitem>Liczb w formacie dziesiętnym lub szesnastkowym: 1234567890 lub 0x123456789ABCDEF0 lub 0x123456789abcdef0</listitem>
				<listitem>Ciągów tekstowych zawartych w:
				<orderedlist>
					<listitem>Apostrofach: <emphasis>'to jest tekst'</emphasis></listitem>
					<listitem>Cudzysłowach: <emphasis>"to jest tekst"</emphasis></listitem>
					<listitem>Odwróconych apostrofach: <emphasis>`to jest tekst`</emphasis></listitem>
					<listitem>Pojedyncze słowa mogą być zapisywane bez apostrofów/cudzysłowów, jeśli nie są operatorami
						lub nie stoją na miejscu przeznaczonym dla operatora.</listitem>
					<listitem>Aby napisać apostrof/cudzysłów jako część tekstu, a nie jego zakończenie, stosujemy backslash: <emphasis>"cudzysłów \" w tekście"</emphasis></listitem>
				</orderedlist>
				</listitem>
				<listitem>Operatorów łączących dwa mniejsze wyrażenia i generujących wynik. Kolejność operatorów decyduje
					o tym, które z nich zostaną obliczone jako pierwsze. Przykładowo, w wyrażeniu <emphasis>1 + 5 * 3</emphasis>,
					odpowiedzią będzie 16, nie 18, ponieważ operator mnożenia ("*") jest ważniejszy, niż operator dodawania.
					Za pomocą okrągłych nawiasów można wymuszać inną kolejność, gdy to jest potrzebne. Kolejność operatorów
					jest identyczna, jak w języku PHP.</listitem>
				<listitem>Funkcji pobierających parametry (argumenty) i generujących na ich podstawie wynik, jak w matematyce lub PHP.
					Składnia przypomina to, co spotykamy w językach programowania: <emphasis>nazwaFunkcji(lista_parametrów)</emphasis> gdzie listą parametrów jest zbiór wyrażeń
					oddzielonych od siebie przecinkiem. Przykładowo, funkcja <emphasis>foo(1, 2, 3)</emphasis> pobiera trzy parametry: 1, 2 i 3.
					<emphasis>bar()</emphasis> nie pobiera żadnych parametrów. Identyczna składnia używana jest w odwołaniach do metod obiektów.</listitem>			
			</orderedlist>
			<para>W OPT dozwolone jest stosowanie następujących operatorów. Niektóre z nich mają dwie wersje: tekstową i symboliczną.</para>
			
			<table frame="all" id="operator_list">
				<?dbhtml table-width="100%" ?>
				<caption>Lista operatorów</caption>
				<tgroup cols="4" align="center">
				<thead>
				<row>
				  <entry>Symoliczny</entry>
				  <entry>Tekstowy</entry>
				  <entry>Przykład</entry>
				  <entry>Opis</entry>
				</row>
				</thead>
				<tbody>
				<row>
				  <entry>==</entry>
				  <entry>eq</entry>
				  <entry>$a == $b</entry>
				  <entry>prawda, gdy $a jest równe $b</entry>
				</row>
				<row>
				  <entry>!=</entry>
				  <entry>neq</entry>
				  <entry>$a != $b</entry>
				  <entry>prawda, gdy $a nie jest równe $b</entry>
				</row>
				<row>
				  <entry>===</entry>
				  <entry></entry>
				  <entry>$a === $b</entry>
				  <entry>prawda, gdy $a jest równe $b i oba wyrażenia mają ten sam typ</entry>
				</row>
				<row>
				  <entry>!==</entry>
				  <entry></entry>
				  <entry>$a !== $b</entry>
				  <entry>prawda, gdy $a nie jest równe $b lub oba wyrażenia mają różne typy</entry>
				</row>
				<row>
				  <entry>&gt;</entry>
				  <entry>gt</entry>
				  <entry>$a &gt; $b</entry>
				  <entry>prawda, gdy $a jest większe niż $b</entry>
				</row>
				<row>
				  <entry>&lt;</entry>
				  <entry>lt</entry>
				  <entry>$a &lt; $b</entry>
				  <entry>prawda, gdy $a jest mniejsze niż $b</entry>
				</row>
				<row>
				  <entry>&gt;=</entry>
				  <entry>gte, ge</entry>
				  <entry>$a &gt;= $b</entry>
				  <entry>prawda, gdy $a jest większe lub równe $b</entry>
				</row>
				<row>
				  <entry>&lt;=</entry>
				  <entry>lte, le</entry>
				  <entry>$a &lt;= $b</entry>
				  <entry>prawda, gdy $a jest mniejsze lub równe $b</entry>
				</row>
				<row>
				  <entry>&amp;&amp;</entry>
				  <entry>and</entry>
				  <entry>$a &amp;&amp; $b</entry>
				  <entry>prawda, gdy $a i $b są prawdziwe</entry>
				</row>
				<row>
				  <entry>||</entry>
				  <entry>or</entry>
				  <entry>$a || $b</entry>
				  <entry>prawda, gdy $a lub $b lub oba naraz są prawdziwe</entry>
				</row>
				<row>
				  <entry></entry>
				  <entry>xor</entry>
				  <entry>$a xor $b</entry>
				  <entry>prawda, gdy $a lub $b jest prawdziwe, lecz nie oba naraz.</entry>
				</row>
				<row>
				  <entry>!</entry>
				  <entry>not</entry>
				  <entry>! $a</entry>
				  <entry>prawda, gdy $a jest fałszywe</entry>
				</row>
				<row>
				  <entry>+</entry>
				  <entry>add</entry>
				  <entry>$a + $b</entry>
				  <entry>suma $a i $b</entry>
				</row>
				<row>
				  <entry>-</entry>
				  <entry>sub</entry>
				  <entry>$a - $b</entry>
				  <entry>różnica $a i $b</entry>
				</row>
				<row>
				  <entry>*</entry>
				  <entry>mul</entry>
				  <entry>$a * $b</entry>
				  <entry>iloczyn $a i $b</entry>
				</row>
				<row>
				  <entry>/</entry>
				  <entry>div</entry>
				  <entry>$a / $b</entry>
				  <entry>iloraz $a i $b</entry>
				</row>
				<row>
				  <entry>%</entry>
				  <entry>mod</entry>
				  <entry>$a % $b</entry>
				  <entry>reszta z dzielenia $a przez $b</entry>
				</row>
				<row>
				  <entry>++</entry>
				  <entry></entry>
				  <entry>$a++</entry>
				  <entry>zwraca wartość $a, a następnie zwiększa ją o 1</entry>
				</row>
				<row>
				  <entry>--</entry>
				  <entry></entry>
				  <entry>$a--</entry>
				  <entry>zwraca wartość $a, a następnie zmniejsza ją o 1</entry>
				</row>
				<row>
				  <entry>::</entry>
				  <entry></entry>
				  <entry>$a :: $b</entry>
				  <entry>połączenie ciągów tekstowych $a i $b</entry>
				</row>
				<row>
				  <entry>=</entry>
				  <entry>is</entry>
				  <entry>@a is $b</entry>
				  <entry>przypisuje wartość wyrażenia po prawej zmiennej lub blokowi po lewej</entry>
				</row>
				</tbody>
			  </tgroup>
			</table>
			<para>Uwaga: OPT wspiera jedynie operatory postinkrementacji i postdekrementacji. Zapis <emphasis>++$a</emphasis> może spowodować
			nieokreślone zachowanie.</para>
			<para>Tabelka może wyglądać zniechęcająco, dlatego teraz zapoznamy się z paroma przykładami. W OPT istnieje instrukcja if,
			która pozwala wyświetlić fragment szablonu, jeśli podane do niej wyrażenie jest prawdziwe. Skrypt przysyła nam dwa bloki:
			<variable>$imie</variable> oraz <variable>$nazwisko</variable> - chcemy pokazać dodatkowy tekst, jeśli wskazują one pewną,
			konkretną osobę.</para>
			<example id="example.syntax.expressions2">
				<title>Proste wyrażenia</title>
				<programlisting><![CDATA[{if $imie == "Jan" and $nazwisko == "Kowalski"}
	<p>Witaj, Janku! Jak się masz</p>
{/if}]]></programlisting>
			</example>
			<para>Operatory takie, jak <emphasis>&gt;</emphasis> i <emphasis>==</emphasis> mogą być używane do porównywania danych, natomiast
			<emphasis>and</emphasis> czy <emphasis>or</emphasis> określają relacje między innymi wyrażeniami. Kolejny przykład będzie dotyczyć
			internetowego quizu. Uczestnik musi obowiązkowo rozwiązać zestaw numer 1, a następnie wybrać zestaw 2 lub 3. Wyniki każdego zestawu skrypt
			przesyła w trzech blokach: <variable>$test1</variable>, <variable>$test2</variable> i <variable>$test3</variable> in test 3. Chcemy wyświetlić dodatkowe
			gratulacje dla osoby, która zaliczyła pierwszy oraz przynajmniej jeden z dwóch kolejnych zestawów.</para>
			<example id="example.syntax.expressions3">
				<title>Bardziej skomplikowane wyrażenia</title>
				<programlisting><![CDATA[{if $test1 > 50 and ($test2 > 50 or $test3 > 50)}
	<p>Gratulacje, zdałeś nasz test śpiewająco!</p>
{/if}]]></programlisting>
			</example>
			<para>Użyliśmy tutaj nawiasów do zgrupowania wyrażeń dla testu 2 i 3 w jedno większe. Teraz parser wie, że
			ma wyświetlić gratulacje tylko wtedy, gdy test 1 i przynajmniej jeden z testów 2 i 3 zdany jest na 50 punktów. Bez nawiasów,
			wyrażenie byłoby liczone następująco: testy 1 i 2 razem LUB test 3 musi być zdany, co nie jest dokładnie tym,
			co chcieliśmy uzyskać.</para>
			</mark>
		</sect1>
		<sect1 id="syntax.functions">
			<title>Funkcje</title>
			<mark type="orange">
			<para>Funkcja jest elementem, który pobiera dane wejściowe, modyfikuje je i zwraca wynik.
			Dane wejściowe zwane są parametrami i są po prostu grupą wartości, które chcemy przetwarzać.
			W OPT funkcje mają podobną składnię, jak w językach
			programowania i matematyce:</para>
			<programlisting><![CDATA[{funkcja(parametry)}]]></programlisting>
			<para><emphasis>parametry</emphasis> to lista wyrażeń oddzielonych od siebie przecinkami. Jeśli
			funkcja nie posiada żadnych parametrów, wciąż musimy zostawić nawiasy. OPT posiada zestaw
			wbudowanych funkcji, zaś programiści mogą tworzyć również własne.</para>
			<para>Poniższy przykład w praktyce ukazuje ideę stojącą za funkcjami. Powiedzmy, że skrypt
			definiuje nam blok <variable>$introduction</variable> z wartością "Witamy na naszej stronie",
			jednak w pewnym miejscu chcemy użyć go zapisanego w całości dużymi literami. Wystarczy użyć
			funkcji, która pobierze oryginalny tekst, zamieni w nim małe litery na duże i zwróci go
			z powrotem szablonowi.</para>
			<example id="example.syntax.functions1">
				<title>Przykładowe użycie funkcji</title>
				<programlisting><![CDATA[<p>{upper($introduction)}</p>]]></programlisting>
			</example>
			<para>Co prawda w wielu wypadkach nie potrzeba posługiwać się systemem szablonów do
			wykonania tego typu czynności (odpowiednie opcje udostępniają arkusze stylów CSS), ale
			nie zapominajmy, że w OPT można również tworzyć inne rodzaje dokumentów tekstowych,
			które wcale nie muszą CSS-a rozumieć.</para>
			<para>Poniżej przedstawiamy kompletną listę funkcji zaimplementowanych domyślnie w OPT.
			Przy każdym parametrze zaznaczyliśmy, jakiego typu wartości on wymaga. Przyjęta jest
			następująca konwencja:</para>
			<orderedlist>
				<listitem><emphasis>Integer</emphasis> - liczba całkowita: ..., -2, -1, 0, 1, 2 ...</listitem>
				<listitem><emphasis>Float</emphasis> - liczba rzeczywista (z ułamkami): 3.14</listitem>
				<listitem><emphasis>Number</emphasis> - liczba całkowita lub rzeczywista</listitem>
				<listitem><emphasis>String</emphasis> - dowolny ciąg tekstowy</listitem>
				<listitem><emphasis>Boolean</emphasis> - wartość logiczna: 1 (prawda) lub 0 (fałsz).</listitem>
				<listitem><emphasis>Array</emphasis> - tablica PHP</listitem>
				<listitem><emphasis>Object</emphasis> - obiekt PHP</listitem>
				<listitem><emphasis>Lang</emphasis> - blok językowy</listitem>
				<listitem><emphasis>Mixed</emphasis> - dozwolone wartości większej liczby typów</listitem>
				<listitem><emphasis>Void</emphasis> - funkcja nie zwraca wartości</listitem>
				<listitem>... - trzy kropki oznaczają zmienną liczbę parametrów.</listitem>
			</orderedlist>
			<para>Uwaga: kwadratowymi nawiasami zaznaczone zostały <emphasis>parametry opcjonalne</emphasis>, które
			nie muszą być koniecznie definiowane. Ich wartość ustawia się tylko, gdy faktycznie jest taka potrzeba.</para>
			</mark>
			<sect2 id="syntax.functions.apply">
				<title>apply()</title>
				<methodsynopsis>
				<type>void</type><methodname>apply</methodname>
					<methodparam><type>lang</type><parameter>blok</parameter></methodparam>
					<methodparam><parameter>...</parameter></methodparam>
				</methodsynopsis>
				<para>Funkcja umożliwia umieszczenie dynamicznych danych we wskazanym bloku językowym.
				Wartości do wstawienia przekazywane są jako kolejne parametry. Zastępują one odpowiednie
				kody formatujące umieszczone w treści bloku językowego, identyczne z kodami funkcji <function>sprinft()</function>
				z języka C. Dokładny rezultat działania zależy od konkretnego systemu językowego
				używanego przez aplikację WWW. Jeśli korzystasz z systemu wbudowanego w OPT, możesz
				wywołać tę funkcję tylko raz na tym samym bloku, gdyż wygenerowana treść nadpisuje źródłową.
				Pisząc własny system, możesz ominąć ten problem.</para>
				<example id="example.syntax.functions.apply1">
					<title>Funkcja apply()</title>
					<programlisting><![CDATA[{* zawartość $menu@welcome: Witaj %s, dziękujemy za wizytę. *}
{apply($menu@welcome, 'Adam')}
{* Wyswietli np.: Witaj Adam, dziękujemy za wizytę. *}
<p>{$menu@welcome}</p>]]></programlisting>
				</example>
			</sect2>
			<sect2 id="syntax.functions.array">
				<title>array()</title>
				<methodsynopsis>
				<type>array</type><methodname>array</methodname>
					<methodparam><parameter>definicja tablicy</parameter></methodparam>
				</methodsynopsis>
				<para>Tworzy tablicę. Definicja tablicy opisuje jej początkową zawartość za pomocą par
				<emphasis>indeks => wartość</emphasis> oddzielonych przecinkami.</para>
				<example id="example.syntax.functions.array1">
					<title>Tworzenie prostych tablic</title>
					<programlisting><![CDATA[{@tablica is array('tytul' => 'Tytuł', 'autor' => 'Janusz', 'tresc' => 'Trochę treści.')}
<h3>{@tablica.tytul}</h3>
<p>By {@tablica.autor}</p>
<p>{@tablica.tresc}</p>]]></programlisting>
				</example>
				<para>Aby elementy były indeksowane automatycznie, podaj tylko początkową wartość numeryczną
				i oddzielaj następne wartości przecinkami bez podawania indeksu:</para>
				<example id="example.syntax.functions.array2">
					<title>Automatyczne indeksowanie</title>
					<programlisting><![CDATA[{@tablica is array(0 => 'wartość 1', 'wartość 2', 'wartość 3', 'wartość 4')}]]></programlisting>
				</example>
				<para>Podobnie jak w PHP, dozwolone jest istnienie indeksów numerycznych i tekstowych w jednej tablicy jednocześnie.</para>
			</sect2>
			<sect2 id="syntax.functions.capitalize">
				<title>capitalize()</title>
				<methodsynopsis>
				<type>string</type><methodname>capitalize</methodname>
					<methodparam><type>string</type><parameter>tekst</parameter></methodparam>
				</methodsynopsis>
				<para>Zwraca podany w parametrze <variable>tekst</variable>, w którym pierwsza litera
				została zamieniona na dużą. To, czy dany znak zostanie uznany za literę, zależy
				od ustawień regionalnych skryptu PHP.</para>
				<example id="example.syntax.functions.capitalize1">
					<title>Funkcja capitalize()</title>
					<programlisting><![CDATA[{* pokaże "Hello world" *}
{capitalize("hello world")}]]></programlisting>
				</example>
			</sect2>
			<sect2 id="syntax.functions.count">
				<title>count()</title>
				<methodsynopsis>
				<type>int</type><methodname>count</methodname>
					<methodparam><type>array</type><parameter>tablica</parameter></methodparam>
				</methodsynopsis>
				<para>Zwraca ilość elementów znajdujących się w tablicy <variable>tablica</variable>.</para>
			</sect2>
			<sect2 id="syntax.functions.countwords">
				<title>countWords()</title>
				<methodsynopsis>
				<type>int</type><methodname>countWords</methodname>
					<methodparam><type>string</type><parameter>tekst</parameter></methodparam>
				</methodsynopsis>
				<para>Zwraca ilość słów znajdujących się w tekście <variable>tekst</variable>.</para>
				<example id="example.syntax.functions.countwords1">
					<title>Funkcja countWords()</title>
					<programlisting><![CDATA[<h1>{$tytul}</h1>
<p>{$tresc}</p>
<span class="small">Łącznie słów: {countWords($tresc)}</span>]]></programlisting>
				</example>
			</sect2>
			<sect2 id="syntax.functions.cycle">
				<title>cycle()</title>
				<methodsynopsis>
				<type>mixed</type><methodname>cycle</methodname>
					<methodparam><parameter>...</parameter></methodparam>
				</methodsynopsis>
				<para>Cyklicznie pobiera kolejne parametry za każdym kolejnym wywołaniem. Dla przykładu,
				jeśli podamy parametry <emphasis>1, 2, 3</emphasis>, to pierwsze wywołanie funkcji zwróci nam
				1, drugie 2, trzecie 3, czwarte z powrotem 1 itd. Jest użyteczna w niektórych sprawach związanych
				z wyglądem. W poniższym przykładzie naprzemiennie kolorujemy za jej pomocą wiersze tabeli:</para>
				<example id="example.syntax.functions.cycle1">
					<title>Funkcja cycle()</title>
					<programlisting><![CDATA[<table border="0">
{section=wiersze}
{@klasa is cycle("jasny", "ciemny")}
<tr>
  <td class="{@klasa}">{$wiersze.nazwa}</td>
  <td class="{@klasa}">{$wiersze.wartosc}</td>
</tr>
{/section}
</table>]]></programlisting>
				</example>
				<para>Uwaga: od wersji OPT 1.1.0 funkcja <function>cycle()</function> nie jest tu niezbędna, gdyż jej
				zadanie przejął jeden z atrybutów sekcji:</para>
				<example id="example.syntax.functions.cycle2">
					<title>Funkcja cycle() jest niepotrzebna</title>
					<programlisting><![CDATA[<table border="0">
{section=wiersze}
{cycle=class; jasny; ciemny} {* wewnetrzny znacznik sekcji *}
<tr>
  <td opt:cycle="wiersze">{$wiersze.nazwa}</td>
  <td opt:cycle="wiersze">{$wiersze.wartosc}</td>
</tr>
{/section}
</table>]]></programlisting>
				</example>
				<para>Zobacz rozdział <link linkend="syntax.instructions.section" endterm="">sekcje</link>, aby uzyskać więcej informacji.</para>
			</sect2>
			<sect2 id="syntax.functions.date">
				<title>date()</title>
				<methodsynopsis>
				<type>string</type><methodname>date</methodname>
					<methodparam><type>string</type><parameter>format</parameter></methodparam>
					<methodparam choice="opt"><type>int</type><parameter>czas</parameter></methodparam>
				</methodsynopsis>
				<para>Formatuje datę zgodnie z regułami funkcji <ulink url="http://www.php.net/date">date()</ulink> dostępnej w PHP. Jeśli
				określiliśmy parametr <variable>czas</variable> (w sekundach od 1.1.1970), sformatowany zostanie właśnie on,
				w przeciwnym wypadku funkcja sformatuje aktualny czas.</para>
				<example id="example.syntax.functions.date1">
					<title>Funkcja date()</title>
					<programlisting><![CDATA[<p>Dziś jest {date("d.m.Y")}.</p>]]></programlisting>
				</example>
			</sect2>
			<sect2 id="syntax.functions.length">
				<title>length()</title>
				<methodsynopsis>
				<type>int</type><methodname>length</methodname>
					<methodparam><type>string</type><parameter>tekst</parameter></methodparam>
				</methodsynopsis>
				<para>Zwraca ilość znaków w tekście <variable>tekst</variable>.</para>
			</sect2>
			<sect2 id="syntax.functions.lower">
				<title>lower()</title>
				<methodsynopsis>
				<type>string</type><methodname>lower</methodname>
					<methodparam><type>string</type><parameter>tekst</parameter></methodparam>
				</methodsynopsis>
				<para>Zamienia wszystkie litery w podanym tekście na małe.</para>
			</sect2>
			<sect2 id="syntax.functions.parseint">
				<title>parseInt()</title>
				<methodsynopsis>
				<type>string</type><methodname>parseInt</methodname>
					<methodparam><type>number</type><parameter>liczba</parameter></methodparam>
				</methodsynopsis>
				<para>Formatuje duże liczby do postaci czytelnej dla człowieka. Domyślnie używane są
				angielskie reguły formatowania, lecz mogą one zostać zmienione następującymi dyrektywami
				konfiguracyjnymi OPT:</para>
				<orderedlist>
					<listitem><emphasis>parseIntDecimals</emphasis> - jak dużo cyfr po przecinku chcemy pokazać.</listitem>
					<listitem><emphasis>parseIntDecPoint</emphasis> - separator części ułamkowych i całkowitych (w polskim: przecinek).</listitem>
					<listitem><emphasis>parseIntThousands</emphasis> - separator między grupami tysięcy (w polskim: spacja lub kropka).</listitem>
				</orderedlist>
				<example id="example.syntax.functions.parseint1">
					<title>Funkcja parseInt()</title>
					<programlisting><![CDATA[<p>{parse_int(3483745.3490)}</p>
{* wyświetli (przy polskich ustawieniach): 3 483 745.349 *}]]></programlisting>
				</example>
			</sect2>
			<sect2 id="syntax.functions.trim">
				<title>trim()</title>
				<methodsynopsis>
				<type>string</type><methodname>trim</methodname>
					<methodparam><type>string</type><parameter>tekst</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>znaki</parameter></methodparam>
				</methodsynopsis>
				<para>Zwraca podany <variable>text</variable>, w którym z początku i końca zostały usunięte znaki podane w
				parametrze <variable>znaki</variable>. Jeśli zbiór znaków jest nieokreślony, wtedy
				usuwane są domyślnie tzw. białe znaki (spacje, tabulacje, znaki nowej linii itd.).</para>
			</sect2>
			<sect2 id="syntax.functions.upper">
				<title>upper()</title>
				<methodsynopsis>
				<type>string</type><methodname>upper</methodname>
					<methodparam><type>string</type><parameter>tekst</parameter></methodparam>
				</methodsynopsis>
				<para>Zamienia wszystie litery w podanym tekście na duże.</para>
			</sect2>
			<sect2 id="syntax.functions.wordwrap">
				<title>wordwrap()</title>
				<methodsynopsis>
				<type>string</type><methodname>wordwrap</methodname>
					<methodparam><type>string</type><parameter>tekst</parameter></methodparam>
					<methodparam><type>int</type><parameter>dlugosc</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>przelamanie</parameter></methodparam>
				</methodsynopsis>
				<para>Zwraca podany <variable>tekst</variable> połamany względem wyrazów tak, aby pasował do kolumny o szerokości
				określonej parametrem <variable>dlugosc</variable>. Do przełamania używany jest ciąg podany w parametrze <variable>przelamanie</variable>.</para>
				<example id="example.syntax.functions.wordwrap1">
					<title>Funkcja wordwrap()</title>
					<programlisting><![CDATA[{* co najwyzej 120 znaków w jednej kolumnie *}
<p>{wordwrap($artykul, 120, "\n<br/>")}</p>]]></programlisting>
				</example>
			</sect2>
		</sect1>
		<sect1 id="syntax.tags">
			<title>Znaczniki</title>
			<para>Większość logiki szablonu zbudowana jest ze znaczników OPT. Zachowują się one,
			a czasem też wyglądają, podobnie jak znaczniki XML/XTML, jednak jest między nimi kilka
			istotnych różnic, które zostaną tu wymienione. Domyślnie znaczniki OPT zamknięte są
			w nawiasach klamrowych: { oraz }. Programista może zdefiniować nowe ograniczniki do użytku
			twórczy szablonów. Poniżej widzimy parę dwóch prostych znaczników:</para>
			<example id="example.syntax.tags1">
				<title>Proste znaczniki</title>
				<programlisting><![CDATA[statyczny tekst
{znacznik}
statyczny tekst wewnątrz znaczników
{/znacznik}
statyczny tekst]]></programlisting>
			</example>
			<para>Znacznik kończący poznamy po znaku / na jego początku, po którym następuje nazwa
			elementu, który chcemy zakończyć. Podobnie jak w XML, musisz pamiętać o zamykaniu znaczników
			w kolejności odwrotnej do ich otwierania, tj. jeśli otwarłeś znacznik "a", a potem "b",
			to zamkniesz najpierw "b" i dopiero później "a". Poniższy przykład ukazuje <emphasis>błędną</emphasis>
			sytuację, która spowoduje błąd kompilacji:</para>
			<example id="example.syntax.tags2">
				<title>Nieprawidłowe zamknięcie znaczników</title>
				<programlisting><![CDATA[{a}
{b}
{/a}
{/b}]]></programlisting>
			</example>
			<para>Jeśli OPT nie wie, w jaki sposób przetworzyć dany znacznik, nie raportuje tego jako
			błędu, lecz po prostu ignoruje jego i całą zawartość. Dzieje się tak, ponieważ inne znaczniki
			mogą wiedzieć, jak go obsłużyć, więc lepiej po prostu takie "nieznane" elementy pozostawić
			w drzewie i zignorować ich zawartość. Konsewkencją tego jest, że literówki w nazwach znaczników <emphasis>nie są</emphasis>
			zgłaszane przez kompilator! Zatem, jeśli coś się nie wyświetla, a powinno, w pierwszej kolejności
			sprawdź, czy wpisałeś prawidłową nazwę znacznika.</para>
			<para>Od wersji 1.1.0 OPT wspiera przestrzenie nazw znane z XML-a. Domyślną przestrzenią nazw
			dla znaczniów jest <emphasis>opt</emphasis>, przez co znaczniki <emphasis>znacznik</emphasis> i
			<emphasis>opt:znacznik</emphasis> są dokładnie tym samym. Niezależne dodatki do OPT mogą używać
			własnych przestrzeni nazw, np. Open Power Forms korzysta z <emphasis>opf</emphasis> do własnych znaczników.</para>
			<para>OPT umożliwia też tworzenie pojedynczych znaczników, które zamykane są natychmiast:</para>
			<example id="example.syntax.tags3">
				<title>Pojedyncze znaczniki</title>
				<programlisting><![CDATA[{pojedynczy/}]]></programlisting>
			</example>
			<para>Następny rodzaj znaczników nie występuje w XML-u: znaczniki alternatywne.</para>
			<example id="example.syntax.tags4">
				<title>Znaczniki alternatywne</title>
				<programlisting><![CDATA[statyczny tekst
{znacznik}
statyczny tekst zamknięty w znacznikach
{znacznikelse}
alternatywna zawartość znacznika
{/znacznik}
statyczny tekst]]></programlisting>
			</example>
			<para>Znaczniki również mogą pobierać parametry. OPT udostępnia tutaj dwie wymienne składnie:</para>
			<orderedlist>
				<listitem>Składnia pozycyjna: <emphasis>{znacznik=parametr1; parametr2; parametr3}</emphasis> - rozpoczyna
					się znakiem równości podanym zaraz po nazwie znacznika. Następnie podajemy same wartości oddzielone od
					siebie średnikiem. Jeżeli chcemy w danym miejscu użyć wartości domyślnej opcjonalnego parametru, piszemy
					<emphasis>!x</emphasis>, na przykład: <emphasis>{znacznik=parametr1; !x; parametr3}</emphasis></listitem>
				<listitem>XML-owa składnia: <emphasis>{znacznik parametr1="wartość" parametr2="wartość" parametr="wartość"}</emphasis></listitem>
			</orderedlist>
			<para>Obie składnie mogą być stosowane wymiennie, to znaczy w jednym miejscu możemy napisać np.	<emphasis>{section=foo}</emphasis>,
			a gdzie indziej w tym samym szablonie - <emphasis>{section name="foo"}</emphasis>.
			Niektóre instrukcje mogą używać również własnych formatów paramertów, ale jest to specjalnie oznaczone i można
			to wyłączyć.</para>
			<para>Podobnie jak w przypadku funkcji, parametry znaczników również mają określony typ. Jeśli znacznik wymaga,
			aby dany parametr był ciągiem tekstowym, możemy swobodnie napisać <emphasis>{znacznik=to jest tekst}</emphasis>. Lecz gdyby
			parametr ten był określony jako "wyrażenie", jedyną poprawną formą będzie <emphasis>{znacznik="this is a text"}</emphasis>,
			lub <emphasis>{tag parameter="`this is a text`"}</emphasis> (cudzysłowy i odwrócone apostrofy. Pierwsze są dla
			parsera parametrów, drugie dla parsera wyrażeń). Jest tak dlatego, iż OPT wymaga, aby w wyrażeniach wielowyrazowe
			ciągi tekstowe były podawane w cudzysłowach lub apostrofach.</para>
			<para>Bądź ostrożny, używając znaków ograniczników wewnątrz znaczników. Kod <emphasis>{znacznik="foo {bar}"}</emphasis>
			spowoduje błąd. Jeśli myślisz, że będziesz mieć problem ze znakami specjalnymi OPT, poproś programistę o włączenie
			w konfiguracji dyrektywy <emphasis>entities</emphasis>. OPT będzie wtedy parsować znane z HTML-a encje:</para>
			<table frame="all" id="entity_list">
				<?dbhtml table-width="100%" ?>
				<caption>Encje OPT</caption>
				<tgroup cols="2" align="center">
				<thead>
				<row>
				  <entry>Encja</entry>
				  <entry>Znak</entry>
				</row>
				</thead>
				<tbody>
				<row>
				  <entry>&amp;amp;</entry>
				  <entry>&amp;</entry>
				</row>
				<row>
				  <entry>&amp;quot;</entry>
				  <entry>&quot;</entry>
				</row>
				<row>
				  <entry>&amp;apos;</entry>
				  <entry>'</entry>
				</row>
				<row>
				  <entry>&amp;lt;</entry>
				  <entry>&lt;</entry>
				</row>
				<row>
				  <entry>&amp;gt;</entry>
				  <entry>&gt;</entry>
				</row>
				<row>
				  <entry>&amp;lb;</entry>
				  <entry>{</entry>
				</row>
				<row>
				  <entry>&amp;rb;</entry>
				  <entry>}</entry>
				</row>
				</tbody>
				</tgroup>
			</table>
			<para>Dwie ostatnie encje mogą być również używane w statycznym kodzie szablonu, poza znacznikami OPT..</para>
		</sect1>
		<sect1 id="syntax.instructions">
			<title>Instrukcje</title>
			<para>Instrukcje tworzą najważniejszą część logiki szablonu. Z ich pomocą możesz określić, gdzie mają znajdować
				się listy danych, które części mają pokazywać się warunkowo itd. Instrukcje korzystają z opcji oferowanych przez
				opisane wyżej znaczniki, jednak do tego posiadają kilka dodatkowych uproszczeń, których nie można stosować
				w innych rodzajach znaczników.</para>
			<orderedlist>
				<listitem>Pojedyncze znaczniki nie muszą być kończone slashem: <emphasis>{include="`file.tpl`"}</emphasis>
					jest tym samym, co <emphasis>{include="`file.tpl`"/}</emphasis></listitem>
				<listitem>Alternatywne znaczniki nie muszą kończyć się słówkiem "else". Zależy to całkowicie od instrukcji.</listitem>
			</orderedlist>
			<para>Instrukcja może rozszerzać blok specjalny <variable>$opt</variable> i dodawać do niego nowe opcje.</para>
			<para>W OPT 1.1.0 zostały wprowadzone atrybuty. Są to atrybuty zwykłych znaczników HTML, które są rozpoznawane i
				przetwarzane przez procesory instrukcji. Rozważmy następujący przykład. Sekcja jest instrukcją do tworzenia list.
			Pragniemy wyróżnić pierwszy element listy, nadając mu inną klasę CSS. Możemy do tego użyć atrybutu <emphasis>opt:sectionfirst</emphasis>:</para>
			<example id="example.instructions1">
				<title>Single tags</title>
				<programlisting><![CDATA[<ul>
{section=list}
<li opt:sectionfirst="list">{$list.title}</li>
{/section}
</ul>]]></programlisting>
			</example>
			<para>Teraz w pierwszym elemencie listy zostanie on zastąpiony przez <emphasis>class="first"</emphasis>, natomiast
			w kolejnych nie zrobi on nic. Naszą klasę CSS możemy sobie teraz dowolnie obudować w arkuszu stylów.</para>
			<para>Uwaga: wszystkie atrybuty muszą mieć określoną przestrzeń nazw!</para>
			<para>Poniższy spis instrukcji zawiera również dodatkowe informacje dla programistów PHP (<emphasis>script-side</emphasis>),
			które głównie opisują, w jaki sposób przygotowywać dane dla instrukcji. Te informacje oznaczone są niebieskim paskiem.</para>
			<sect2 id="syntax.instructions.section">
				<title>Sekcja</title>
				<para>Sekcje są używane do tworzenia list. Rozpoczynają się znacznikiem <emphasis>{section}</emphasis> i kończą <emphasis>{/section}</emphasis>. The content between them is the look of a single element of the list.
				Sekcja posiada unikalną nazwę używaną do uzyskania dostępu do danych aktualnie wyświetlanego elementu oraz do identyfikacji,
				gdy zajdzie taka potrzeba. Kod wewnątrz znaczników określa wygląd pojedynczego elementu listy.</para>
				<example id="example.sections1">
					<title>Proste sekcje</title>
					<programlisting><![CDATA[<table>
<tr>
<td>Nazwa produktu</td>
<td>Cena produktu</td>
</tr>
{section=products}
<tr>
<td>{$products.name}</td>
<td>{$products.price}</td>
</tr>
{/section}
</table>]]></programlisting>
				</example>
				<para>Wewnątrz sekcji składnia <emphasis>{$tablica.klucz}</emphasis> zmienia swoje znaczenie i jest wykorzystywana
					do odwoływania się do danych elementu sekcji. Pierwszy człon identyfikuje nazwę sekcji, a drugi nazwę bloku elementu listy, który
					chcemy użyć. Jeśli kompilator stwierdzi, że pierwszy człon nie odnosi się do żadnej z aktywnych sekcji, wtedy kompiluje
					taki blok w tradycyjny sposób.</para>
				<para>Od wersji 1.1.3, sekcje mogą również współpracować z elementami innymi, niż tablice:</para>
				<example id="example.sections45">
					<title>Nietablicowe dane sekcji</title>
					<programlisting><![CDATA[<p>Liczby:</p>
<ul>
{section=liczby}
	<li>{$liczby}</li>
{/section}
</ul>

<p>Obiekty:</p>
<ul>
{section=obiekty}
	<li>{$obiekty -> metoda()}</li>
{/section}
</ul>]]></programlisting>
				</example>
				<para>Opcjonalny znacznik <emphasis>{sectionelse}</emphasis> może być użyty do wyświetlenia zastępczego tekstu,
					jeśli sekcja nie zawiera żadnych elementów:</para>
				<example id="example.sections2">
					<title>Sectionelse</title>
					<programlisting><![CDATA[<table>
<tr>
<td>Nazwa produktu</td>
<td>Cena produktu</td>
</tr>
{section=products}
<tr>
<td>{$products.name}</td>
<td>{$products.price}</td>
</tr>
{sectionelse}
<tr>
<td colspan="2">Na liście nie ma produktów!</td>
</tr>
{/section}
</table>]]></programlisting>
				</example>
				<para>Sekcja przyjmuje kilka parametrów:</para>
				<table frame="all" id="params.section">
					<?dbhtml table-width="100%" ?>
					<caption>Sekcja: parametry</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Nazwa</entry>
					  <entry>Typ</entry>
					  <entry>Wymagany?</entry>
					  <entry>Opis</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>name</entry>
					  <entry>ID</entry>
					  <entry>Tak</entry>
					  <entry>Nazwa sekcji.</entry>
					</row>
					<row>
					  <entry>order</entry>
					  <entry>ID</entry>
					  <entry>Nie</entry>
					  <entry>Jeśli ustawiony na "reversed", elementy sekcji wyświetlane są w odwrotnej kolejności.</entry>
					</row>
					<row>
					  <entry>state</entry>
					  <entry>Wyrażenie</entry>
					  <entry>Nie</entry>
					  <entry>Jeśli podane wyrażenie jest fałszywe, sekcja nie zostanie pokazana tak, jakby nie zawierała żadnych elementów.</entry>
					</row>
					<row>
					  <entry>datasource</entry>
					  <entry>Wyrażenie</entry>
					  <entry>Nie</entry>
					  <entry>Lokalizacja danych sekcji. Jeśli niepodana, nazwa sekcji jest używana do określenia bloku, w którym znajduje się tablica z danymi.</entry>
					</row>
					<row>
					  <entry>separator</entry>
					  <entry>Wyrażenie</entry>
					  <entry>Nie</entry>
					  <entry>Separator wstawiany między dwa sąsiednie elementy listy. Parametr jest implementacją instrukcji
						  <link linkend="syntax.instruction.separator" endterm="">separator</link>. Jest on dostępny od wersji OPT 1.1.3.
					  </entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<para>W przykładach powyżej nie byliśmy w stanie ukryć całej struktury tabeli, jeśli sekcja nie zawierała
					żadnych elementów. Jednak w OPT istnieje również znacznik <emphasis>{show}</emphasis>:</para>
				<example id="example.sections3">
					<title>{show}</title>
					<programlisting><![CDATA[{show=products}
<table>
<tr>
<td>Nazwa produktu</td>
<td>Cena produktu</td>
</tr>
{section}
<tr>
<td>{$products.name}</td>
<td>{$products.price}</td>
</tr>
{/section}
</table>
{showelse}
<p>Na liście nie ma żadnych produktów.</p>
{/show}]]></programlisting>
				</example>
				<para>W tym przypadku wszystkie parametry podajemy w instrukcji <emphasis>{show}</emphasis> i zostawiamy <emphasis>{section}</emphasis> puste.
					Co więcej, zamiast <emphasis>{sectionelse}</emphasis> musimy skorzystać z <emphasis>{showelse}</emphasis>.</para>
				<para>Teraz, jeśli dodaliśmy do sekcji niepustą listę, pokaże nam się tablica, a kod wewnątrz sekcji zostanie użyty do
					wyświetlenia jej elementów. W przeciwnym wypadku ujrzymy jedynie paragraf z komunikatem o braku danych.</para>
				<para>Możesz także zagnieżdżać sekcje. Po prostu umieść kolejny blok <emphasis>section... /section</emphasis> wewnątrz innego:</para>
				<example id="example.sections4">
					<title>Sekcje zagnieżdżone</title>
					<programlisting><![CDATA[<table>
<tr>
<td>Nazwa produktu</td>
<td>Kategorie produktu</td>
</tr>
{section=products}
<tr>
<td>{$products.name}</td>
<td><ul>
  {section=categories}
  <li>{$categories.name} (lub) {$products.categories.name}</li>
  {/section}
</ul></td>
</tr>
{/section}
</table>]]></programlisting>
				</example>
				<para>Zauważ, że istnieją dwie równoważne składnie dostępu do danych sekcji podrzędnej: <emphasis>$categories.block</emphasis>
				lub <emphasis>$products.categories.block</emphasis>. Jedyne, co musisz zrobić, to upewnić się, że pierwszy człon zawsze
					odnosi się do istniejącej sekcji, by nie został skompilowany jako odwołanie do tablicy. OPT sam zajmie się połączeniem
				elementów w obu sekcjach zgodnie z istniejącymi między nimi relacjami.</para>
				<sect3 id="syntax.instructions.section.attributes">
					<title>Atrybuty</title>
					<para>Począwszy od OPT 1.1.0, sekcje dostarczają kilku atrybutów do użycia z tagami HTML.</para>
					<sect4 id="syntax.instructions.section.attributes.first">
						<title>opt:sectionfirst</title>
						<para>Generuje kod <emphasis>class="first"</emphasis> jeśli przetwarzany jest pierwszy element
						podanej listy. Za parametr pobiera nazwę sekcji.</para>
						<example id="example.sections5">
							<title>opt:sectionfirst</title>
							<programlisting><![CDATA[<table>
<tr>
<td>Nazwa produktu</td>
<td>Cena produktu</td>
</tr>
{section=products}
<tr>
<td opt:sectionfirst="products">{$products.name}</td>
<td opt:sectionfirst="products">{$products.price}</td>
</tr>
{/section}
</table>]]></programlisting>
						</example>
					</sect4>
					<sect4 id="syntax.instructions.section.attributes.last">
						<title>opt:sectionlast</title>
						<para>Generuje kod <emphasis>class="last"</emphasis> jeśli przetwarzany jest ostatni
						element listy. Za parametr pobiera nazwę sekcji.</para>
						<example id="example.sections6">
							<title>opt:sectionlast</title>
							<programlisting><![CDATA[<table>
<tr>
<td>Nazwa produktu</td>
<td>Cena produktu</td>
</tr>
{section=products}
<tr>
<td opt:sectionlast="products">{$products.name}</td>
<td opt:sectionlast="products">{$products.price}</td>
</tr>
{/section}
</table>]]></programlisting>
						</example>
					</sect4>
					<sect4 id="syntax.instructions.section.attributes.cycle">
						<title>opt:sectioncycle</title>
						<para>Wykonuje cykliczną rotację zbioru atrybutów HTML. Umożliwa to łatwe kolorowanie
							kolejnych wierszy tabeli innymi barwami. Wartości są zdefiniowane w dodatkowym
							znaczniku umieszczonym w sekcji: <emphasis>{cycle=attributename; ...}</emphasis> - 
						pierwszy parametr określa nazwę atrybutu HTML, a kolejne dowolnie długą listę wartości do rotacji.</para>
						<example id="example.sections7">
							<title>opt:sectioncycle</title>
							<programlisting><![CDATA[<table>
<tr>
<td>Nazwa produktu</td>
<td>Cena produktu</td>
</tr>
{section=products}
{cycle='class'; 'brighter'; 'darker'}
<tr>
<td opt:sectioncycle="products">{$products.name}</td>
<td opt:sectioncycle="products">{$products.price}</td>
</tr>
{/section}
</table>]]></programlisting>
						</example>
						<para>Rezultat:</para>
<programlisting><![CDATA[<table>
<tr>
<td>Nazwa produktu</td>
<td>Cena produktu</td>
</tr>
<tr>
<td class="brighter">Produkt 1</td>
<td class="brighter">15.50</td>
</tr>
<tr>
<td class="darker">Produkt 2</td>
<td class="darker">12.00</td>
</tr>
<tr>
<td class="brighter">Produkt 3</td>
<td class="brighter">17.30</td>
</tr>
<tr>
<td class="darker">Produkt 4</td>
<td class="darker">13.99</td>
</tr>
</table>]]></programlisting>
					</sect4>
				</sect3>
				<sect3 id="syntax.instructions.section.opt">
					<title>Możliwości {$opt}</title>
					<para>Sekcje mogą powiedzieć Ci więcej dzięki specjalnemu blokowi <variable>$opt</variable>:</para>
					<table frame="all" id="opt.section">
						<?dbhtml table-width="100%" ?>
						<caption>Opis $opt.section</caption>
						<tgroup cols="2" align="center">
						<thead>
						<row>
						  <entry>Blok specjalny</entry>
						  <entry>Wartość</entry>
						</row>
						</thead>
						<tbody>
						<row>
						  <entry>$opt.section.nazwa_sekcji.count</entry>
						  <entry>Ilość elementów sekcji <emphasis>nazwa_sekcji</emphasis>.</entry>
						</row>
						<row>
						  <entry>$opt.section.nazwa_sekcji.id</entry>
						  <entry>Aktualny ID elementu.</entry>
						</row>
						<row>
						  <entry>$opt.section.nazwa_sekcji.size</entry>
						  <entry>Ilość bloków zdefiniowana w aktualnym elemencie.</entry>
						</row>
						<row>
						  <entry>$opt.section.nazwa_sekcji.first</entry>
						  <entry>Prawda, jeśli przetwarzany jest pierwszy element sekcji.</entry>
						</row>
						<row>
						  <entry>$opt.section.nazwa_sekcji.last</entry>
						  <entry>Prawda, jeśli przetwarzany jest ostatni element sekcji.</entry>
						</row>
						<row>
						  <entry>$opt.section.nazwa_sekcji.far</entry>
						  <entry>Prawda, jeśli przetwarzany jest pierwszy lub ostatni element sekcji.</entry>
						</row>
						</tbody>
						</tgroup>
					</table>
					<para>Przykładowe użycie:</para>
					<example id="example.sections8">
						<title>Sample use</title>
						<programlisting><![CDATA[{show=products}
<p>Jest tutaj {$opt.section.products.count} produktów.</p>
<ul>
{section}
  {if $opt.section.products.first}
  <li><b>Hit!</b> {$products.name}</li>
  {else}
  <li>{$products.name}</li>
  {/if}
{/section}
</ul>
{/show}]]></programlisting>
					</example>
				</sect3>
				<sect3 id="syntax.instructions.section.programmers">
					<title>Sekcje dla programistów</title>
					<mark type="blue">
					<para>Sekcje wymagają danych przygotowanych w specyficznej tablicy. Dla pojedynczej, niezagnieżdżonej
					sekcji jej budowa jest zawsze identyczna, natomiast w przypadku zagnieżdżeń OPT wspiera dwa różne
					formaty. Programista decyduje, którego z nich będzie używać domyślnie, za pomocą konfiguracji.
					Drugi format jest jednak zawsze dostępny dzięki parametrowi <parameter>datasource</parameter>.</para>
					<para>Tablica danych dla sekcji jest ma postać tablicy tablic (wielowymiarowa struktura). Oto przykładowy
					kod PHP:</para>
					<example id="example.sections_php1">
						<title>Dane dla pojedynczych sekcji</title>
						<programlisting><![CDATA[$produkty = array(0 =>
   array('nazwa' => 'Jabłuszka', 'cena' => 15),
   array('nazwa' => 'Gruszki', 'cena' => 17),
   array('nazwa' => 'Banany', 'cena' => 13)
);
$tpl -> assign('produkty', $produkty);]]></programlisting>
					</example>
					<para>Ten kod w połączeniu z sekcją utworzy nam trójelementową listę. Do każdego elementu przypisaliśmy
					po dwa bloki: <variable>nazwę</variable> oraz <variable>cenę</variable>.</para>
					<para>Jak wspominaliśmy wyżej, w przypadku sekcji zagnieżdżonych należy wybrać jeden z dwóch formatów danych.
					Domyślny określa dyrektywa konfiguracyjna <emphasis>sectionStructure</emphasis> przyjmująca jedną z dwóch
					wartości: <emphasis>OPT_SECTION_MULTI</emphasis> (domyślna) oraz <emphasis>OPT_SECTION_SINGLE</emphasis>.</para>
					<para>OPT_SECTION_MULTI: Jest to domyślny format OPT. Każda podsekcja musi zostać przypisana niezależnie
					od innych jako kolejna tablica wielowymiarowa. Musi ona posiadać tak dużo indeksów położenia, jak głęboko
					leży. Jeśli do przykładu powyżej chcielibyśmy dodać wyświetlenie kategorii, do jakich należy produkt,
					musielibyśmy stworzyć najpierw trójelementową tablicę odpowiedzialną produktom. Pierwszy indeks opisywałby,
					do jakiego produktu kategoria należy, drugi byłby wewnętrznym indeksem kategorii w obrębie danego produktu,
					a trzeci opisywałby konkretny blok pojedynczej kategorii:</para>
					<example id="example.sections_php2">
						<title>OPT_SECTION_MULTI</title>
						<programlisting><![CDATA[$kategorie = array(0 =>
   // Kategorie dla produktu 1
   array(0 =>
      array('nazwa' => 'Jedzenie'),
      array('nazwa' => 'Napoje')
   ),
   // Categories for product 2
   array(0 =>
      array('nazwa' => 'Mięso'),
      array('nazwa' => 'Obiad'),
   ),
   // Categories for product 3
   array(0 =>
      array('nazwa' => 'Warzywa'),
      array('nazwa' => 'Obiad'),
   )
);
$tpl -> assign('kategorie', $kategorie);]]></programlisting>
					</example>
					<para>Jeśli sekcja zagnieżdżona jest w dwóch innych, indeksów będzie cztery, itd.</para>
					<para>OPT_SECTION_SINGLE: w tym formacie dane sekcji oraz wszystkich innych sekcji w niej
					zagnieżdżonych przechowywane są w jednej wspólnej tablicy. Do parsera przekazujemy tylko tablicę
					dla sekcji głównej. Wewnątrz danych najwyższych elementów tworzymy też blok o nazwie identycznej,
					jak sekcja podrzędna i umieszczamy w nim dane dla danej sekcji powiązane z aktualnym elementem.</para>
					<example id="example.sections_php3">
						<title>OPT_SECTION_SINGLE</title>
						<programlisting><![CDATA[$produkty = array(0 =>
   array('nazwa' => 'Jabłuszka', 'cena' => 17, 'kategorie' =>
     // Dane dla kategorii związanych z tym produktem
     array(0 =>
       array('nazwa' => 'Owoce'),
       array('nazwa' => 'Napoje')
     )
   ),
   array('nazwa' => 'Gruszki', 'cena' => 15, 'kategorie' =>
     // Dane dla kategorii związanych z tym produktem
     array(0 =>
       array('nazwa' => 'Owoce'),
       array('nazwa' => 'Lody')
     )
   )
);
$tpl -> assign('produkty', $produkty);]]></programlisting>
					</example>
					<sect4 id="syntax.instructions.section.programmers.datasource">
						<title>Parametr "datasource"</title>
						<para>As mentioned above, you can always use both multi-array and single-array format, even if you
						chose the other as your default one. This is provided by the datasource parameter available in each
						section. If you work in <emphasis>OPT_SECTION_MULTI</emphasis> mode and you want to read subsection
						data from the upper section table, you specify here its block that contains the data:</para>
						<example id="example.sections_datasource1">
							<title>Datasource and OPT_SECTION_MULTI</title>
							<programlisting><![CDATA[<td>Product categories</td> {* for OPT_SECTION_MULTI *}
</tr>
{section=products}
<tr>
<td>{$products.name}</td>
<td><ul>
  {* read the data like in OPT_SECTION_SINGLE *}
  {section=categories; !x; !x; $products.categories}
  <li>{$categories.name} (or) {$products.categories.name}</li>
  {/section}
</ul></td>
</tr>
{/section}
</table>]]></programlisting>
						</example>
						<para>The data of categories subsection are located in <variable>$products.categories</variable> block.</para>
						<example id="example.sections_datasource2">
							<title>Datasource and OPT_SECTION_SINGLE</title>
							<programlisting><![CDATA[<td>Product categories</td> {* for OPT_SECTION_SINGLE *}
</tr>
{section=products}
<tr>
<td>{$products.name}</td>
<td><ul>
  {* read the data like in OPT_SECTION_MULTI *}
  {section=categories; !x; !x; $categories}
  <li>{$categories.name} (or) {$products.categories.name}</li>
  {/section}
</ul></td>
</tr>
{/section}
</table>]]></programlisting>
						</example>
					</sect4>
					<sect4 id="syntax.instructions.section.programmers.dynamic">
						<title>Dynamic sections</title>
						<para>OPT 1.1.0 introduces the new way of handling the section data. Instead of passing the already-generated
						lists to the parser, we pass only the function/method that will generate it, if a section with a specified name
						is used. This can be useful in modular websites - if a template does not make use of some available sections,
						the data for them are not generated. This is, what we call dynamic sections.</para>
						<para>The template designer does not know anything, which section is dynamic and which is not - this is only
						a PHP script issue. OPT supports two ways of processing dynamic sections: statically compiled (default) and
						runtime.</para>
						<para>In order to make dynamic section, we have to write a function or class method that generates the section
						data in the format described above. We pass a standard PHP callback to the parser with
						<link linkend="library.optclass.assign-dynamic" endterm="">optClass::assignDynamic()</link> method.</para>
						<para>If the dynamic sections are statically compiled, the callbacks must be defined BEFORE the template
						compilation. The calls of the functions are compiled in the template and we must not change it later (in other
						words - you must not pass callback for one request and the normal data for the second using the same section
						and template). The advantage is that "normal" sections are not touched by the compiler and work like in previous
						releases of OPT.</para>
						<para>The dynamic sections may be also handled during the runtime. Now you can use function callback, wherever
						and whenever you want, but at the cost of performance - the compiler puts a small condition at the beginning of
						each section, which checks, whether the static data or dynamic callback was provided.</para>
						<para>The way of dynamic section handling can be changed with <emphasis>sectionDynamic</emphasis> configuration
						directive and the possible values: <emphasis>OPT_SECTION_COMPILE</emphasis> (default) and
						<emphasis>OPT_SECTION_RUNTIME</emphasis>.</para>
						<example id="example.sections_php4">
							<title>Making dynamic sections</title>
							<programlisting><![CDATA[function dynamicSectionGenerator()
{
	// Section data generator
	return array(0 =>
		array('title' => 'Foo'),
		array('title' => 'Bar'),
		array('title' => 'Joe')
	);	
} // end dynamicSectionGenerator();
	
$tpl -> assignDynamic('dyn', 'dynamicSectionGenerator', array());
$tpl -> parse('template.tpl');
]]></programlisting>
						</example>
					</sect4>
					</mark>
				</sect3>
			</sect2>
			<sect2 id="syntax.instructions.tree">
				<title>Drzewo</title>
				<para>Tree instruction is a kind of section, which generates hierarchical tree structures. Everything
				that works for sections, works for trees, too. The only difference is that here we use the
				<emphasis>{tree}</emphasis>, <emphasis>{treeelse}</emphasis> and <emphasis>{/tree}</emphasis> tags
				and that they require some additional information.</para>
				<para>OPT tree support is the best to use with the modified preorder tree traversal algorithm to generate
					the trees. The algorithm calculates the "depth" parameter for each element and you have to provide it
					as one of the section blocks in order to make the tree be processed correctly. Now, OPT can count,
					whether the element is a leaf or whether it opens another level. The information, how to display the
					particular situation is defined with three tags specified inside the tree instruction:
					<emphasis>{leaf}</emphasis>, <emphasis>{opening}</emphasis> and <emphasis>{closing}</emphasis>. The last
					one tells, how to close the depth level and return to the upper. Below, we can see an example of displaying
					a tree as a HTML list.</para>
				<example id="example.trees_1">
					<title>Sample tree rendering</title>
					<programlisting><![CDATA[<ol>
{tree=mytree}
	{leaf}
		<li>{$mytree.title}</li>
	{/leaf}
	{opening}
		<li>{$mytree.title}<ol>
	{/opening}
	{closing}
		</ol></li>
	{/closing}
{treeelse}
	<li>No tree provided.</li>
{/tree}
</ol>
]]></programlisting>
				</example>
				<para>Tree instruction can work with the Show known from sections.</para>
				<example id="example.trees_2">
					<title>Trees and the show instruction</title>
					<programlisting><![CDATA[{show=mytree}
<ol>
{tree}
	{leaf}
		<li>{$mytree.title}</li>
	{/leaf}
	{opening}
		<li>{$mytree.title}<ol>
	{/opening}
	{closing}
		</ol></li>
	{/closing}
{/tree}
</ol>
{showelse}
	<li>No tree provided.</li>
{/show}]]></programlisting>
				</example>
				<para>Other section features also affect tree rendering (for example, the dynamic section support works here, too).</para>
				<para>If your templates render the various trees many times with the same layout, you can keep it in one place with
						  the <link linkend="syntax.instructions.bindgroup" endterm="">bindGroup</link>. It is linked with the
						  <emphasis>use</emphasis> tag written inside the tree instruction.</para>
				<example id="example.trees_3">
					<title>Binding the tree layout from snippets</title>
					<programlisting><![CDATA[{bindGroup=treeSnippet}
	{leaf}
		<li>{$treeSnippet.title}</li>
	{/leaf}
	{opening}
		<li>{$treeSnippet.title}<ol>
	{/opening}
	{closing}
		</ol></li>
	{/closing}
{/bindGroup}							  
							  
							  
<ol>
{tree=mytree}
  {use snippet="treeSnippet"/}
{treeelse}
	<li>No tree provided.</li>
{/tree}
</ol>
]]></programlisting>
				</example>
				<para>Note that inside the bindGroup instruction, the tree blocks begin with the snippet name. It is automatically
					replaced with the correct name, when the snippet is put into the tree.</para>
			</sect2>
			<sect2 id="syntax.instructions.pagesystem">
				<title>System stronicowania</title>
				<para><emphasis>Pagesystem</emphasis> instruction is used to integrate OPT with the pagination systems from the
						  web application. It allows to define the layout of the page list used in the templates, so that it is independent
						  from the PHP code. The instruction takes from one to three parameters:</para>
				<table frame="all" id="params.pagesystem">
					<?dbhtml table-width="100%" ?>
					<caption>Pagesystem: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>name</entry>
					  <entry>ID</entry>
					  <entry>Yes</entry>
					  <entry>The name of the pagesystem. Moreover, The pagination system is imported from the block with the specified name.</entry>
					</row>
					<row>
					  <entry>npDisplay</entry>
					  <entry>Expression</entry>
					  <entry>No</entry>
					  <entry>An expression that controls, whether the links to the next and previous page are shown (if provided). By default set to 1.</entry>
					</row>
					<row>
					  <entry>flDisplay</entry>
					  <entry>Expression</entry>
					  <entry>No</entry>
					  <entry>An expression that controls, whether the links to the first and last page are shown (if provided). By default set to 1.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<para>The layout is defined in the special tags inside the instruction. Their names and meanings are:</para>
				<orderedlist>
						  <listitem><emphasis>page</emphasis> - the look of a link to a page.</listitem>
						  <listitem><emphasis>active</emphasis> - the look of a link to an active page.</listitem>
						  <listitem><emphasis>separator</emphasis> - the look of a separator, which hides a bigger set of pages in order to make the list smaller.</listitem>
						  <listitem><emphasis>next</emphasis> - the look of a link to the next page.</listitem>
						  <listitem><emphasis>prev</emphasis> - the look of a link to the previous page.</listitem>
						  <listitem><emphasis>first</emphasis> - the look of a link to the first page.</listitem>
						  <listitem><emphasis>last</emphasis> - the look of a link to the last page.</listitem>
				</orderedlist>
				<para>The number of tags necessary to work depends on the pagination system used by the programmer, but unsually the
					first tree ones are the minimum. In all of them, the two variables are provided: <variable>{@url}</variable> with
					the URL address to the page, and <variable>{@title}</variable> with the page name. They are returned by the
					pagination system.</para>
				<example id="example.pages_1">
					<title>The simplest pagination system port.</title>
					<programlisting><![CDATA[<p>{pagesystem=ps}
{page}[ <a href="{@url}">{@title}</a> ]{/page}
{active}&lt; <strong><a href="{@url}">{@title}</a></strong> &gt;{/active}
{separator}...{/separator}
{/pagesystem}</p>]]></programlisting>
				</example>
				<example id="example.pages_2">
					<title>More advanced pagination system port.</title>
					<programlisting><![CDATA[<p>{pagesystem=ps}
{page}[ <a href="{@url}">{@title}</a> ]{/page}
{active}&lt; <strong><a href="{@url}">{@title}</a></strong> &gt;{/active}
{separator}...{/separator}
{prev}<a href="{@url}">prev</a> :: {/prev}
{next} :: <a href="{@url}">next</a>{/next}
{first}<a href="{@url}">first</a> :: {/first}
{last} :: <a href="{@url}">last</a>{/last}
{/pagesystem}</p>]]></programlisting>
				</example>
				<para>Like in trees, the pagesystem design can be kept globally in the
						  <link linkend="syntax.instructions.bindgroup" endterm="">bindGroup</link> instruction and linked with
						  <emphasis>use</emphasis> tag.</para>
				<example id="example.pages_3">
					<title>More advanced pagination system port.</title>
					<programlisting><![CDATA[{bindGroup=pagesystemDesign}
	{page}[ <a href="{@url}">{@title}</a> ]{/page}
	{active}&lt; <strong><a href="{@url}">{@title}</a></strong> &gt;{/active}
	{separator}...{/separator}
	{prev}<a href="{@url}">prev</a> :: {/prev}
	{next} :: <a href="{@url}">next</a>{/next}
	{first}<a href="{@url}">first</a> :: {/first}
	{last} :: <a href="{@url}">last</a>{/last}
{/bindGroup}							  
							  
<p>{pagesystem=ps}{use snippet="pagesystemDesign"/}{/pagesystem}</p>]]></programlisting>
				</example>
				<mark type="blue">
						  <para>When it comes to the programmers' point of view, a pagination system is an object of a class that
									 implements the <link linkend="library.ioptpagesystem" endterm="">ioptPagesystem</link> interface.
									 It provides some methods to integrate the class with the pagesystem instruction. Each of them returns
									 an assotiative array with three elements:</para>
						  <orderedlist>
								<listitem><variable>t</variable> - element type: 0 - normal page; 1 - active page; 2 - separator;</listitem>
								<listitem><variable>p</variable> - page name</listitem>
								<listitem><variable>l</variable> - the link to the page.</listitem>
					 	  </orderedlist>
							<para>If there are no pages to display or the specified part of the interface is not supported by the
									  pagination system, the methods should return nothing. Below, you can see a sample implementation
									  of the interface.</para>
							<example id="example.pages_4">
								<title>Sample implementation of ioptPagesystem interface.</title>
								<programlisting><![CDATA[<?php
	class pagesystem implements ioptPagesystem
	{
		private $buffer;		// the buffer, where the page information is generated to.
		private $prev;			// the number of the previously returned page

		// some other class methods here...

		/*
	 	 * Returns the next page from the buffer or nothing, if the script reaches the end of the buffer.
		 */
		public function getPage()
		{
			if(!is_array($this -> buffer))
			{
				$this -> prepare(); // generate the list of pages, if it does not exist
			}
			$page = key($this -> buffer); // try to get the next page
			if(!is_null($page))
			{
				if($this -> prev + 1 != $page) // there is a hole in the page numbers, insert the separator here.
				{
					$this -> prev = $page - 1;
					return array('t' => 2, 'p' => 0, 'l' => '');
				}

				$this -> prev = $page;
				next($this->buffer); // jump to the next page
				return array('t' => ($page == $this->from_pos ? 1 : 0), // return the page, checking whether it's the active one
					'p' => $page,
					'l' => $this -> l($page)
				);
			}
		} // end getPage();

		/*
	 	 * Returns the information for the "next page" link.
		 */
		public function nextPage()
		{
			if($this -> from_pos < $this -> pages)
			{
				return array('t' => 0, 'p' => $this->from_pos+1, 'l' => $this->l($this->from_pos+1));
			}
		} // end nextPage();

		/*
		 * Returns the information for the "previous page" link.
		 */
		public function prevPage()
		{
			if($this -> from_pos > 1)
			{
				return array('t' => 0, 'p' => $this->from_pos-1, 'l' => $this->l($this->from_pos-1));
			}
		} // end prevPage();

		/*
		 * Returns the information for the "first page" link.
		 */
		public function firstPage()
		{
			if($this -> pages > 1)
			{
				return array('t' => 0, 'p' => 1, 'l' => $this->l(1));
			}
		} // end firstPage();

		/*
		 * Returns the information for the "last page" link.
		 */
		public function lastPage()
		{
			if($this -> pages > 1)
			{
				return array('t' => 0, 'p' => $this->pages, 'l' => $this->l($this->pages));
			}
		} // end lastPage();
	}
?>]]></programlisting>
					</example>
					<para>The pagesystem object is loaded to the template with the standard
							  <link linkend="library.optclass.assign" endterm="">optClass::assign()</link> method.</para>
				</mark>
			</sect2>
			<sect2 id="syntax.instructions.conditions">
				<title>Instrukcja warunkowa</title>
				<para>OPT obsługuje instrukcję warunkową <emphasis>if ... elseif ... else ... /if</emphasis> znaną z języków programowania. 
				Umożliwia ona wyświetlenie fragmentu szablonu tylko wtedy, gdy podany warunek jest prawdziwy. Warunek
				użyty w instrukcji powinien dlatego zwracać wartości logiczne: <emphasis>true</emphasis> (prawda) lub <emphasis>false</emphasis> (fałsz).</para>
				<example id="example.conditions1">
					<title>Instrukcja warunkowa</title>
					<programlisting><![CDATA[{if $dostep eq 1}
{* wyświetli się tylko, gdy $dostep będzie mieć wartość 1 *}
<p>Witaj, najjaśniejszy Administratorze</p>
{elseif $dostep eq 2}
{* to się wyświetli tylko, gdy poprzedni warunek jest fałszywy, a *}
{* blok $dostep ma wartość 2 *}
<p>Witaj, redaktorze</p>
{else}
{* to się wyświetli, gdy wszystkie inne warunki będą fałszywe *}
<p>Dostęp zabroniony</p>
{/if}]]></programlisting>
				</example>
				<para>Uwagi:</para>
				<orderedlist>
					<listitem><emphasis>elseif</emphasis> oraz <emphasis>else</emphasis> są opcjonalne.</listitem>
					<listitem>Możesz dodać tak dużo węzłów <emphasis>elseif</emphasis>, jak tylko potrzebujesz.</listitem>
					<listitem><emphasis>if</emphasis> oraz <emphasis>elseif</emphasis> używają domyślnie własnego formatu parametrów.
					Można wymusić na nich stosowanie wspólnego parsera parametrów poprzez włączenie jednej z poniższych dyrektyw:
					<emphasis>strictSyntax</emphasis>, <emphasis>xmlsyntaxMode</emphasis>. Parametr, w którym należy podać wyrażenie,
					nazywa się wtedy <emphasis>test</emphasis>. Poniższy kod działa, gdy OPT pracuje w trybie ścisłej składni:
					<example id="example.conditions2">
						<title>Warunki w trybie ścisłej składni</title>
						<programlisting><![CDATA[{* parametry pozycyjne *}
{if=$dostep eq 1}
<p>Witaj najjaśniejszy Administratorze</p>
{* składnia XML *}
{elseif test="$dostep eq 2"}
<p>Witaj, redaktorze</p>
{/if}]]></programlisting>
						</example>					
					</listitem>
				</orderedlist>
			</sect2>
			<sect2 id="syntax.instructions.separator">
				<title>Separator</title>
				<para>This instruction allows to define	a content that is put between every two iterations of a loop. It always comes with a parameter "separator"
					specified in the loop tag, but it has a lower priority while compiling.</para>
				<example id="example.separator1">
					<title>Using separators</title>
					<programlisting><![CDATA[{section=navigation}
{separator} / {/separator}
{$navigation.title}
{/section}]]></programlisting>
				</example>
				<para>The result for three section elements:</para>
				<programlisting><![CDATA[Element A / Element B / Element C]]></programlisting>
				<para>The same result can be achieved with the section parameter:</para>
				<example id="example.separator2">
					<title>Separator as a parameter</title>
					<programlisting><![CDATA[{section name="navigation" separator="' / '"}
{$navigation.title}
{/section}]]></programlisting>
				</example>
				<para>The result for three section elements:</para>
				<programlisting><![CDATA[Element A / Element B / Element C]]></programlisting>
				<para>Separators can be also used with <link linkend="syntax.instructions.for" endterm="">for</link> and
				<link linkend="syntax.instructions.foreach" endterm="">foreach</link> loops exactly in the same way:</para>
				<example id="example.separator3">
					<title>Separators and other loops</title>
					<programlisting><![CDATA[{for begin="@i = 1" end="@i lt 5" iterate="@i++" separator="` / `"}
{@i}
{/for}
<br/>			
{for begin="@i = 1" end="@i lt 5" iterate="@i++"}
{separator} / {/separator}
{@i}
{/for}]]></programlisting>
				</example>
				<para>The result:</para>
				<programlisting><![CDATA[1 / 2 / 3 / 4
1 / 2 / 3 / 4]]></programlisting>
			</sect2>
			<sect2 id="syntax.instructions.var">
				<title>Var</title>
				<para>Var is used to declare variables. It takes two parameters: <parameter>name</parameter> (ID) and
				<parameter>value</parameter> (expression):</para>
				<example id="example.var1">
					<title>Declaring variables</title>
					<programlisting><![CDATA[{var=length; "500px"}
{var name="length" value="`500px`"}]]></programlisting>
				</example>
			</sect2>
			<sect2 id="syntax.instructions.include">
				<title>Include</title>
				<para>Include is used to including one template into another.</para>
				<table frame="all" id="params.include">
					<?dbhtml table-width="100%" ?>
					<caption>Include: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>file</entry>
					  <entry>Expression</entry>
					  <entry>Yes</entry>
					  <entry>The template file we want to include.</entry>
					</row>
					<row>
					  <entry>default</entry>
					  <entry>Expression</entry>
					  <entry>No</entry>
					  <entry>The default file to include, if the template pointed by the file parameter doesn't exist.</entry>
					</row>
					<row>
					  <entry>assign</entry>
					  <entry>ID</entry>
					  <entry>No</entry>
					  <entry>If specified, the template output is captured to the specified variable.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<para>When using XML-style parameters, you may specify additional parameters for the template. Their values will
				be put as template variables. Here we have a sample template to include:</para>
				
				<programlisting><![CDATA[<p>Mr {@name} has already paid us ${@amount}.</p>]]></programlisting>
				
				<para>Now we include it two times, with different data:</para>
				
				<example id="example.include1">
					<title>Including and template parameters</title>
					<programlisting><![CDATA[{* This will display "Mr John Smith has already paid us $150.30" *}
{include file="`sample.tpl`" name="`John Smith`" amount="150.3"}
{* This will display "Mr Adam Brown has already paid us $535.70" *}
{include file="`sample.tpl`" name="`Adam Brown`" amount="535.7"}]]></programlisting>
				</example>
				<para>While specifying the file names to include, remember about OPT syntax. The file name must be enclosed
				in some sort of brackets:</para>
				
				<programlisting><![CDATA[{include=`file.tpl`}]]></programlisting>
				
				<para>or</para>
				
				<programlisting><![CDATA[{include file="`file.tpl`"}]]></programlisting>
				
				<para>In the second example, the double quotes are a part of the parameter syntax. The reversed quotes are a part
				of the expression and enclose the file name in both examples.</para>
			</sect2>
			<sect2 id="syntax.instructions.place">
				<title>Place</title>
				<para>Place works like include, but here one template is physically inserted into the other, and you should not
				change its source. OPT is not able to check it and recompile, if needed.</para>
				<table frame="all" id="params.place">
					<?dbhtml table-width="100%" ?>
					<caption>Place: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>file</entry>
					  <entry>String</entry>
					  <entry>Yes</entry>
					  <entry>The template file we want to include.</entry>
					</row>
					<row>
					  <entry>assign</entry>
					  <entry>ID</entry>
					  <entry>No</entry>
					  <entry>If specified, the template output is captured to the specified variable.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<para>Note: here, the template file name must be provided <emphasis>without</emphasis> quotes!</para>
			</sect2>
			<sect2 id="syntax.instructions.default">
				<title>Default</title>
				<para>Default shows the block value or the default value, if this block is not set.</para>
				<table frame="all" id="params.default">
					<?dbhtml table-width="100%" ?>
					<caption>Default: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>test</entry>
					  <entry>Expression</entry>
					  <entry>Yes</entry>
					  <entry>The block we want to show.</entry>
					</row>
					<row>
					  <entry>alt</entry>
					  <entry>Expression</entry>
					  <entry>No</entry>
					  <entry>The alternative value, if the first block doesn't exist.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<example id="example.default1">
					<title>Default values</title>
					<programlisting><![CDATA[<p>{default=$price; "No such price"}</p>]]></programlisting>
				</example>
				<para>The example will show the text "No such price", if the block <variable>$price</variable> is not created
				by the script, or its value, if it is.</para>
			</sect2>
			<sect2 id="syntax.instructions.capture">
				<title>Capture</title>
				<para>Capture instruction collects the output of the template into a special block instead of displaying it.
				The captured content can be used in template from the special block <variable>$opt.capture.foo</variable>
				where "foo" is the name of captured content. The instruction takes one parameter:</para>
				<table frame="all" id="params.capture">
					<?dbhtml table-width="100%" ?>
					<caption>Capture: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>name</entry>
					  <entry>ID</entry>
					  <entry>Yes</entry>
					  <entry>The name of captured content.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<example id="example.capture1">
					<title>Capturing the content</title>
					<programlisting><![CDATA[{* we don't want to print a table row unless content is displayed *}
{capture=banner}
  {include file="`get_banner.tpl`"}
{/capture}
{if $opt.capture.banner ne ""}

<table>
<tr>
  <td>
   {$opt.capture.banner}
  </td>
</tr>
</table>
{/if}]]></programlisting>
				</example>
				<mark type="blue">
				<para>If you are also a programmer, you can capture whole templates in your application using
				<link linkend="library.optclass.parse-capture" endterm="">optClass::parseCapture()</link> method.</para>
				</mark>
				<para>Capture instructions can be nested. In this way the output is directed to the last opened capture block:</para>
				<example id="example.capture2">
					<title>Nested captures</title>
					<programlisting><![CDATA[{capture=foo1}
<p>Aaa</p>
	{capture=foo2}
	<p>Bbb</p>
	{/capture}
<p>Ccc</p>
{/capture}
{$opt.capture.foo1}
{$opt.capture.foo2}]]></programlisting>
				</example>
				
				<para>The script output will be:</para>
				
				<programlisting><![CDATA[Aaa
Ccc
Bbb]]></programlisting>
			</sect2>
			<sect2 id="syntax.instructions.for">
				<title>For</title>
				<mark type="red">
				<para>This is a simple loop known from programming languages. It iterates, until the end expression is
				true. The instruction takes three parameters:</para>
				<table frame="all" id="params.for">
					<?dbhtml table-width="100%" ?>
					<caption>For: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>begin</entry>
					  <entry>Expression</entry>
					  <entry>Yes</entry>
					  <entry>Starting condition (i.e. iterating variable initialization).</entry>
					</row>
					<row>
					  <entry>end</entry>
					  <entry>Expression</entry>
					  <entry>Yes</entry>
					  <entry>Ending condition. The loop iterates, until it is true.</entry>
					</row>
					<row>
					  <entry>iterate</entry>
					  <entry>Expression</entry>
					  <entry>Yes</entry>
					  <entry>Iterating expression executed every call.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<example id="example.for1">
					<title>Displaying numbers from 1 to 10</title>
					<programlisting><![CDATA[{for begin="@a is 1" end="@a <= 10" iterate="@a++"}
<p>{@a}</p>
{/for}]]></programlisting>
				</example>
				</mark>
			</sect2>
			<sect2 id="syntax.instructions.foreach">
				<title>Foreach</title>
				<mark type="red">
				<para>Another loop that iterates through an array or object and passes the element index and value to the
				template variables. Like in PHP, it takes three parameters:</para>
				<table frame="all" id="params.foreach">
					<?dbhtml table-width="100%" ?>
					<caption>Foreach: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>table</entry>
					  <entry>Expression</entry>
					  <entry>Yes</entry>
					  <entry>The array or object we want to iterate through.</entry>
					</row>
					<row>
					  <entry>index</entry>
					  <entry>ID</entry>
					  <entry>Yes</entry>
					  <entry>Index variable name.</entry>
					</row>
					<row>
					  <entry>value</entry>
					  <entry>ID</entry>
					  <entry>Yes</entry>
					  <entry>Value variable name.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<example id="example.foreach1">
					<title>Foreach and arrays</title>
					<programlisting><![CDATA[{@array is array(
 'Name' => 'John',
 'Surname' => 'Smith',
 'Age' => 31
)}

<table>
{foreach=@array; title; value}
<tr>
<td>{@title}</td>
<td><input type="text" name="{@title}" value="{@value}"/></td>
</tr>
{/foreach}
</table>]]></programlisting>
				</example>
				<para>OPT variant of foreach supports also <emphasis>{foreachelse}</emphasis> block. Its content is presented, if
				the parsed array/object contains no elements:</para>
				<example id="example.foreach2">
					<title>Foreachelse</title>
					<programlisting><![CDATA[<table>
{foreach=$array; title; value}
<tr>
<td>{@title}</td>
<td><input type="text" name="{@title}" value="{@value}"/></td>
</tr>
{foreachelse}
<tr>
<td colspan="2">Please specify the form data!</td>
</tr>
{/foreach}
</table>]]></programlisting>
				</example>
				</mark>
			</sect2>
			<sect2 id="syntax.instructions.php">
				<title>Php</title>
				<mark type="red">
				<para>The content between <emphasis>{php}</emphasis> and <emphasis>{/php}</emphasis> is treated as a PHP code and
				inserted directly in the compiler output.</para>
				</mark>
			</sect2>
			<sect2 id="syntax.instructions.literal">
				<title>Literal</title>
				<para>All the OPT tags between <emphasis>{literal}</emphasis> and <emphasis>{/literal}</emphasis> are ignored by the
				template compiler. You should use them to escape your JavaScript code.</para>
				<example id="example.literal1">
					<title>Preventing JavaScript code from being parsed by OPT</title>
					<programlisting><![CDATA[<script type="text/javascript">
{literal}
  function foo()
  {
    document.write('Sample JS function');
  }
{/literal}
</script>]]></programlisting>
				</example>
			</sect2>
			<sect2 id="syntax.instructions.dynamic">
				<title>Dynamic</title>
				<mark type="orange">
				<para>The output generated by the code between <emphasis>{dynamic}</emphasis> and <emphasis>{/dynamic}</emphasis>
				remains a dynamic content that is not cached by the output caching system. After enabling it for the template
				below:</para>
				<example id="example.dynamic1">
					<title>Dynamic content in cached templates</title>
					<programlisting><![CDATA[<p>This is a static date: {date('d.m.Y, H:i')}</p>
{dynamic}
<p>This is a dynamic date: {date('d.m.Y, H:i')}</p>
{/dynamic}]]></programlisting>
				</example>
				<para>you will see that the first date was cached and it is not changing while the page is refreshed. The second
				date is always correct, because it is not cached.</para>
				<para>Dynamic parts of template can be used with templates that are not cached, however
				they do nothing there.</para>
				</mark>
			</sect2>
			<sect2 id="syntax.instructions.bind">
				<title>Bind</title>
				<para>This is a compilation stage instruction. It captures the part of the template (not its output!) between
				<emphasis>{bind}</emphasis> and <emphasis>{/bind}</emphasis> tags and allows to
				<link linkend="syntax.instructions.insert" endterm="">insert</link> it later somewhere else. The snippet is
				still dynamic, so if you change the data to display between two insertions of the same snippet, they
				generate different output. The instruction takes one parameter:</para>
				<table frame="all" id="params.bind">
					<?dbhtml table-width="100%" ?>
					<caption>Bind: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>name</entry>
					  <entry>Id</entry>
					  <entry>Yes</entry>
					  <entry>The unique name of a captured snippet.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<example id="example.bind1">
					<title>Binding the template source</title>
					<programlisting><![CDATA[{bind=snippet}
<p>This is a text: {@variable1}</p>
{/bind}

{var=variable1; "Value 1"}

{* we will see "This is a text: Value 1" *}
{insert=snippet}

{@variable1 = "Another value"}
{* we will see "This is a text: Another value" *}
{insert=snippet}]]></programlisting>
				</example>
				<para>Note that you may put often used snippets in the master template.</para>
			</sect2>
			<sect2 id="syntax.instructions.insert">
				<title>Insert</title>
				<para>This is a compilation stage instruction. It inserts the snippet captured by the
				<link linkend="syntax.instructions.bind" endterm="">bind</link> instruction. It takes one parameter:</para>
				<table frame="all" id="params.insert">
					<?dbhtml table-width="100%" ?>
					<caption>Insert: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>name</entry>
					  <entry>Id</entry>
					  <entry>Yes</entry>
					  <entry>The name of a snippet we want to insert.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<para>The example is provided in the <link linkend="syntax.instructions.bind" endterm="">bind</link> instruction description.</para>
			</sect2>
			<sect2 id="syntax.instructions.bindevent">
				<title>BindEvent</title>
				<para>This is a compilation stage instruction. It allows to create shared events for the OPT components
				(see <link linkend="syntax.components" endterm="">Components</link>). It takes three or four parameters:</para>
				<table frame="all" id="params.bindevent">
					<?dbhtml table-width="100%" ?>
					<caption>bindEvent: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>id</entry>
					  <entry>Id</entry>
					  <entry>Yes</entry>
					  <entry>The unique ID of an event.</entry>
					</row>
					<row>
					  <entry>name</entry>
					  <entry>Id</entry>
					  <entry>Yes</entry>
					  <entry>The name of an event (for example: "onmessage").</entry>
					</row>
					<row>
					  <entry>message</entry>
					  <entry>Id</entry>
					  <entry>Yes</entry>
					  <entry>The variable name the event passes the message to.</entry>
					</row>
					<row>
					  <entry>position</entry>
					  <entry>Id</entry>
					  <entry>No</entry>
					  <entry>Display position of the event. Possible values: "up", "mid", "down".</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<para>Note that you may put the shared events in the master template.</para>
			</sect2>
			<sect2 id="syntax.instructions.bindgroup">
				<title>BindGroup</title>
				<para>This is a compilation stage instruction. It is used to store groups of tags for the
						<link linkend="syntax.instructions.tree" endterm="">Tree</link> and 
						<link linkend="syntax.instructions.pagesystem" endterm="">Pagesystem</link> instructions. It takes
						one parameter:</para>
				<table frame="all" id="params.bindgroup">
					<?dbhtml table-width="100%" ?>
					<caption>Insert: parameters</caption>
					<tgroup cols="4" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Required?</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>name</entry>
					  <entry>Id</entry>
					  <entry>Yes</entry>
					  <entry>The name of a group we want to create.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
				<para>The examples are provided in the descriptions of the Tree and Pagesystem instructions.</para>
			</sect2>
		</sect1>
		<sect1 id="syntax.components">
			<title>Komponenty</title>
			<para>A component is a high-level port, where we can bind a special object that generates the HTML code. It is
			allowed to communicate with your application and it may be created either by the template or by you in your
			application. These features are really useful when working with dynamic forms. You write several components
			that represent the form fields. Because they are allowed to communicate with the application, they can automatically
			display previously typed data, if the form needs to be refreshed because of validation errors. The components also
			have events which may be used for displaying error messages.</para>
			<para>The components were especially developed for the Open Power Forms library (currently under development) that
			provides full support for the dynamic forms. However, you may write your own components and invent many new uses.</para>
			<para>The components are placed in the template using OPT tags. The parser supports two types of components:</para>
			<orderedlist>
				<listitem>Defined components - they are created directly by the template engine.</listitem>
				<listitem>Undefined components - created by the application and assigned to the undefined component tag
				in the template manually. Thus, the application may decide, which component will be displayed in specified
				place.</listitem>			
			</orderedlist>
			<para>When it comes to the programming issues, components are objects of classes that implement
			<classname>ioptComponent</classname> interface. The last thing: <emphasis>remember that component support is only
			a platform. The way the feature elements are used, in fact depends on the component authors and does not have to
			be the same, as we planned.</emphasis></para>
			<sect2 id="syntax.components.defined">
				<title>Defined components</title>
				<para>A sample of a defined component we can see in the following example:</para>
				<example id="example.components.defined1">
					<title>A defined component</title>
					<programlisting><![CDATA[{selectComponent name="interests"}
  {param name="selected" value="$selected"/}
  {listItem name="1" value="Cars"/}
  {listItem name="2" value="Sports"/}
  {listItem name="3" value="Computers"/}

  {onMessage message="msg" position="up"}
    <p>Error: {@msg}</p>
  {/onMessage}
{/selectComponent}]]></programlisting>
				</example>
				<para>A component in the template is built of the main opening and ending tag named like the component type we
				want to use. In the example above we wanted to display a selection component, so we used tags
				<emphasis>{selectComponent}.... {/selectComponent}</emphasis>. To display an input component, we would write
				<emphasis>{inputComponent}...{/inputComponent}</emphasis> etc. Between them, there are more special tags that
				set the parameters of the component. The exact way they are implemented depends on the component we use, as we
				mentioned above.</para>
				<para>In fact, the programmer can (and even should!) write a component that configures itself automatically,
				reading the data directly from the web application, so that the component tags would be much shorter, than above.
				The shortest component definition you can create is to put a tag and load an external event created by
				<link linkend="syntax.instructions.bindevent" endterm="">bindEvent</link> instruction.</para>
				<example id="example.components.defined2">
					<title>Self-configuring component</title>
					<programlisting><![CDATA[
{bindEvent id="universalMessage" name="onmessage" message="msg" position="down"}
<span class="error">{@msg}</span>
{/bindEvent}

<table>
 <tr>
  <td>Your name:</td>
  <td>{selfConfiguringComponent name="name"}{load event="universalMessage"/}{/selfConfiguringComponent}</td>
 </tr>
 <tr>
  <td>Your surname:</td>
  <td>{selfConfiguringComponent name="surname"}{load event="universalMessage"/}{/selfConfiguringComponent}</td>
 </tr>
 <tr>
  <td>Your e-mail:</td>
  <td>{selfConfiguringComponent name="email"}{load event="universalMessage"/}{/selfConfiguringComponent}</td>
 </tr>
</table>]]></programlisting>
				</example>
				<para>However, such components must be created by a programmer, because OPT simply does not know, what is
				the architecture of the web application.</para>
			</sect2>
			<sect2 id="syntax.components.undefined">
				<title>An undefined component</title>
				<para>An undefined component formally does not exist. It is only a place, where we can (but do not have to) assign
				a component created in the application. The main tags are named <emphasis>{component}...{/component}</emphasis> and
				have to contain an id parameter that tells, what block the engine must take the component from.</para>
				<example id="example.components.undefined1">
					<title>An undefined component</title>
					<programlisting><![CDATA[{component id="$list" name="interests"}
  {param name="selected" value="$selected"/}
  {listItem name="1" value="Cars"/}
  {listItem name="2" value="Sports"/}
  {listItem name="3" value="Computers"/}

  {onMessage message="msg" position="up"}
    <p>Error: {@msg}</p>
  {/onMessage}
{/component}]]></programlisting>
				</example>
				<para>Now, if we assing a <classname>selectComponent</classname> object to the <variable>$list</variable> block,
				there will be displayed select-style list. If we assign a component called (for example)
				<classname>radioListComponent</classname>, there will be a group of radio inputs that simulate the list.
				Both of them will take the same settings given by the undefined component. If the $list block is null, nothing is
				displayed.</para>
			</sect2>
			<sect2 id="syntax.components.tagref">
				<title>Component tag reference</title>
				<para>A component consists of several types of tags. Here we would like to describe them.</para>
				
				<sect3 id="syntax.components.tagref.defined">
					<title>Defined component tag</title>
					<para>A defined component tag (for example <emphasis>{selectComponent}</emphasis>) takes 0 or more parameters:</para>

					<table frame="all" id="params.components.defined">
						<?dbhtml table-width="100%" ?>
						<caption>Defined component tag: parameters</caption>
						<tgroup cols="4" align="center">
						<thead>
						<row>
						  <entry>Name</entry>
						  <entry>Type</entry>
						  <entry>Required?</entry>
						  <entry>Description</entry>
						</row>
						</thead>
						<tbody>
						<row>
						  <entry>datasource</entry>
						  <entry>Expression</entry>
						  <entry>No</entry>
						  <entry>A source for the component data.</entry>
						</row>
						</tbody>
						</tgroup>
					</table>
					<para>Additional parameters represent unsually HTML tag parameters and depend on the component we use.</para>
					<para>A component making use from the <variable>datasource</variable> parameter can read the data for example
					from an external array instead of using <emphasis>{listItem}</emphasis> tags.</para>
					<example id="example.components.tagref.dcom1">
						<title>Datasource parameter</title>
						<programlisting><![CDATA[{selectComponent name="interests" datasource="$listItems"}
  {param name="selected" value="$selected"/}

  {onMessage message="msg" position="up"}
    <p>Error: {@msg}</p>
  {/onMessage}
{/selectComponent}]]></programlisting>
					</example>
				</sect3>
				
				<sect3 id="syntax.components.tagref.undefined">
					<title>Undefined component tag</title>
					<para>An undefined component tag takes at least one parameter:</para>

					<table frame="all" id="params.components.undefined">
						<?dbhtml table-width="100%" ?>
						<caption>Unefined component tag: parameters</caption>
						<tgroup cols="4" align="center">
						<thead>
						<row>
						  <entry>Name</entry>
						  <entry>Type</entry>
						  <entry>Required?</entry>
						  <entry>Description</entry>
						</row>
						</thead>
						<tbody>
						<row>
						  <entry>id</entry>
						  <entry>Expression</entry>
						  <entry>Yes</entry>
						  <entry>A block that contains the exact component.</entry>
						</row>
						<row>
						  <entry>datasource</entry>
						  <entry>Expression</entry>
						  <entry>No</entry>
						  <entry>A source for the component data.</entry>
						</row>
						</tbody>
						</tgroup>
					</table>
					<para>Additional parameters represent unsually HTML tag parameters and depend on the component we use.</para>
				</sect3>
				
				<sect3 id="syntax.components.tagref.param">
					<title>{param} tag</title>
					<para>The tag allows to set additional parameters for the component.</para>

					<table frame="all" id="params.components.param">
						<?dbhtml table-width="100%" ?>
						<caption>Parameter tag: parameters</caption>
						<tgroup cols="4" align="center">
						<thead>
						<row>
						  <entry>Name</entry>
						  <entry>Type</entry>
						  <entry>Required?</entry>
						  <entry>Description</entry>
						</row>
						</thead>
						<tbody>
						<row>
						  <entry>name</entry>
						  <entry>Expression</entry>
						  <entry>Yes</entry>
						  <entry>The name of the parameter we set.</entry>
						</row>
						<row>
						  <entry>value</entry>
						  <entry>Expression</entry>
						  <entry>Yes</entry>
						  <entry>The value we want to assign.</entry>
						</row>
						</tbody>
						</tgroup>
					</table>
					<para>For example, <classname>selectComponent</classname> uses it to get to know, which list element is selected.</para>
				</sect3>
				
				<sect3 id="syntax.components.tagref.listitem">
					<title>{listItem} tag</title>
					<para>If the component operates on lists, you may define static list items using this tag.</para>

					<table frame="all" id="params.components.listitem">
						<?dbhtml table-width="100%" ?>
						<caption>Listitem tag: parameters</caption>
						<tgroup cols="4" align="center">
						<thead>
						<row>
						  <entry>Name</entry>
						  <entry>Type</entry>
						  <entry>Required?</entry>
						  <entry>Description</entry>
						</row>
						</thead>
						<tbody>
						<row>
						  <entry>name</entry>
						  <entry>Expression</entry>
						  <entry>Yes</entry>
						  <entry>The name of the list item we set.</entry>
						</row>
						<row>
						  <entry>value</entry>
						  <entry>Expression</entry>
						  <entry>Yes</entry>
						  <entry>The value we want to assign.</entry>
						</row>
						<row>
						  <entry>selected</entry>
						  <entry>Expression</entry>
						  <entry>No</entry>
						  <entry>Is this element selected by default? This setting may be overwritten by the
						  <emphasis>selected</emphasis> parameter, if supported.</entry>
						</row>
						</tbody>
						</tgroup>
					</table>
				</sect3>
				
				<sect3 id="syntax.components.tagref.load">
					<title>{load} tag</title>
					<para>Sometimes you use the same event in many different places. You may write it only once and store it in the
					compiler memory under a specified ID using <link linkend="syntax.instructions.bindevent" endterm="">bindEvent</link>
					instruction. This tag allows to load such shared events into the component.</para>

					<table frame="all" id="params.components.load">
						<?dbhtml table-width="100%" ?>
						<caption>Event loader tag: parameters</caption>
						<tgroup cols="4" align="center">
						<thead>
						<row>
						  <entry>Name</entry>
						  <entry>Type</entry>
						  <entry>Required?</entry>
						  <entry>Description</entry>
						</row>
						</thead>
						<tbody>
						<row>
						  <entry>name</entry>
						  <entry>Id</entry>
						  <entry>Yes</entry>
						  <entry>The ID of a shared event.</entry>
						</row>
						</tbody>
						</tgroup>
					</table>
					
					<example id="example.components.tagref.load1">
						<title>Loading shared events</title>
						<programlisting><![CDATA[{bindEvent id="messageEv" name="onMessage" message="msg" position="down"}
<p>Error: {@msg}</p>
{/bindEvent}
...
{selectComponent name="interests"}
   {load event="messageEv"/}
{/selectComponent}
...
{inputComponent name="age"}
   {load event="messageEv"/}
{/inputComponent}]]></programlisting>
					</example>
					
					<para>This code could be also written as:</para>
					
					<example id="example.components.tagref.load2">
						<title>No shared events</title>
						<programlisting><![CDATA[{selectComponent name="interests"}
   {onMessage message="msg" position="down"}
    <p>Error: {@msg}</p>
   {/onMessage}
{/selectComponent}
...
{inputComponent name="age"}
   {onMessage message="msg" position="down"}
    <p>Error: {@msg}</p>
   {/onMessage}
{/inputComponent}]]></programlisting>
					</example>
					<para>However, as you see, it is less clear and harder to modify (especially if there is a large number of
					components and we want to make the events display above, not under the component). Note that you may put the
					shared events in the master template.</para>
				</sect3>
				
				<sect3 id="syntax.components.tagref.events">
					<title>Event tags</title>
					<para>All other tags defined inside the component are called event tags. An event is a piece of HTML that may be
					shown around the component, if some event occured (for example, the data are invalid). They are mostly used to
					display error messages, when the specified form data do not match to the patterns.</para>

					<table frame="all" id="params.components.events">
						<?dbhtml table-width="100%" ?>
						<caption>Unefined component tag: parameters</caption>
						<tgroup cols="4" align="center">
						<thead>
						<row>
						  <entry>Name</entry>
						  <entry>Type</entry>
						  <entry>Required?</entry>
						  <entry>Description</entry>
						</row>
						</thead>
						<tbody>
						<row>
						  <entry>name</entry>
						  <entry>Id</entry>
						  <entry>Yes</entry>
						  <entry>The name of an event (for example: "onmessage").</entry>
						</row>
						<row>
						  <entry>message</entry>
						  <entry>Id</entry>
						  <entry>Yes</entry>
						  <entry>The variable name the event passes the message to.</entry>
						</row>
						<row>
						  <entry>position</entry>
						  <entry>Id</entry>
						  <entry>No</entry>
						  <entry>Display position of the event. Possible values: "up", "mid", "down".</entry>
						</row>
						</tbody>
						</tgroup>
					</table>
				</sect3>
			</sect2>
			
			<sect2 id="syntax.components.reference">
				<title>Component reference</title>
				<para>OPT has a small set of predefined components that demonstrate, how to use this feature. In the real application,
				you should write your own components or install Open Power Forms library. All the components treat main component tag
				parameters as HTML attributes and <emphasis>{param}</emphasis> tag parameters as additional settings:</para>
				
				<orderedlist>
					<listitem><emphasis>message</emphasis> - if defined, the onMessage event is activated and the specified message
					is displayed.</listitem>
					<listitem><emphasis>selected</emphasis> - for lists only: overwrites the currently selected element ID
					set by the <emphasis>{listItem}</emphasis> tag.</listitem>
				</orderedlist>
				
				<para>If it is a list, it makes use of the datasource parameter and listItem tag. All of them have also a message
				onMessage.</para>
				
				<para>The following components are implemented in OPT by default:</para>
				
				<orderedlist>
					<listitem><classname>selectComponent</classname> - HTML select list.</listitem>
					<listitem><classname>textInputComponent</classname> - HTML input component.</listitem>
					<listitem><classname>textLabelComponent</classname> - static text with a hidden form field.</listitem>
					<listitem><classname>formActionsComponent</classname> - form action buttons.</listitem>
				</orderedlist>
			</sect2>
		</sect1>
		<sect1 id="syntax.xmlmode">
			<title>Tryb kompatybilności z XML</title>
			<para>This is a special compiler mode enabled by the <emphasis>xmlsyntaxMode</emphasis> configuration directive. It
			adds several XML-style tag delimiters that may be used to make your template fully XML-compilant. Standard { and }
			delimiters are still available. <emphasis>Remember that this is only an emulation. OPT does not have, if fact, a
			real XML parser, and it is not able to detect many of invalid XML syntax usages.</emphasis></para>
			<para>The delimiters defined by this mode are:</para>
			<programlisting><![CDATA[<namespace:YOURCODEHERE>
</namespace:YOURCODEHERE>
<namespace:YOURCODEHERE/>]]></programlisting>
			<para>By default, OPT registers only the <emphasis>opt</emphasis> namespace, but if you use some unofficial add-ons,
			they might have their own ones. A sample section in this mode looks like this:</para>
			<example id="example.xmlsyntax1">
				<title>Sections and XML Syntax Mode</title>
				<programlisting><![CDATA[<ul>
<opt:section name="list">
<li>{$list.item}</li>
</opt:section>
</ul>]]></programlisting>
			</example>
			<para>XML syntax mode enables also two additional configuration directives: <emphasis>strictSyntax</emphasis> (all the instructions
			are forced to use native parameter parser) and <emphasis>entities</emphasis> (parsing HTML entities).</para>
			<para>In OPT 1.0.0, the CDATA section was also parsed by OPT, like the <emphasis>{literal}</emphasis> instruction, but
			starting from 1.0.1, it is not parsed anymore because of problems with XHTML code generating.</para>
		</sect1>
		<sect1 id="syntax.mastertpl">
			<title>Szablony kompilacyjne</title>
			<mark type="orange">
			<para>Starting from 1.1.0, OPT supports master templates. They are automatically loaded, when any of the website templates
			has changed and needs to be compiled. Some instructions, like <link linkend="syntax.instructions.bind" endterm="">binds</link>
			and <link linkend="syntax.instructions.bindevent" endterm="">bindEvents </link> exist only during the compilation time and
			there is no way to autoinclude them with <link linkend="syntax.instructions.include" endterm="">include</link>. The master
			template is the only solution to create an universal repository of them for all the templates.</para>
			<mark type="blue">
			<para>Which template is the master, the script programmer defines with
			<link linkend="library.optclass.set-master-template" endterm="">optClass::setMasterTemplate()</link> method. The programmer
			may set more than one master templates for the application.</para>
			</mark>
			<para>Take a look at the example. You do not have to declare all the content for the 
			<link linkend="syntax.instructions.tree" endterm="">tree</link> instruction - the parts can be loaded from the bind snippets.
			Using a master template, we create a universal tree layout for all the website:</para>
			<example id="example.mastertpl1">
				<title>A master template</title>
				<programlisting><![CDATA[{bindGroup=universalTree}
{bind=opening}
<li>{$item.title}<ul>
{/bind}
{bind=leaf}
<li>{$item.title}</li>
{/bind}
{bind=levelclose}
</ul></li>
{/bind}				
{/bindGroup}]]></programlisting>
			</example>
			<para>Now, everytime we want to put somewhere a tree, we write:</para>
			<example id="example.mastertpl2">
				<title>Universal tree use</title>
				<programlisting><![CDATA[
<ul>
{tree=sometree}
	{use group="universalTree"/}			
{/tree}
</ul>]]></programlisting>
			</example>
			<para>If this template needs to be compiled, the compiler will load a master template with the universal tree structure
			so that the template could use it.</para>
			</mark>
		</sect1>
	</chapter>
	<chapter id="library">
		<title>Opis biblioteki</title>
		<sect1 id="library.optclass">
			<title>Klasa optClass</title>
			<para>Biblioteka OPT rozbita jest na kilka plików:</para>
			<orderedlist>
				<listitem><filename>opt.class.php</filename> - główna klasa parsera: <classname>optClass</classname>. Ten plik
					powinieneś załączać, aby używać OPT.</listitem>
				<listitem><filename>opt.compiler.php</filename> - kompilator szablonów ładowany tylko wtedy, gdy jest potrzebny.</listitem>
				<listitem><filename>opt.core.php</filename> - kilka rzadziej używanych opcji ładowanych, gdy zajdzie potrzeba.</listitem>
				<listitem><filename>opt.error.php</filename> - obsługa błędów OPT. Ładowana, gdy jest potrzeba</listitem>
				<listitem><filename>opt.instructions.php</filename> - implementacje instrukcji i systemu komponentów. Ładowane tylko
					w momencie kompilowania szablonów</listitem>
				<listitem><filename>opt.components.php</filename> - przykładowe implementacje komponentów (nie są dołączane automatycznie!)</listitem>
				<listitem><filename>opt.api.php</filename> - API do budowy własnych parserów opartych o kompilator OPT.</listitem>
			</orderedlist>
			<para>Alfabetyczna lista klas definiowanych przez bibliotekę:</para>
			<orderedlist>
				<listitem><classname>optApi</classname> (uproszczony parser OPT)</listitem>
				<listitem><classname>optBind</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optBindEvent</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optBlock</classname></listitem>
				<listitem><classname>optCapture</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optClass</classname></listitem>
				<listitem><classname>optCompiler</classname></listitem>
				<listitem><classname>optComponent</classname> (klasa kompilacji komponentów)</listitem>
				<listitem><classname>optDefault</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optDynamic</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optDynamicData</classname></listitem>
				<listitem><classname>optFor</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optForeach</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optIf</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optInclude</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optInsert</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optInstruction</classname></listitem>
				<listitem><classname>optNode</classname></listitem>
				<listitem><classname>optPagelist</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optPlace</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optSection</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optTextNode</classname></listitem>
				<listitem><classname>optTree</classname> (klasa instrukcji)</listitem>
				<listitem><classname>optVar</classname> (klasa instrukcji)</listitem>
			</orderedlist>
			<para>Lista interfejsów definiowanych przez bibliotekę:</para>
			<orderedlist>
				<listitem><classname>ioptComponent</classname> - interfejs komponentów</listitem>
				<listitem><classname>ioptI18n</classname> - interfejs systemu językowego</listitem>
				<listitem><classname>ioptNode</classname> - interfejs węzłów kompilatora</listitem>
				<listitem><classname>ioptPagesystem</classname> - interfejs systemu stronicowania dla instrukcji
					<link linkend="syntax.instructions.pagesystem" endterm="">pagesystem</link>.</listitem>
			</orderedlist>
			<sect2 id="library.optclass.fields">
				<title>Pola klasy</title>
				<para>All the configuration directives are the fields of this class. Addtitional fields which should be
				accessed only by the compiler, instructions and components:</para>
				<table frame="all" id="fields.optclass">
					<?dbhtml table-width="100%" ?>
					<caption>optClass: fields</caption>
					<tgroup cols="3" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>$capture</entry>
					  <entry>Array</entry>
					  <entry>The captured content memory.</entry>
					</row>
					<row>
					  <entry>$compiler</entry>
					  <entry>optCompiler</entry>
					  <entry>The compiler object (loaded only, if there is a need to compile something).</entry>
					</row>
					<row>
					  <entry>$data</entry>
					  <entry>Array</entry>
					  <entry>The block memory.</entry>
					</row>
					<row>
					  <entry>$vars</entry>
					  <entry>Array</entry>
					  <entry>The variable memory.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
			</sect2>
			<sect2 id="library.optclass.assign">
				<title>assign()</title>
				<methodsynopsis>
				<type>void</type><methodname>assign</methodname>
					<methodparam><type>string</type><parameter>$name</parameter></methodparam>
					<methodparam><type>mixed</type><parameter>$value</parameter></methodparam>
				</methodsynopsis>
				<para>Assigns the value to the <variable>$name</variable> block in the template. Use it also for assigning the section data. The
				method must be called before parsing the template. Already defined blocks are not lost after the template
				execution and you can still use them.</para>
				<example id="example.library.assign">
					<title>assign()</title>
					<programlisting><![CDATA[<?php
  // Initialize OPT here
  $tpl -> assign('date', date('d.m.Y, H:i'));
  $tpl -> parse('template.tpl');
?>]]></programlisting>
				</example>
				<para>template.tpl:</para>
				<programlisting><![CDATA[<p>Today is {$date}</p>]]></programlisting>
			</sect2>
			<sect2 id="library.optclass.assign-dynamic">
				<title>assignDynamic()</title>
				<methodsynopsis>
				<type>void</type><methodname>assignDynamic</methodname>
					<methodparam><type>string</type><parameter>$name</parameter></methodparam>
					<methodparam><type>mixed</type><parameter>$callback</parameter></methodparam>
					<methodparam choice="opt"><type>array</type><parameter>$args</parameter></methodparam>
				</methodsynopsis>
				<para>Assigns the valid PHP callback <variable>$callback</variable> to the dynamic section or tree <variable>$name</variable>.
				The optional array <variable>$args</variable> are the arguments for the function/method. The assigned function or method
				must return a valid section/tree data.</para>
				<para>If the dynamic sections are precompiled (default OPT setting), the callbacks must be set BEFORE the template
				execution/compilation starts.</para>
				<para>Note: this method is not available, if the <emphasis>Dynamic sections</emphasis> were removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.assign-group">
				<title>assignGroup()</title>
				<methodsynopsis>
				<type>void</type><methodname>assignGroup</methodname>
					<methodparam><type>array</type><parameter>$blocks</parameter></methodparam>
				</methodsynopsis>
				<para>Assigns a group of blocks from an assotiative array <variable>$blocks</variable>. The indexes become block
				names, and the values their values.</para>
				<example id="example.library.assign-group">
					<title>assignGroup()</title>
					<programlisting><![CDATA[<?php
  // Initialize OPT here
  $tpl -> assignGroup(array(
    'name' => 'Adam',
    'surname' => 'Smith',
    'age' => 28
  ));
  $tpl -> parse('template.tpl');
?>]]></programlisting>
				</example>
				<para>template.tpl:</para>
				<programlisting><![CDATA[<p>{$name} {$surname} (Age: {$age})</p>]]></programlisting>
			</sect2>
			<sect2 id="library.optclass.assign-ref">
				<title>assignRef()</title>
				<methodsynopsis>
				<type>void</type><methodname>assignRef</methodname>
					<methodparam><type>string</type><parameter>$name</parameter></methodparam>
					<methodparam><type>mixed</type><parameter>&amp;$value</parameter></methodparam>
				</methodsynopsis>
				<para>Assings the value to the block by reference. It is unsually faster, if we assign big data, such as
				article texts. However, we must pay attention to the PHP reference-connected issues. For more details see
				<ulink url="http://www.php.net/manual/en/language.references.php">PHP Manual</ulink>.</para>
			</sect2>
			<sect2 id="library.optclass.cache-reset">
				<title>cacheReset()</title>
				<methodsynopsis>
				<type>void</type><methodname>assignRef</methodname>
					<methodparam choice="opt"><type>string</type><parameter>$filename</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$id</parameter></methodparam>
					<methodparam choice="opt"><type>int</type><parameter>$expire</parameter></methodparam>
				</methodsynopsis>
				<para>Removes the output cache directory content. Depending on the number of specified parameters, it works
				in several ways (null is the default value of each parameter):</para>
				<itemizedlist>
					<listitem><variable>$filename</variable> is null, <variable>$id</variable> is null - removes whole cache.</listitem>
					<listitem><variable>$filename</variable> is null - removes all cached outputs with specified ID pattern.</listitem>
					<listitem><variable>$id</variable> is null - removes all cached versions of specified template.</listitem>
					<listitem>Both <variable>$filename</variable> and <variable>$id</variable> specified - removes the <variable>$id</variable>
						version of template <variable>$filename</variable>.</listitem>
				</itemizedlist>
				<para><variable>$id</variable> is any valid path pattern used by PHP <ulink url="http://www.php.net/glob">glob()</ulink>
				function. Curly braces are allowed: {a,b,c} means "a", "b", or "c". "*" is an alias of any string.</para>
				<para>Let's say that you use the template article.tpl to display articles. You save the article 1 under cache ID "1",
				the article "2" under "2", and the article 3 under cache ID "3" (see
				<link linkend="tutorials.outputcaching" endterm="">Output caching in OPT</link> for more details). To delete the cached
				version of article 1, call</para>
				
				<programlisting><![CDATA[$tpl -> cacheReset('article.tpl', '1');]]></programlisting>
				
				<para>To remove all cached articles, call</para>
				
				<programlisting><![CDATA[$tpl -> cacheReset('article.tpl');]]></programlisting>
				
				<para>To remove articles 2 and 3, call</para>
				
				<programlisting><![CDATA[$tpl -> cacheReset('article.tpl', '{2,3}');]]></programlisting>
				
				<para>Third parameter, <variable>$expire</variable> allows you to delete only templates with specified age and
				older. Thus, the newest files, with creation date bigger than <ulink url="http://www.php.net/time">time()</ulink>
				- <variable>$expire</variable> will not be removed even, if they match the pattern. If this parameter is not
				specified, all the templates matching the pattern are removed.</para>
				
				<para>Note: this method is not available, if the <emphasis>Output Caching</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.cache-status">
				<title>cacheStatus()</title>
				<methodsynopsis>
				<type>void</type><methodname>cacheStatus</methodname>
					<methodparam><type>bool</type><parameter>$status</parameter></methodparam>
					<methodparam choice="opt"><type>int</type><parameter>$expire</parameter></methodparam>
				</methodsynopsis>
				<para>Allows to enable/disable output caching for the next executed template and set its expire
				time (the default is 2 seconds).</para>
				<example id="example.library.cache-status">
					<title>cacheStatus()</title>
					<programlisting><![CDATA[  $tpl -> cacheStatus(true, 15);
  $tpl -> parse('template.tpl');]]></programlisting>
				</example>
				<para>In this example we cache the template <filename>template.tpl</filename> for 15 seconds. After this
				time, the cached version is expired and the template engine must generate newer version.</para>
				<para>Note that after template execution output caching does not become disabled automatically. In order
				to disable it, call</para>
				
				<programlisting><![CDATA[$tpl -> cacheStatus(false);]]></programlisting>
				
				<para>before parsing the next template.</para>
				
				<para>Note: this method is not available, if the <emphasis>Output Caching</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.cache-unique">
				<title>cacheUnique()</title>
				<methodsynopsis>
				<type>void</type><methodname>cacheUnique</methodname>
					<methodparam choice="opt"><type>string</type><parameter>$id</parameter></methodparam>
				</methodsynopsis>
				<para>Sometimes we store different contents in a specified template. To cache all the variants of the data assigned
				to a template, we specify an unique content ID using this method. If no parameter specified, the ID utility is
				disabled.</para>
				<para>Let's say we have three articles displayed with <filename>article.tpl</filename> template. All of them must
				be cached. This example shows, how to do it:</para>
				<example id="example.library.cache-unique">
					<title>cacheUnique()</title>
					<programlisting><![CDATA[  $tpl -> cacheStatus(true, 30);
  // Store the article 1
  $tpl -> cacheUnique(1);
  $tpl -> assign('content', $article1);
  $tpl -> parse('article.tpl');
  // Store the article 2
  $tpl -> cacheUnique(2);
  $tpl -> assign('content', $article2);
  $tpl -> parse('article.tpl');
  // Store the article 3
  $tpl -> cacheUnique(3);
  $tpl -> assign('content', $article3);
  $tpl -> parse('article.tpl');]]></programlisting>
				</example>
				<para>More details about output caching in <link linkend="tutorials.outputcaching" endterm="">Output caching in OPT</link>
				chapter.</para>
				
				<para>Note: this method is not available, if the <emphasis>Output Caching</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.compile-cache-reset">
				<title>compileCacheReset()</title>
				<methodsynopsis>
				<type>void</type><methodname>compileCacheReset</methodname>
					<methodparam choice="opt"><type>string</type><parameter>$filename</parameter></methodparam>
				</methodsynopsis>
				<para>Removes the content of compiled template cache directory. If the <variable>$filename</variable> is specified,
				removes only the compiled version of a specified template.</para>
			</sect2>
			<sect2 id="library.optclass.error">
				<title>error()</title>
				<methodsynopsis>
				<type>void</type><methodname>error</methodname>
					<methodparam><type>int</type><parameter>$level</parameter></methodparam>
					<methodparam><type>string</type><parameter>$message</parameter></methodparam>
					<methodparam><type>int</type><parameter>$code</parameter></methodparam>
				</methodsynopsis>
				<para>The method is used by OPT to generate exceptions. The <variable>$level</variable>
				is one of: <emphasis>E_USER_ERROR</emphasis> or <emphasis>E_USER_WARNING</emphasis>.
				For the user error messages, the codes from 401 are reserved.</para>
			</sect2>
			<sect2 id="library.optclass.fetch">
				<title>fetch()</title>
				<methodsynopsis>
				<type>mixed</type><methodname>fetch</methodname>
					<methodparam><type>string</type><parameter>$filename</parameter></methodparam>
					<methodparam choice="opt"><type>bool</type><parameter>$display = false</parameter></methodparam>
				</methodsynopsis>
				<para>Executes the template in the <variable>$filename</variable> file and returns it as a function result
				(<emphasis>$display = false</emphasis>) or sends it to the browser (<emphasis>$display = true</emphasis>).
				The second parameter is used mostly by OPT and you do not have to worry about it. Contrary to the first OPT
				versions, you may use both returning as function result and to the browser at the same time and at the
				same template.</para>
				<para>The executed template sees the blocks assigned before calling this method, but it does not remove them
				after parsing, so you may use them again.</para>
				<example id="example.library.fetch">
					<title>fetch()</title>
					<programlisting><![CDATA[<?php
    // Use OPT for mail parsing
    $tpl -> assign('title', 'Message title');
    $tpl -> assign('email', 'foo@bar.com');
    mail('Automessage', 'foo2@bar.com', $tpl -> fetch('mail.tpl'));
?>]]></programlisting>
				</example>
				<para>See also: <link linkend="library.optclass.parse" endterm="">optClass::parse()</link>,
				<link linkend="library.optclass.parse-capture" endterm="">optClass::parseCapture()</link></para>
			</sect2>
			<sect2 id="library.optclass.get-status">
				<title>getStatus()</title>
				<methodsynopsis>
				<type>bool</type><methodname>getStatus</methodname>
				</methodsynopsis>
				<para>Returns true, if the output caching is already enabled.</para>
				<para>Note: this method is not available, if the <emphasis>Output Caching</emphasis> were removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.header">
				<title>header()</title>
				<methodsynopsis>
				protected <type>void</type><methodname>header</methodname>
					<methodparam><type>string</type><parameter>$header</parameter></methodparam>
				</methodsynopsis>
				<para>The default header handler for <link linkend="library.optclass.http-headers" endterm="">optClass::httpHeaders()</link>.
				If you have your own header support, you can overwrite this method and put there your code sending them. Note
				this is a protected method and may not be called outside the class!</para>
				<para>Note: this method is not available, if the <emphasis>Header support</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.http-headers">
				<title>httpHeaders()</title>
				<methodsynopsis>
				<type>void</type><methodname>httpHeaders</methodname>
					<methodparam><type>mixed</type><parameter>$contentType</parameter></methodparam>
					<methodparam choice="opt"><type>int</type><parameter>$cache</parameter></methodparam>
				</methodsynopsis>
				<para>Sends the HTTP headers to the browser that declare the content-type and document encoding taken
				from the charset configuration directive. The <variable>$contentType</variable> parameter may be one
				of these constants:</para>
				<orderedlist>
					<listitem><emphasis>OPT_HTML</emphasis> - HTML document.</listitem>
					<listitem><emphasis>OPT_XHTML</emphasis> - XHTML document, if it is supported by the browser and
						has the higher priority than <emphasis>text/html</emphasis></listitem>
					<listitem><emphasis>OPT_FORCE_XHTML</emphasis> - XHTML document always, if the browser supports it.</listitem>
					<listitem><emphasis>OPT_XML</emphasis> - XML document.</listitem>
					<listitem><emphasis>OPT_WML</emphasis> - WML document (WAP protocol).</listitem>
					<listitem><emphasis>OPT_TXT</emphasis> - plain text document.</listitem>
				</orderedlist>
				<para>If no type matches to your preferences, specify it manually. If the debug console is enabled, OPT
				changes the content-type to text/html in order to be able to add the console code into the output. In this
				case, the debug console specifies the following type used:</para>
				
				<programlisting><![CDATA[application/xhtml+xml (text/html used for debug purposes)]]></programlisting>
				
				<para>The optional second parameter decides, whether the proxy servers should cache the content we send
				(<emphasis>OPT_HTTP_CACHE</emphasis>, default setting) or not (<emphasis>OPT_NO_HTTP_CACHE</emphasis>).
				We recommend to call the method just after the parser initialization.</para>
				
				<example id="example.library.http-headers">
					<title>fetch()</title>
					<programlisting><![CDATA[<?php
  try
  {
    $tpl = new optClass;
    $tpl -> loadConfig('config.php');
    $tpl -> httpHeaders(OPT_HTML);

    // your code here
  }
  catch(optException $exception)
  {
    optErrorHandler($exception);
  }
?>]]></programlisting>
				</example>
				<para>Custom content type:</para>
				
				<programlisting><![CDATA[$tpl -> httpHeaders('application/xml+vrml');]]></programlisting>
				
				<para>Note: this method is not available, if the <emphasis>Header support</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.is-cached">
				<title>isCached()</title>
				<methodsynopsis>
				<type>bool</type><methodname>isCached</methodname>
					<methodparam><type>string</type><parameter>$filename</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$id</parameter></methodparam>
				</methodsynopsis>
				
				<para>Returns true, if the specified template with specified ID (optionally) is already cached. Use this method
				to check, whether you need to get the data from the database:</para>
				<example id="example.library.is-cached">
					<title>isCached()</title>
					<programlisting><![CDATA[  if(!$tpl -> isCached('news.tpl'))
  {
    // The news are assigned only if we need to regenerate cache file.
    $tpl -> assign('news', getNews());
  }
  $tpl -> cacheStatus(true, 30);
  $tpl -> parse('news.tpl');]]></programlisting>
				</example>

				<para>Note: this method is not available, if the <emphasis>Output caching</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.load-config">
				<title>loadConfig()</title>
				<methodsynopsis>
				<type>void</type><methodname>loadConfig</methodname>
					<methodparam><type>mixed</type><parameter>$config</parameter></methodparam>
				</methodsynopsis>
				
				<para>Loads the OPT configuration. $config may be both a configuration filename (PHP ini files syntax) or an array
				containing the directives. Instead of using it, you may also specify the configuration manually by specifying the
				configuration field values in <classname>optClass</classname> object.</para>
				
				<example id="example.library.load-config">
					<title>Three ways of setting the configuration</title>
					<programlisting><![CDATA[<?php
  // Load a configuration from an external file
  $tpl -> loadConfig('config.php');
  // Load from an array
  $tpl -> loadConfig(array(
    'root' => './templates/',
    'compile' => './templates_c/',
    'debugConsole' => false
  ));
  // Specify the config manually
  $tpl -> root = './templates/';
  $tpl -> compile = './templates_c/';
?>]]></programlisting>
				</example>
			</sect2>
			<sect2 id="library.optclass.load-plugins">
				<title>loadPlugins()</title>
				<methodsynopsis>
				<type>void</type><methodname>loadPlugins</methodname>
				</methodsynopsis>
				
				<para>If the <emphasis>plugins</emphasis> configuration directive is set to the plugin directory, the method
				loads the plugins from it. It is also called automatically during the first
				<link linkend="library.optclass.fetch" endterm="">optClass::fetch()</link> call. It is good to do this manually,
				if some plugin objects are required by the script (for example: the components).</para>				
				<para>Note: this method is not available, if the <emphasis>Plugin support</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.parse">
				<title>parse()</title>
				<methodsynopsis>
				<type>void</type><methodname>parse</methodname>
					<methodparam><type>string</type><parameter>$filename</parameter></methodparam>
				</methodsynopsis>
				<para>Alias for <emphasis>fetch($filename, true);</emphasis> - sends the parsed content to the browser.</para>
				<example id="example.library.parse">
					<title>parse()</title>
					<programlisting><![CDATA[<?php
    // Initialize OPT here
    $tpl -> assign('title', 'Page title');
    $tpl -> assign('style', 'yellow.css');
    $tpl -> assign('current_date', date('d.m.Y, H:i'));
    $tpl -> parse('overall_header.tpl');
?>]]></programlisting>
				</example>
			</sect2>
			<sect2 id="library.optclass.parse-capture">
				<title>parseCapture()</title>
				<methodsynopsis>
				<type>void</type><methodname>parseCapture</methodname>
					<methodparam><type>string</type><parameter>$filename</parameter></methodparam>
					<methodparam><type>string</type><parameter>$destination</parameter></methodparam>
				</methodsynopsis>
				<para>Executes the template <variable>$filename</variable> and makes the result a <link linkend="syntax.instructions.capture" endterm="">capture</link>
				block with the <variable>$destination</variable> name. So, if you save the result under the name "banner", you
				can put it in the next template with <variable>{$opt.capture.banner}</variable> block.</para>
			</sect2>
			<sect2 id="library.optclass.register-component">
				<title>registerComponent()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerComponent</methodname>
					<methodparam><type>mixed</type><parameter>$name</parameter></methodparam>
				</methodsynopsis>
				
				<para>Registers a component. <variable>$name</variable> is the name of the class implementing
				<classname>ioptComponent</classname> interface or an array of such names.</para>
				
				<example id="example.library.register-component">
					<title>registerComponent()</title>
					<programlisting><![CDATA[<?php
  $tpl -> registerComponent(array(0 =>
    'mySelectComponent', 'myInputComponent'
  ));
?>]]></programlisting>
				</example>
				
				<para>The components are visible in the template under their class names. In order to disable predefined
				components, use OPT Configurator and uncheck <emphasis>Predefined components</emphasis> directive.</para>				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> or
				<emphasis>Component support</emphasis> was removed from the source with
				<link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-delimiter">
				<title>registerDelimiter()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerDelimiter</methodname>
					<methodparam><type>string</type><parameter>$regExp</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$lEntName</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$lEntLook</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$rEntName</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$rEntLook</parameter></methodparam>
				</methodsynopsis>				
				<para>Registers a new tag delimiter. The <variable>$regExp</variable> is a PCRE regular expression
				(without the modifiers) that defines the look of a delimiter. It has to provide four groups:</para>
				<orderedlist>
					<listitem><emphasis>(\/?)</emphasis> - for enclosing tags.</listitem>
					<listitem><emphasis>(($$NS$$)\:)?</emphasis> - optional namespace</listitem>
					<listitem><emphasis>(.*?)</emphasis> - tag content</listitem>
					<listitem><emphasis>(\/?)</emphasis> - a slash for single tags.</listitem>				
				</orderedlist>
				<para>If you want to customize the namespace look, remember you have to preserve the
				<emphasis>$$NS$$</emphasis> string in the expression.</para>
				<para>The four optional parameters allow to define the entities that display the left and right part of
				a delimiter, so that the template designer could also display it.</para>
				<para>An example of defining square brackets as a delimiter:</para>
				<example id="example.library.register-delimiter">
					<title>registerDelimiter()</title>
					<programlisting><![CDATA[<?php
  $tpl -> registerDelimiter('\[(\/?)(([a-zA-Z]+)\:)?(.*?)(\/?)\]', 'lsb', '[', 'rsb', ']');
?>]]></programlisting>
				</example>
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-filter">
				<title>registerFilter()</title>
				<methodsynopsis>
				<type>bool</type><methodname>registerFilter</methodname>
					<methodparam><type>int</type><parameter>$type</parameter></methodparam>
					<methodparam><type>string</type><parameter>$callback</parameter></methodparam>
				</methodsynopsis>
				
				<para>Registers a new content filter. The <variable>$type</variable> parameter defines its type
				(OPT_PREFILTER, OPT_POSTFILTER, OPT_OUTPUTFILTER) and the second parameter is a filter function
				callback without the prefixes <emphasis>optPrefilter</emphasis>, <emphasis>optPostfilter</emphasis>
				or <emphasis>optOutputfilter</emphasis>. So, if you have a function <function>optPrefilterMyFilter</function>,
				you register it in this way:</para>
				
				<programlisting><![CDATA[$tpl -> registerFilter(OPT_PREFILTER, 'MyFilter');]]></programlisting>
				
				<para>More about content filters - see <link linkend="extending.filters" endterm="">New filters</link>.</para>
				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> or
				<emphasis>Code filters</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-function">
				<title>registerFunction()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerFunction</methodname>
					<methodparam><type>mixed</type><parameter>$name</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$callback</parameter></methodparam>
				</methodsynopsis>
				<para>Registers new function in the parser. Depending on the number of parameters:</para>
				<orderedlist>
					<listitem>The method takes an assotiative array as the first parameter, which contains pairs
					<emphasis>name => callback</emphasis>. "name" means the name, under which we want to see the
					function in the template. "callback" is a PHP function callback (without the "opt" prefix!).
					This allows to register many functions at once.</listitem>
					<listitem>The method takes the name as the first parameter and the callback as the second one.</listitem>				
				</orderedlist>
				
				<para>The registered function must have an "opt" prefix in the name and take an <classname>optClass</classname>
				object as the first parameter.</para>
				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-instruction">
				<title>registerInstruction()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerInstruction</methodname>
					<methodparam><type>mixed</type><parameter>$object</parameter></methodparam>
				</methodsynopsis>
				
				<para>Registers new OPT instruction or a group of instructions. The <variable>$obj</variable> may be either a
				name of the class that extends <classname>optInstruction</classname> class, or an array of such names. Note
				the instructions you are going to register, have to be already loaded to the application, because this metod
				must execute some of their methods to get their syntax info, if the compiler is used. In order to avoid this,
				call <link linkend="library.optclass.register-instruction-file" endterm="">optClass::registerInstructionFile()</link>
				first.</para>
				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-instruction-file">
				<title>registerInstructionFile()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerInstructionFile</methodname>
					<methodparam><type>string</type><parameter>$filename</parameter></methodparam>
				</methodsynopsis>
				
				<para>Registers a PHP file containing OPT instruction sources. They will be loaded only, if the compiler needs it.
				Use this method in connection with <link linkend="library.optclass.register-instruction" endterm="">optClass::registerInstruction()</link>:</para>

				<example id="example.library.register-instruction-file">
					<title>registerInstructionFile()</title>
					<programlisting><![CDATA[<?php
  $tpl -> registerInstructionFile('myInstructions.php');
  // Register instructions located in the file above
  $tpl -> registerInstruction('optInstruction1');
  $tpl -> registerInstruction('optInstruction2');
?>]]></programlisting>
				</example>
			
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-namespace">
				<title>registerNamespace()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerNamespace</methodname>
					<methodparam><type>string</type><parameter>$namespace</parameter></methodparam>
				</methodsynopsis>

				<para>Registers the new namespace <variable>$namespace</variable> for the OPT compiler. Only the registered
				namespaces are parsed by OPT in the XML syntax mode. The rest of the tags is simply displayed in the output. Note that OPT registers
				one namespace by default: "opt".</para>

				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-php-function">
				<title>registerPhpFunction()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerPhpFunction</methodname>
					<methodparam><type>mixed</type><parameter>$name</parameter></methodparam>
					<methodparam choice="opt"><type>string</type><parameter>$callback</parameter></methodparam>
				</methodsynopsis>
				
				<para>Registers new PHP function in the parser. Depending on the number of parameters:</para>
				<orderedlist>
					<listitem>The method takes an assotiative array as the first parameter, which contains pairs
					<emphasis>name => callback</emphasis>. "name" means the name, under which we want to see the
					function in the template. "callback" is a PHP function callback. This allows to register many functions at once.</listitem>
					<listitem>The method takes the name as the first parameter and the callback as the second one.</listitem>				
				</orderedlist>

				<para>You can register every PHP function in the parser, using this method. No additional prefixes and
				parameters are required.</para>
				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.register-resource">
				<title>registerResource()</title>
				<methodsynopsis>
				<type>void</type><methodname>registerResource</methodname>
					<methodparam><type>string</type><parameter>$name</parameter></methodparam>
					<methodparam><type>string</type><parameter>$callback</parameter></methodparam>
				</methodsynopsis>
				
				<para>Registers the new OPT resource function with the name <variable>$callback</variable> (without the
				<emphasis>optResource</emphasis> prefix!). The $name is the name of the handle, under which we want to
				access to this resource. <variable>$name</variable> is a reserved handle. In order to call the template
				located in your new resource, write the <emphasis>resourceHandle:template_name</emphasis> instead of the
				template file name. For example, <emphasis>db:sample</emphasis> will load the template "sample" located
				in the "db" resource. The "file" handle is a default handler; the names "template_file.tpl" and "file:template_file.tpl"
				are synonyms.</para>				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> or
				<emphasis>Custom resources</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.set-default-i18n">
				<title>setDefaultI18n()</title>
				<methodsynopsis>
				<type>void</type><methodname>setDefaultI18n</methodname>
					<methodparam><type>array</type><parameter>&amp;$array</parameter></methodparam>
				</methodsynopsis>
				
				<para>Sets the procedure-based i18n support. <variable>$array</variable> is a reference to an array containing
				language block values. For more details, see chapter <link linkend="tutorials.i18n" endterm="">I18n support</link>.</para>
			</sect2>
			<sect2 id="library.optclass.set-master-template">
				<title>setMasterTemplate()</title>
				<methodsynopsis>
				<type>void</type><methodname>setMasterTemplate</methodname>
					<methodparam><type>string</type><parameter>$template</parameter></methodparam>
				</methodsynopsis>
				
				<para>Sets a new master template file <variable>$template</variable>. It is loaded, when the compiler needs to compile a template. You can use master
				templates to store there common <link linkend="syntax.instructions.bind" endterm="">snippets</link> and
				<link linkend="syntax.instructions.bindevent" endterm="">component events</link>. OPT allows to use many master
				templates at the same time.</para>
				
				<para>Note: this method is not available, if the <emphasis>Master template support</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.set-object-i18n">
				<title>setObjectI18n()</title>
				<methodsynopsis>
				<type>void</type><methodname>setObjectI18n</methodname>
					<methodparam><type>ioptI18n</type><parameter>$i18n</parameter></methodparam>
				</methodsynopsis>
				
				<para>Sets the object i18n support. <variable>$obj</variable> is an object that implements <classname>ioptI18n</classname>
				interface. For more details, see chapter <link linkend="tutorials.i18n" endterm="">I18n support</link>.</para>
				
				<para>Note: this method is not available, if the <emphasis>Objective i18n</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.unregister-filter">
				<title>unregisterFilter()</title>
				<methodsynopsis>
				<type>bool</type><methodname>unregisterFilter</methodname>
					<methodparam><type>int</type><parameter>$type</parameter></methodparam>
					<methodparam><type>string</type><parameter>$callback</parameter></methodparam>
				</methodsynopsis>
				
				<para>Unregisters a code filter of the specified type <variable>$type</variable> and callback <variable>$callback</variable>.
				The filter must be previously registered, otherwise the method returns <emphasis>false</emphasis>.</para>
				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> or
				<emphasis>Code filters</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
			<sect2 id="library.optclass.unregister-namespace">
				<title>unregisterNamespace()</title>
				<methodsynopsis>
				<type>bool</type><methodname>unregisterNamespace</methodname>
					<methodparam><type>string</type><parameter>$namespace</parameter></methodparam>
				</methodsynopsis>
				
				<para>Unregisters <variable>$namespace</variable> namespace defined in OPT. In the namespace does not exist, it returns
				<emphasis>false</emphasis>.</para>
				
				<para>Note: this method is not available, if the <emphasis>Register method family</emphasis> was removed from the
				source with <link linkend="tutorials.opt-toolset" endterm="">OPT Configurator</link>.</para>
			</sect2>
		</sect1>
		<sect1 id="library.optcompiler">
			<title>optCompiler class</title>
			<sect2 id="library.optcompiler.fields">
				<title>Class fields</title>
				<para>The class fields described below are intented to the instruction programmers:</para>
				<table frame="all" id="fields.optcompiler">
					<?dbhtml table-width="100%" ?>
					<caption>optClass: fields</caption>
					<tgroup cols="3" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>$tpl</entry>
					  <entry>optClass</entry>
					  <entry>The template parser object.</entry>
					</row>
					<row>
					  <entry>$processors</entry>
					  <entry>Array</entry>
					  <entry>An assotiative array of registered instruction processors. The two default processors are
					  "generic" and "component". Do not write anything to this array on your own.</entry>
					</row>
					<row>
					  <entry>$translator</entry>
					  <entry>Array</entry>
					  <entry>A buffer of registered instruction tags (keys) and their types (values). Do not write anything
					  to this array on your own.</entry>
					</row>
					<row>
					  <entry>$mapper</entry>
					  <entry>Array</entry>
					  <entry>A buffer of registered instruction tags pointing to their processors. Do not write anything to
					  this array on your own.</entry>
					</row>
					<row>
					  <entry>$dynamic</entry>
					  <entry>Boolean</entry>
					  <entry>If true, the generated code generates a fully dynamic content, that is not cached with the
					  output cache system. </entry>
					</row>
					<row>
					  <entry>$dynamic</entry>
					  <entry>Boolean</entry>
					  <entry>If true, the generated code generates a fully dynamic content, that is not cached with the
					  output cache system.</entry>
					</row>
					<row>
					  <entry>$genericBuffer</entry>
					  <entry>Array</entry>
					  <entry>A buffer for the shared content between the instructions. Each instruction must firstly create
					  its own unique buffer there in order to use it.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
			</sect2>
			<sect2 id="library.optcompiler.__construct">
				<title>__construct()</title>
				<methodsynopsis>
				<methodname>__construct</methodname>
					<methodparam><type>mixed</type><parameter>$tpl</parameter></methodparam>
				</methodsynopsis>
				
				<para>Class constructor. The <variable>$tpl</variable> parameter may be:</para>
				
				<orderedlist>
					<listitem>An object of <classname>optClass</classname> or any extending class.</listitem>
					<listitem>An object of <classname>optApi</classname> or any extending class.</listitem>
					<listitem>An object of <classname>optCompiler</classname> - the settings are imported from the other
						compiler.</listitem>
				</orderedlist>
			</sect2>
			<sect2 id="library.optcompiler.compile-expression">
				<title>compileExpression()</title>
				<methodsynopsis>
				<type>mixed</type><methodname>compileExpression</methodname>
					<methodparam><type>string</type><parameter>$expression</parameter></methodparam>
					<methodparam choice="opt"><type>bool</type><parameter>$assignment</parameter></methodparam>
				</methodsynopsis>
				
				<para>Compiles the specified valid <variable>$expression</variable> to the PHP code and returns it as a string.
				If <variable>$assignment</variable> is true, it allows to use assignment operator = in the compiled expression.
				Moreover, an array is returned. The first element (index 0) contains the expression, and the second a boolean
				value, which tells whether an assignment was used in this expression or not.</para>
			</sect2>
			<sect2 id="library.optcompiler.dynamic">
				<title>dynamic()</title>
				<methodsynopsis>
				<type>void</type><methodname>compileExpression</methodname>
					<methodparam><type>bool</type><parameter>$state</parameter></methodparam>
				</methodsynopsis>

				<para>If <variable>$state</variable> is true, the method begins a dynamic code, which stays dynamic even in
				cached templates. False ends the dynamic code.</para>
			</sect2>
			<sect2 id="library.optcompiler.out">
				<title>out()</title>
				
				<methodsynopsis>
				<type>void</type><methodname>out</methodname>
					<methodparam><type>string</type><parameter>$output</parameter></methodparam>
					<methodparam choice="opt"><type>bool</type><parameter>$static</parameter> = false</methodparam>
				</methodsynopsis>

				<para>Adds the content <variable>$str</variable> to the compiler output. If no second parameter is
				specified, the content is treated as a dynamic PHP code. Set <variable>$static</variable> to true in
				order to send a plain, static text.</para>
			</sect2>
			<sect2 id="library.optcompiler.parametrize">
				<title>parametrize()</title>
				<methodsynopsis>
				<type>array</type><methodname>parametrize</methodname>
					<methodparam><type>string</type><parameter>$instruction</parameter></methodparam>
					<methodparam><type>array</type><parameter>$args</parameter></methodparam>
					<methodparam><type>array</type><parameter>&amp;$config</parameter></methodparam>
					<methodparam choice="opt"><type>int</type><parameter>$style</parameter> = OPT_STYLE_BOTH</methodparam>
				</methodsynopsis>
				
				<para>This method is used for the instruction parameter parsing. The first parameter defines the instruction name
				(used only, if an error occured and the compiler needs to tell, where it is). <variable>$args</variable> is an argument
				array got from the template tree. <variable>$config</variable> is a reference to the array that defined the number
				and type of parameters we need. After the method execution, the parsed values overwrite the configuration in this
				array. The format of this array is:</para>
				
				<programlisting><![CDATA[$params = array(
	'param_1' => array(OPT_PARAM_REQUIRED, OPT_PARAM_ID),
	// ...
	'param_n' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_EXPRESSION, NULL),
	// ...
);]]></programlisting>
				<para>The index defines the parameter name and the value is the parameter configuration. Their elements mean:</para>
				<orderedlist>
					<listitem>Whether the parameter is required (<emphasis>OPT_PARAM_REQUIRED</emphasis>) or not
						(<emphasis>OPT_PARAM_OPTIONAL</emphasis>). Optional parameters must be provided after the required ones.</listitem>
					<listitem>Parameter type:<orderedlist>
						<listitem><emphasis>OPT_PARAM_ID</emphasis> - any valid identifier, for example "foo", "bar32".</listitem>
						<listitem><emphasis>OPT_PARAM_EXPRESSION</emphasis> - the value is an OPT expression, for example "$a + $b"</listitem>
						<listitem><emphasis>OPT_PARAM_ASSIGN_EXPR</emphasis> - like above, but also assignment allowed.</listitem>
						<listitem><emphasis>OPT_PARAM_STRING</emphasis> - the value is treated as a string</listitem>
						<listitem><emphasis>OPT_PARAM_NUMBER</emphasis> - the value is treated as a number</listitem>
						<listitem><emphasis>OPT_PARAM_VARIABLE</emphasis> - the value must begin with "@" and it is treated as a variable name.</listitem>
					</orderedlist></listitem>
					<listitem>Default values for optional parameters.</listitem>
				</orderedlist>
				
				<para>Note that <emphasis>__UNKNOWN__</emphasis> is a reserved parameter name. It specifies the type of undefined
				parameters (see below). If the XML-style parameters are provided, they are returned in an assotiative array (param name => value).
				In the OPT-style, the array has the numeric indices.</para>
				
				<para><variable>$style</variable> allows to force the parameter style we want to use. By default each instruction accepts both XML-style and
				position-based syntax. To force XML-style, set the value to <emphasis>OPT_STYLE_XML</emphasis> and to force the second
				variant, to <emphasis>OPT_STYLE_OPT</emphasis>.</para>
				
				<para>Let's take a look at some examples:</para> 

				<example id="example.library.parametrize">
					<title>parametrize()</title>
					<programlisting><![CDATA[$params = array(
	'file' => array(OPT_PARAM_REQUIRED, OPT_PARAM_EXPRESSION),
	'default' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_EXPRESSION, NULL),
	'assign' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_ID, NULL),
	'__UNKNOWN__' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_EXPRESSION, NULL)
);
$variables = $this -> compiler ->
	parametrize('include', $block -> getAttributes(), $params);]]></programlisting>
				</example>
				
				<para>This is a part of real include instruction implemented in OPT. We see three "system" parameters:
				required <emphasis>file</emphasis> and optional <emphasis>default</emphasis> and <emphasis>assign</emphasis>.
				The two first parameters are parsed as expressions. We also allow to insert some additional parameters
				(<emphasis>__UNKNOWN__</emphasis>), which are returned to the <variable>$variables</variable> array. System
				parameter values are in the <variable>$params</variable> array. They are used by the instruction in this way:</para>
				
				<example id="example.library.parametrize2">
					<title>Using the parameters</title>
					<programlisting><![CDATA[foreach($variables as $name => $variable)
{
	$code .= ' $this -> vars[\''.$name.'\'] = '.$variable.'; ';		
}
// An optional parameter check
if($params['default'] != NULL)
{
	$code .= ' if(!$this -> doInclude('.$params['file'].')){
		$this -> doInclude('.$params['default'].'); } ';
}
else
{
	$code .= '$this -> doInclude('.$params['file'].');';
}]]></programlisting>
				</example>
			</sect2>
			<sect2 id="library.optcompiler.parse">
				<title>parse()</title>
				<methodsynopsis>
				<type>string</type><methodname>parse</methodname>
					<methodparam><type>string</type><parameter>$filename</parameter></methodparam>
					<methodparam><type>string</type><parameter>$code</parameter></methodparam>
				</methodsynopsis>
				
				<para>Compiles the specified input (<variable>$code</variable>) and returns the output. If <variable>$filename</variable>
				is not equal to NULL, the output is also saved under the specified location (compilation cache).</para>
			</sect2>
		</sect1>
		<sect1 id="library.optnode">
			<title>optNode class</title>
			
			<para>This chapter describes only those methods that are used by instruction programmers.</para>
			<para>The class implements the <classname>IteratorAggregate</classname> interface. When put to a foreach loop, it
			returns the blocks assigned to the specified node.</para>
			
			<sect2 id="library.optnode.get-block-count">
				<title>getBlockCount()</title>
				<methodsynopsis>
				<type>int</type><methodname>getBlockCount</methodname>
				</methodsynopsis>
				
				<para>Returns the number of blocks assigned to this node.</para>
			</sect2>
			<sect2 id="library.optnode.get-first-block">
				<title>getFirstBlock()</title>
				<methodsynopsis>
				<type>optBlock</type><methodname>getFirstBlock</methodname>
				</methodsynopsis>
				
				<para>Returns the first block.</para>
			</sect2>
			<sect2 id="library.optnode.get-name">
				<title>getName()</title>
				<methodsynopsis>
				<type>string</type><methodname>getName</methodname>
				</methodsynopsis>
				
				<para>Returns the node name.</para>
			</sect2>
			<sect2 id="library.optnode.get-parent">
				<title>getParent()</title>
				<methodsynopsis>
				<type>optNode</type><methodname>getParent</methodname>
				</methodsynopsis>
				
				<para>Returns the parent node.</para>
			</sect2>
			<sect2 id="library.optnode.get-type">
				<title>getType()</title>
				<methodsynopsis>
				<type>int</type><methodname>getType</methodname>
				</methodsynopsis>
				
				<para>Returns the node type. The following types are allowed:</para>
				
				<orderedlist>
					<listitem><emphasis>OPT_ROOT</emphasis> - template tree root.</listitem>
					<listitem><emphasis>OPT_TEXT</emphasis> - static text.</listitem>
					<listitem><emphasis>OPT_INSTRUCTION</emphasis> - instruction node.</listitem>
					<listitem><emphasis>OPT_EXPRESSION</emphasis> - expression node.</listitem>
					<listitem><emphasis>OPT_COMPONENT</emphasis> - component node.</listitem>
					<listitem><emphasis>OPT_ATTRIBUTE</emphasis> - OPT attribute.</listitem>
					<listitem><emphasis>OPT_UNKNOWN</emphasis> - any other node. The instruction programmer decides, how to parse it.</listitem>
				</orderedlist>
			</sect2>
		</sect1>
		<sect1 id="library.optblock">
			<title>optBlock class</title>
			
			<para>This chapter describes only those methods that are used by instruction programmers.</para>
			<para>The class implements the <classname>IteratorAggregate</classname> interface. When put to a foreach loop,
			it returns the nodes assigned to the specified block.</para>
			
			<sect2 id="library.optblock.get-element-by-tag-name">
				<title>getElementByTagName()</title>
				<methodsynopsis>
				<type>optNode</type><methodname>getElementByTagName</methodname>
					<methodparam><type>string</type><parameter>$tagName</parameter></methodparam>
				</methodsynopsis>
				
				<para>Returns the first node with the specified tag name assigned to this block or NULL, if there is no such node.</para>
			</sect2>
			<sect2 id="library.optblock.get-name">
				<title>getName()</title>				
				<methodsynopsis>
				<type>string</type><methodname>getName</methodname>
				</methodsynopsis>
				
				<para>Returns the block name.</para>
			</sect2>
			<sect2 id="library.optblock.get-parameters">
				<title>getParameters()</title>
				<methodsynopsis>
				<type>array</type><methodname>getParameters</methodname>
				</methodsynopsis>
				
				<para>Returns the parameters assigned to the block. Use it to get parameters for the
				<link linkend="library.optcompiler.parametrize" endterm="">optCompiler::parametrize()</link> method.</para>
			</sect2>
			<sect2 id="library.optblock.get-type">
				<title>getType()</title>
				<methodsynopsis>
				<type>int</type><methodname>getType</methodname>
				</methodsynopsis>
				
				<para>Returns the block type. The following types are allowed:</para>
				
				<orderedlist>
					<listitem><emphasis>OPT_COMMAND</emphasis> - standalone block, without subnodes (for example <emphasis>{tag/}</emphasis>)</listitem>
					<listitem><emphasis>OPT_MASTER</emphasis> - opening block, probably contains nodes with nested elements: <emphasis>{tag}</emphasis>.</listitem>
					<listitem><emphasis>OPT_ALT</emphasis> - alternative block, also could contain some nodes: <emphasis>{tagelse}</emphasis>.</listitem>
					<listitem><emphasis>OPT_ENDER</emphasis> - closing block, without subnodes: <emphasis>{/tag}</emphasis>.</listitem>
				</orderedlist>
			</sect2>
			<sect2 id="library.optblock.has-child-nodes">
				<title>hasChildNodes()</title>
				<methodsynopsis>
				<type>bool</type><methodname>hasChildNodes</methodname>
				</methodsynopsis>
				
				<para>Returns true, if there are some nodes assigned to this block.</para>
			</sect2>
			<sect2 id="library.optblock.has-parameters">
				<title>hasParameters()</title>
				<methodsynopsis>
				<type>bool</type><methodname>hasParameters</methodname>
				</methodsynopsis>
				
				<para>Returns true, if there are some parameters assigned to this block.</para>
			</sect2>
		</sect1>
		<sect1 id="library.optinstruction">
			<title>optInstruction class</title>
			
			<para>The programmer has to extend this class in order to create his instruction processor for the compiler.</para>
			
			<sect2 id="library.optinstruction.fields">
				<title>Class fields</title>
				<table frame="all" id="fields.optinstruction">
					<?dbhtml table-width="100%" ?>
					<caption>optClass: fields</caption>
					<tgroup cols="3" align="center">
					<thead>
					<row>
					  <entry>Name</entry>
					  <entry>Type</entry>
					  <entry>Description</entry>
					</row>
					</thead>
					<tbody>
					<row>
					  <entry>$tpl</entry>
					  <entry>optClass</entry>
					  <entry>The template parser object.</entry>
					</row>
					<row>
					  <entry>$compiler</entry>
					  <entry>optCompiler</entry>
					  <entry>The template compiler object.</entry>
					</row>
					<row>
					  <entry>$masterUse</entry>
					  <entry>boolean</entry>
					  <entry>If true, the instruction is processed inside the master templates. By default, set to false.</entry>
					</row>
					</tbody>
					</tgroup>
				</table>
			</sect2>
			<sect2 id="library.optinstruction.configure">
				<title>configure()</title>
				<methodsynopsis>
				<type>array</type><methodname>configure</methodname>
				</methodsynopsis>
				
				<para>The method to overwrite by the programmer. It returns the list of instruction tags to register with
				their types. The returned array must have the following structure:</para>
				
				<programlisting><![CDATA[public function configure()
{
	return array(
		0 => 'processorname',
		// registered tags
		'tag' => OPT_TAGTYPE,
		'tag' => OPT_TAGTYPE,
		'tag' => OPT_TAGTYPE,
		...
	);
} // end configure();]]></programlisting>

				<para>The tag type is one of the following:</para>
				
				<orderedlist>
					<listitem><emphasis>OPT_COMMAND</emphasis> - standalone block, without subnodes (for example <emphasis>{tag/}</emphasis>)</listitem>
					<listitem><emphasis>OPT_MASTER</emphasis> - opening block, probably contains nodes with nested elements: <emphasis>{tag}</emphasis>.</listitem>
					<listitem><emphasis>OPT_ALT</emphasis> - alternative block, also could contain some nodes: <emphasis>{tagelse}</emphasis>.</listitem>
					<listitem><emphasis>OPT_ENDER</emphasis> - closing block, without subnodes: <emphasis>{/tag}</emphasis>.</listitem>
					<listitem><emphasis>OPT_ATTRIBUTE</emphasis> - dynamic attribute: <emphasis>namespace:name="value"</emphasis></listitem>
				</orderedlist>
				
				<para>Note: if you want to use namespaces, they must be also specified in the tag name, for example:
				<emphasis>'namespace:sometag' => OPT_MASTER</emphasis>. Below, we provide a real example of registering section tags:</para>

				<example id="example.library.configure1">
					<title>Registering section tags</title>
					<programlisting><![CDATA[<?php
		public function configure()
		{
			return array(
				// processor name
				0 => 'section',
				// instructions
				'section' => OPT_MASTER,
				'sectionelse' => OPT_ALT,
				'/section' => OPT_ENDER,
				'show' => OPT_MASTER,
				'showelse' => OPT_ALT,
				'/show' => OPT_ENDER,
				'sectionfirst' => OPT_ATTRIBUTE, // use the "opt" namespace here
				'sectionlast' => OPT_ATTRIBUTE,
				'sectioncycle' => OPT_ATTRIBUTE
			);
		} // end configure();
?>]]></programlisting>
				</example>
			</sect2>
			<sect2 id="library.optinstruction.default-tree-process">
				<title>defaultTreeProcess()</title>
				<methodsynopsis>
				<type>void</type><methodname>defaultTreeProcess</methodname>
					<methodparam><type>optBlock</type><parameter>$block</parameter></methodparam>
				</methodsynopsis>
				<para>Processes the OPT nodes assigned to the specified blocks.</para>
			</sect2>
			<sect2 id="library.optinstruction.find-snippets">
				<title>findSnippets()</title>
				<methodsynopsis>
				<type>void</type><methodname>findSnippets</methodname>
					<methodparam><type>ioptBlock</type><parameter>$block</parameter></methodparam>
					<methodparam><type>string</type><parameter>&amp;$snippetName</parameter></methodparam>
					<methodparam choice="opt"><type>bool</type><parameter>$useBindGroup</parameter> = false</methodparam>
				</methodsynopsis>
				<para>Tries to find the <emphasis>use</emphasis> tag in the specified block and import the
					snippets, if exists. The name of the snippet is saved in the <variable>$snippetName</variable>
					reference variable. The last, optional parameter, forces to search the snippet in the
					<link linkend="syntax.instructions.bindgroup" endterm="">bindGroup</link> buffer, instead of
					<link linkend="syntax.instructions.bind" endterm="">bind</link>.</para>
				<para>If the <emphasis>use</emphasis> tag is not found, the method returns NULL and the instruction
					should look for the tags on its own then.</para>
			</sect2>
			<sect2 id="library.optinstruction.instruction-node-process">
				<title>instructionNodeProcess()</title>
				<methodsynopsis>
				<type>void</type><methodname>instructionNodeProcess</methodname>
					<methodparam><type>ioptNode</type><parameter>$node</parameter></methodparam>
				</methodsynopsis>
				<para>The programmer has to overwrite this method, which processes the tags matching to this
					processor. $node contains the node created for the matching tag. This is a sample processing
					method, which redirects PHP to tag processing methods defined somewhere else in the class:</para>
				<example id="example.library.configure2">
					<title>Processing the instruction nodes</title>
					<programlisting><![CDATA[public function instructionNodeProcess(ioptNode $node)
{
	foreach($node as $block)
	{				
		switch($block -> getName())
		{
			case 'tag':
				$this -> tagBegin($block -> getAttributes());
				$this -> defaultTreeProcess($block);
				break;
			case 'tagelse':
				$this -> tagElse();
				$this -> defaultTreeProcess($block);
				break;
			case '/tag':
				$this -> tagEnd();
		}
	}
} // end process();]]></programlisting>
				</example>
				<para>In the example, the method gets the node blocks and checks, which tags they match to.
					If the block can contain some child nodes, we call
					<link linkend="library.optinstruction.default-tree-process" endterm="">defaultTreeProcess()</link> method
					in order to process them, too.</para>
			</sect2>
			<sect2 id="library.optinstruction.node-process">
				<title>nodeProcess()</title>
				<methodsynopsis>
				<type>void</type><methodname>nodeProcess</methodname>
					<methodparam><type>ioptNode</type><parameter>$node</parameter></methodparam>
				</methodsynopsis>
				<para>Default OPT node processing method. Recognizes expressions, text nodes, component nodes, OPT
					attributes and calls to the programmer instruction processing method.</para>
			</sect2>
			<sect2 id="library.optinstruction.process-attribute">
				<title>processAttribute()</title>
				<methodsynopsis>
				<type>void</type><methodname>processAttribute</methodname>
					<methodparam><type>optBlock</type><parameter>$block</parameter></methodparam>
				</methodsynopsis>
				<para>The method should be overwritten in the instruction class. It allows to process the OPT attributes,
					which are passed here as the optBlock objects. The attribute value is saved as an block attribute.</para>
			</sect2>
			<sect2 id="library.optinstruction.process-opt">
				<title>processOpt()</title>
				<methodsynopsis>
				<type>string</type><methodname>processOpt</methodname>
					<methodparam><type>array</type><parameter>$call</parameter></methodparam>
				</methodsynopsis>
				<para>This method should be overwritten by the programmer in order to process <variable>$opt</variable>
					special block calls for the specified instruction. For example, if the processor is named
					instruction, all the calls <emphasis>$opt.instruction.something</emphasis> are redirected to
					this method. <variable>$call</variable> contains the block elements splitted with the dot
					numbered from 0. The method returns the PHP code for the compiler.</para>
			</sect2>
		</sect1>
		<sect1 id="library.optexception">
			<title>optException class</title>
			<para>This class extends the standard <classname>Exception</classname> class
				available in PHP.</para>
			<sect2 id="library.optexception.__construct">
				<title>__construct()</title>
				<methodsynopsis>
				<methodname>__construct</methodname>
					<methodparam><type>string</type><parameter>$message</parameter></methodparam>
					<methodparam><type>int</type><parameter>$code</parameter></methodparam>
					<methodparam><type>int</type><parameter>$type</parameter></methodparam>
					<methodparam><type>string</type><parameter>$file</parameter></methodparam>
					<methodparam><type>int</type><parameter>$line</parameter></methodparam>
					<methodparam><type>string</type><parameter>$function</parameter></methodparam>
				</methodsynopsis>
				<para>Creates an exception object with specified error info.</para>
			</sect2>
			<sect2 id="library.optexception.get-function">
				<title>getFunction()</title>
				<methodsynopsis>
				<type>string</type><methodname>getFunction</methodname>
				</methodsynopsis>
				<para>Returns the function name, where the error occured.</para>
			</sect2>
			<sect2 id="library.optexception.get-type">
				<title>getType()</title>
				<methodsynopsis>
				<type>int</type><methodname>getType</methodname>
				</methodsynopsis>
				<para>Returns the error type (general/compilation).</para>
			</sect2>
		</sect1>
		<sect1 id="library.iopti18n">
			<title>ioptI18n interface</title>
			<para>The i18n interface used by OPT.</para>
			<sect2 id="library.iopti18n.apply">
				<title>apply()</title>
				<methodsynopsis>
				<type>void</type><methodname>apply</methodname>
					<methodparam><type>string</type><parameter>$group</parameter></methodparam>
					<methodparam><type>string</type><parameter>$id</parameter></methodparam>
					<methodparam><parameter>...</parameter></methodparam>
				</methodsynopsis>
				<para>Places the data passed as parameters to the specified text using
					<emphasis>prinft()</emphasis> format syntax. The modified version is
					stored in internal class buffer.</para>
			</sect2>
			<sect2 id="library.iopti18n.put">
				<title>put()</title>
				<methodsynopsis>
				<type>string</type><methodname>put</methodname>
					<methodparam><type>string</type><parameter>$group</parameter></methodparam>
					<methodparam><type>string</type><parameter>$id</parameter></methodparam>
				</methodsynopsis>
				<para>Returns the text with specified <variable>$group</variable> and
					<variable>$id</variable>.</para>
			</sect2>
			<sect2 id="library.iopti18n.put-apply">
				<title>putApply()</title>
				<methodsynopsis>
				<type>string</type><methodname>putApply</methodname>
					<methodparam><type>string</type><parameter>$group</parameter></methodparam>
					<methodparam><type>string</type><parameter>$id</parameter></methodparam>
					<methodparam><parameter>...</parameter></methodparam>
				</methodsynopsis>
				<para>Works like <link linkend="library.iopti18n.apply" endterm="">apply()</link>,
					but the modified version is returned.</para>
			</sect2>
			<sect2 id="library.iopti18n.set-opt-instance">
				<title>setOptInstance()</title>
				<methodsynopsis>
				<type>void</type><methodname>setOptInstance</methodname>
					<methodparam><type>optClass</type><parameter>$tpl</parameter></methodparam>
				</methodsynopsis>
				<para>Sets the <classname>optClass</classname> instance.</para>
			</sect2>
		</sect1>
		<sect1 id="library.ioptcomponent">
			<title>ioptComponent class</title>
			<sect2 id="library.ioptcomponent.__construct">
				<title>__construct()</title>
				<methodsynopsis>
				<methodname>__construct</methodname>
					<methodparam choice="opt"><type>string</type><parameter>$name</parameter></methodparam>
				</methodsynopsis>
				<para>Initializes the component object. <variable>$name</variable> is the component
					name that could be defined using name parameter in the template. However, you
					do not have to pay attention to it.</para>
			</sect2>
			<sect2 id="library.ioptcomponent.begin">
				<title>begin()</title>
				<methodsynopsis>
					<type>void</type><methodname>begin</methodname>
				</methodsynopsis>
				<para>Begins the component rendering. Use <emphasis>echo</emphasis> to send the HTML
					output to the browser. Before it, there are called events with
					<emphasis>position="up"</emphasis> parameter.</para>
			</sect2>
			<sect2 id="library.ioptcomponent.end">
				<title>end()</title>
				<methodsynopsis>
					<type>void</type><methodname>begin</methodname>
				</methodsynopsis>
				<para>Ends the component rendering (if necessary). Use echo to send the HTML output
					to the browser. Before it, there are called events with
					<emphasis>position="mid"</emphasis> parameter. The events with
					<emphasis>position="down"</emphasis> parameter are called next.</para>
			</sect2>
			<sect2 id="library.ioptcomponent.push">
				<title>push()</title>
				<methodsynopsis>
					<type>void</type><methodname>push</methodname>
					<methodparam><type>string</type><parameter>$name</parameter></methodparam>
					<methodparam><type>mixed</type><parameter>$value</parameter></methodparam>
					<methodparam choice="opt"><type>bool</type><parameter>$selected</parameter> = false</methodparam>
				</methodsynopsis>
				<para>Adds the list element <variable>$name</variable> with the value
					<variable>$value</variable>. In the template, it is called for all listItem tags.</para>
			</sect2>
			<sect2 id="library.ioptcomponent.set">
				<title>set()</title>
				<methodsynopsis>
					<type>void</type><methodname>set</methodname>
					<methodparam><type>string</type><parameter>$name</parameter></methodparam>
					<methodparam><type>mixed</type><parameter>$value</parameter></methodparam>
				</methodsynopsis>
				<para>Sets the parameter <variable>$name</variable> to the value <variable>$value</variable>.
					In the template, it is called for all <emphasis>{param}</emphasis> tags.</para>
			</sect2>
			<sect2 id="library.ioptcomponent.set-datasource">
				<title>setDatasource()</title>
				<methodsynopsis>
					<type>void</type><methodname>setDatasource</methodname>
					<methodparam><type>mixed</type><parameter>$source</parameter></methodparam>
				</methodsynopsis>
				<para>If the component uses an external data source (for example a section array), it
					could be passed to it using this method. In the template, it is called for the
					<emphasis>datasource</emphasis> parameter in the main component tag.</para>
			</sect2>
			<sect2 id="library.ioptcomponent.set-opt-instance">
				<title>setOptInstance()</title>
				<methodsynopsis>
				<type>void</type><methodname>setOptInstance</methodname>
					<methodparam><type>optClass</type><parameter>$tpl</parameter></methodparam>
				</methodsynopsis>
				<para>Passes an <classname>optClass</classname> object to the component. It is automatically
					called, when the component is run inside the template.</para>
			</sect2>
 		</sect1>
		<sect1 id="library.ioptpagesystem">
			<title>ioptPagesystem class</title>
			<para>The pagination system interface, which must be implemented in order to integrate the pagesystem from our
					  web application with the <link linkend="syntax.instructions.pagesystem" endterm="">Pagesystem</link> instruction.</para>
			<sect2 id="library.ioptpagesystem.get-page">
				<title>getPage()</title>
				<methodsynopsis>
					<type>array</type><methodname>getPage</methodname>
				</methodsynopsis>
				<para>The method should return the array with the information about the next page in
					the list. If the system reaches the end of the list, nothing should be returned
					in order to stop the loop. The returned array must have exactly three fields:</para>
				<itemizedlist>
					<listitem><emphasis>t</emphasis> - the type of returned item: 0 - normal page;
						1 - active page; 2 - separator</listitem>
					<listitem><emphasis>p</emphasis> - page number</listitem>
					<listitem><emphasis>l</emphasis> - the link, where the page points to.</listitem>
				</itemizedlist>
				<para>You can find a sample implementation in the
					<link linkend="syntax.instructions.pagesystem">{pagesystem}</link> tag description.</para>
			</sect2>
			<sect2 id="library.ioptpagesystem.next-page">
				<title>nextPage()</title>
				<methodsynopsis>
					<type>array</type><methodname>getPage</methodname>
				</methodsynopsis>
				<para>Returns the same array, as in
					<link linkend="library.ioptpagesystem.get-page" endterm="">getPage()</link> method with
					the information for the "next page" link. If such item should not be displayed, nothing
					should be returned.</para>
				<para>You can find a sample implementation in the
					<link linkend="syntax.instructions.pagesystem">{pagesystem}</link> tag description.</para>
			</sect2>
			<sect2 id="library.ioptpagesystem.prev-page">
				<title>prevPage()</title>
				<methodsynopsis>
					<type>array</type><methodname>getPage</methodname>
				</methodsynopsis>
				<para>Returns the same array, as in
					<link linkend="library.ioptpagesystem.get-page" endterm="">getPage()</link> method with
					the information for the "previous page" link. If such item should not be displayed, nothing
					should be returned.</para>
				<para>You can find a sample implementation in the
					<link linkend="syntax.instructions.pagesystem">{pagesystem}</link> tag description.</para>
			</sect2>
			<sect2 id="library.ioptpagesystem.first-page">
				<title>firstPage()</title>
				<methodsynopsis>
					<type>array</type><methodname>getPage</methodname>
				</methodsynopsis>
				<para>Returns the same array, as in
					<link linkend="library.ioptpagesystem.get-page" endterm="">getPage()</link> method with
					the information for the "first page" link. If such item should not be displayed, nothing
					should be returned.</para>
				<para>You can find a sample implementation in the
					<link linkend="syntax.instructions.pagesystem">{pagesystem}</link> tag description.</para>
			</sect2>
			<sect2 id="library.ioptpagesystem.last-page">
				<title>lastPage()</title>
				<methodsynopsis>
					<type>array</type><methodname>getPage</methodname>
				</methodsynopsis>
				<para>Returns the same array, as in
					<link linkend="library.ioptpagesystem.get-page" endterm="">getPage()</link> method with
					the information for the "last page" link. If such item should not be displayed, nothing
					should be returned.</para>
				<para>You can find a sample implementation in the
					<link linkend="syntax.instructions.pagesystem">{pagesystem}</link> tag description.</para>
			</sect2>
		</sect1>
	</chapter>
	<chapter id="tutorials">
		<title>Tutorials</title>
		<sect1 id="tutorials.i18n">
			<title>I18n and OPT</title>
			<para>When we create a multilingual website, it would be nice the template not to make
				this task harder. Open Power Template is very useful in such projects, because it
				natively supports i18n. Let's take a look at the sample template:</para>
			<example id="example.tutorial.i18n.e1">
				<title>Sample i18n template</title>
				<programlisting><![CDATA[{* put the current date inside the global@date language block *}
{apply($global@date, $current_date)}
<p>{$global@text1}</p>
<p>{$global@text2}</p>
<p>{$global@text3}</p>
<p>{$global@date}</p>]]></programlisting>
			</example>
			<para>As we see, OPT has a special kind of blocks called language blocks. They read the
				text directly from your i18n system, so you do not have to assign it manually to the
				parser. The language block is build of the group ID, and the text ID inside this 
				group, so the texts must be organised somehow in groups. The
				<link linkend="syntax.functions.apply" endterm="">apply()</link> function allows to
				insert some dynamic data into a text in the place of printf() C function format tags.</para>
			<para>When it comes to the PHP code, OPT supports two styles of coding. First of all, we
				can use a simple, procedural i18n system, where we link a simple array containing
				all the language texts and groups. The apply() function operates directly on the language
				block, overwriting its content. This is a sample implementation:</para>
			<example id="example.tutorial.i18n.e2">
				<title>Procedural i18n in OPT</title>
				<programlisting><![CDATA[<?php 
   define('OPT_DIR', '../lib/');
   require('../lib/opt.class.php');
   // Our language array
   $lang = array(
	   'global' => 
			array(
			'text1' => 'This is text one',
			'text2' => 'This is text two',
			'text3' => 'This is text three',
			'date' => 'Today is %s, good day for fishing'		
		 )
	 );
								 
	 try
	 { 
		 $tpl = new optClass; 
		 $tpl -> root = './templates/';
		 $tpl -> compile = './templates_c/';
		 $tpl -> gzipCompression = 1;
		 $tpl -> httpHeaders(OPT_HTML); 
				 
		 // init the default i18n system
		 $tpl -> setDefaultI18n($lang);
									 
		 $tpl -> assign('current_date', date('d.m.Y')); 
		 $tpl -> parse('example4.tpl'); 
	 }
	 catch(optException $exception)
	 { 
		 optErrorHandler($exception); 
	 } 
?>]]></programlisting>
			</example>
			<para>As we run the example, we will see something like that:</para>
			<programlisting><![CDATA[This is text one
This is text two
This is text three
Today is 15.05.2006, good day for fishing]]></programlisting>
			<para>The second style is called object-oriented i18n. Here, we have to create a
			class that implements the
			<link linkend="library.iopti18n" endterm="">ioptI18n</link> interface.</para>
		<example id="example.tutorial.i18n.e3">
			<title>Object-oriented i18n in OPT</title>
			<programlisting><![CDATA[<?php
	define('OPT_DIR', '../lib/');
	require('../lib/opt.class.php');
			  
	class i18n implements ioptI18n{
		private $data;
		private $replacements;
		static $instance;
		private $tpl;
			  
		private function __construct()
		{
			// We put the text in the constructor
			// But normally it should be somehow read from a file
			$this -> data = array(
				'global' => 
					array(
						'text1' => 'This is text one',
						'text2' => 'This is text two',
						'text3' => 'This is text three',
						'date' => 'Today is %s, good day for fishing'		
					)
			);
		} // end __construct();
				
		public function setOptInstance(optClass $tpl)
		{
			$this -> tpl = $tpl;
		} // end setOptInstance();
				
		static public function getInstance()
		{
			if(!is_object(self::$instance))
			{
				self::$instance = new i18n;
			}
			return self::$instance;
		} // end getInstance();  
				
		public function put($group, $text_id)
		{
			if(isset($this->replacements[$group][$text_id]))
			{
				return $this->replacements[$group][$text_id];
			}
			return $this->data[$group][$text_id]; 	
		} // end put();
				
		public function apply($group, $text_id)
		{
			$args = func_get_args();
			unset($args[0]);
			unset($args[1]);
			$this -> replacements[$group][$text_id] =
			vsprintf($this -> data[$group][$text_id], $args);
		} // end apply();
				
		public function putApply($group, $text_id)
		{
			$args = func_get_args();
			unset($args[0]);
			unset($args[1]);
			return vsprintf($this -> data[$group][$text_id], $args);
		} // end putApply();  
	}
				
	try
	{ 
		$tpl = new optClass; 
		$tpl -> root = './templates/';
		$tpl -> compile = './templates_c/';
		$tpl -> gzipCompression = 1;
		$tpl -> httpHeaders(OPT_HTML); 
				
		// create an instance of the i18n system
		$i18n = i18n::getInstance();
				
		// pass it to the parser
		$tpl -> setObjectI18n($i18n);
				
		$tpl -> assign('current_date', date('d.m.Y')); 
		$tpl -> parse('example5.tpl'); 
	}
	catch(optException $exception){
	
		optErrorHandler($exception); 
	}
?>]]></programlisting>
			</example>
			<para>The class creates two buffers: <variable>$data</variable>, where the original
			texts are stored, and <variable>$replacements</variable> for the texts generated by
			the apply() function. In the <emphasis>i18n::put()</emphasis> method, we return the
			requested text.</para>
			<para>As we have a class, we create its object and put it into the engine using
				<link linkend="library.optclass.set-object-i18n" endterm="">optClass::setObjectI18n()</link>
				method.</para>
			<para>Of course the i18n issue does not end here. Remember that English grammar is not a
				king of the world, and the programmers should know that other languages like to prefer
				the structures that do not match to the English patterns. The simplest example is the
				date. In English, there is no problem to generate it with a computer. However, Polish
				and almost all Slavonic languages have cases, which are used here. For example, the
				Polish name for July is <emphasis>czerwiec</emphasis>, but in the date we have to write
				<emphasis>15 czerwca 2006</emphasis>. It would be good to remember about such issues,
				because they decide on the application quality.</para>
		</sect1>
		<sect1 id="tutorials.outputcaching">
			<title>Output caching</title>
			<para>In many websites some data do not change so often in order to read them every time
				from the database or some other source. They are not even worth assigning to the
				template engine then. To improve the performance, we can use the output caching
				feature. When it is enabled, OPT captures the output generated by the parser and
				stores it on the HDD. Next time, instead of generating the result once more, it
				simply reads it from the directory.</para>
			<para>OPT supports the expiry date cache. This means that if the cache file is too old,
				it is regenerated in order to make the website up-to-date. There is, however, some
				delay, but if we specify short enough peroids, the guests will not notice anything.</para>
			<para>The output caching feature is enabled by specifying the directory, where OPT will
				store the cached template versions. We set it in the <emphasis>cache</emphasis>
				directive. Then we use
				<link linkend="library.optclass.cache-status" endterm="">optClass::cacheStatus()</link>
				method to enable or disable the caching for the exact templates:</para>
			<example id="example.tutorial.cache.e1">
				<title>Caching issues</title>
				<programlisting><![CDATA[// This is our cache directory.
$tpl -> cache = './cache/';
// cache file1.tpl for 120 seconds
$tpl -> cacheStatus(true, 120);
$tpl -> parse('file1.tpl');
$tpl -> cacheStatus(false);

// cache three files for 30 seconds
$tpl -> cacheStatus(true, 120);
$tpl -> parse('file1.tpl');
$tpl -> parse('file2.tpl');
$tpl -> parse('file3.tpl');
$tpl -> cacheStatus(false);
// This file will not be cached
$tpl -> parse('file4.tpl');]]></programlisting>
			</example>
			<para>The next, very useful method, is
				<link linkend="library.optclass.is-cached" endterm="">optClass::isCached()</link>. It
				allows to check, whether the template has a valid cache file, and we do not have to read
				the data from the database etc. Note that this method reads everything it needs from the
				cache file and you do not have to call
				<link linkend="library.optclass.cache-status" endterm="">cacheStatus()</link> before you
				want to use it. This is a sample code:</para>
			<example id="example.tutorial.cache.e2">
				<title>Reading the data in cached scripts</title>
				<programlisting><![CDATA[<?php
	define('OPT_DIR', '../lib/');
	require(OPT_DIR.'opt.class.php');
	
	try
	{ 
		$tpl = new optClass;
		$tpl -> root = 'templates/';
		$tpl -> compile = 'templates_c/';
		$tpl -> cache = 'cache/';
		$tpl -> httpHeaders(OPT_HTML);
	
		if(!$tpl -> isCached('example10.tpl'))
		{
			// We load the data only if we regenerate the cache
			require('db_connect.php'); 
			$r = mysql_query('SELECT id, name, description
				FROM products ORDER BY id');
			$list = array();
			while($row = mysql_fetch_assoc($r)) 
			{ 
				// add the next item 
				$list[] = array( 
					'id' => $row['id'], 
					'name' => $row['name'],
					'description' => $row['description']
				);
			}
			$tpl -> assign('products', $list);
			mysql_close();
		}
		// cache the template result for 30 seconds
		$tpl -> cacheStatus(true, 30);
		$tpl -> parse('example10.tpl');
		$tpl -> cacheStatus(false);
	}
	catch(optException $exception)
	{ 
		optErrorHandler($exception); 
	}
?>]]></programlisting>
			</example>
			<para>Even in the cached templates, there is unsually a need to some content
				stay dynamic. The dynamic content can be enclosed in the
				<link linkend="syntax.instructions.dynamic" endterm="">{dynamic}...{/dynamic}</link>
				tags:</para>
			<example id="example.tutorial.cache.e4">
				<title>Dynamic content in cached templates</title>
				<programlisting><![CDATA[{dynamic}
<p>Dynamic date: {$current_date}</p>
{/dynamic}
<p>Static (cached) date: {$current_date}</p>]]></programlisting>
			</example>
			<para>If we cache this template, we notice that the first date changes every time we
				refresh the page (it is dynamic). The second date changes rarely, only if the
				cache file is regenerated and OPT has an ability to put here the new value (see
				Example 9 in the sources).</para>
			<para>Let's say we have a template that is used to show an article. We call it
				<emphasis>article_read.tpl</emphasis>. We cache it, but there is the problem.
				The user sees only article A, even if he wants to see article B. Why? Of course,
				OPT cached the first article and thinks it should be shown in all the situations.
				But there is a solution. Using
				<link linkend="library.optclass.cache-unique" endterm="">optClass::cacheUnique()</link>
				method you may set additional identifier to the cached content.</para>
			<example id="example.tutorial.cache.e5">
				<title>Unique cache ID</title>
				<programlisting><![CDATA[if(!$tpl -> isCached('article_read.tpl', $_GET['article_id']))
{
	$stmt = $opd -> prepare('SELECT * FROM articles WHERE id=:id');
	$stmt -> bindValue(':id', $_GET['article_id'], PDO::PARAM_INT);
	$stmt -> execute();
	$tpl -> assignGroup($stmt -> fetch());
}
$tpl -> cacheStatus(true, 300);
$tpl -> cacheUnique($_GET['article_id']);
$tpl -> parse('article_read.tpl');
$tpl -> cacheStatus(false);]]></programlisting>
			</example>
			<para>As we see, the ID must be specified also in the
				<link linkend="library.optclass.is-cached" endterm="">isCached()</link> method. Note
				that after calling the <link linkend="library.optclass.parse" endterm="">parse()</link>
				method, the ID is cleared automatically, so we do not have to worry about the fact that
				the next template will be also cached with it by mistake.</para>
		</sect1>
		<sect1 id="tutorials.opt-toolset">
			<title>OPT Toolset</title>
			<para>OPT Toolset is an application developed to manage OPT or OPT-related issues.
			Currently it consists of two tools:</para>
			<orderedlist>
				<listitem>Configurator - this is a preprocessor, which allows you to remove
				unused features from the library code. OPT Compiler was a standalone tool
				in OPT 1.0.x.</listitem>
				<listitem>Compiler - an external template compiler. It may be useful, if
				you use the <variable>performance</variable> directive, which turns off
				the automated template compilation. If you fix something in a template,
				you run the compiler, compile it manually and send the compiled version
				to the server without disabling the directive for a moment.</listitem>
			</orderedlist>
			<para>To install the toolset, just copy it somewhere, where the webserver could
			find it. Copy also OPT library, because it is required by the application. Open
			<filename>common.php</filename> and set the <variable>OPT_DIR</variable> constant
			to the actual path to the library. Run the browser and open <filename>index.php</filename>.
			If you see the info page, the installation is over.</para>
			<para>OPT Toolset contains a built-in help, so here we will describe only the basic
			things.</para>
			<para>The configurator requires the original source code of OPT to work. You specify
			a path to it and the localization of the output, modified files. Next, you select
			the features you want to keep and untick those ones which are unnecessary.</para>
			<para>The compiler tool: in the top you see three fields to specify paths:</para>
			<orderedlist>
				<listitem>Template source directory</listitem>
				<listitem>Compiled template directory</listitem>
				<listitem>Plugin directory - if your templates use some plugins, OPT may
				load them in order to use in the compiled templates.</listitem>
			</orderedlist>
			<para>The tool has three functions:</para>
			<orderedlist>
				<listitem>Remove all - removes all the compiled versions of the templates.</listitem>
				<listitem>Remove selected - you have to tick the templates, whose compiled
				versions must be removed.</listitem>
				<listitem>Compile selected - compiles the selected templates, using their source
				files and loaded plugins.</listitem>
			</orderedlist>
			<para>Note: OPT Toolset remembers all the paths and options you have typed, so
			you do not have to specify them every time you want to use the toolset.</para>
		</sect1>
	</chapter>
	<chapter id="extending">
		<title>Extending OPT</title>
		<sect1 id="extending.functions">
			<title>New functions</title>
			<para>Creating of new functions is really easy in OPT. Let's begin with the PHP code.
				The function we want to use in the templates, must have the name started with the
				<emphasis>opt</emphasis> prefix, and get the
				<link linkend="library.optclass" endterm="">optClass</link> instance as the first
				parameter. The function must process the data and return a value.</para>
			<example id="example.extending.function.e1">
				<title>New OPT function</title>
				<programlisting><![CDATA[<?php
								  
	function optPower(optClass $tpl, $x, $y = 2)
	{
		// return the value
		return pow($x, $y);
	} // end optPower();
							  
?>]]></programlisting>
			</example>
			<para>Then, we have to register our function in OPT. There are three ways of doing it:</para>
			<orderedlist>
				<listitem>Using plugins (described in chapter
					<link linkend="extending.plugins" endterm="">OPT Plugins</link>).</listitem>
				<listitem>In the constructor, if we extend optClass class.</listitem>
				<listitem>Using
					<link linkend="library.optclass.register-function" endterm="">optClass::registerFunction()</link> method.</listitem>				
			</orderedlist>
			<para>Beware! In all these methods we specify the function name <emphasis>without</emphasis>
				the opt prefix!</para>
			<programlisting><![CDATA[$tpl -> registerFunction('pow', 'Power');]]></programlisting>
			<para>The first parameter defines the function name used in the templates, the second -
				PHP function name withour prefix. The use of the function:</para>
			<programlisting><![CDATA[<p>The second power of 3 is {pow(3)}.</p>]]></programlisting>
		</sect1>
		<sect1 id="extending.resources">
			<title>New resources</title>
			<para>In OPT, the programmer may use not only files as a template resource. The parser
				allows to write your own resource handling function, reading the templates from the
				database etc. Its structure is very simple. The function accepts three parameters:</para>
			<orderedlist>
				<listitem><link linkend="library.optclass" endterm="">optClass</link> object.</listitem>
				<listitem>The name of the template.</listitem>
				<listitem>Optional compiled file modification time.</listitem>
			</orderedlist>
			<para>The function returns the template source or false, if it is already compiled. In
				order to handle the situation, when the template does not exist, the function may
				call the <link linkend="library.optclass.error" endterm="">optClass::error()</link>
				method, which generates an exception. In the example we can see a sample database
				resource:</para>
			<example id="example.extending.resource.e1">
				<title>New OPT resource</title>
				<programlisting><![CDATA[<?php
	 
	 function optResourceDatabase(optClass $tpl, $title, $compiledTime = NULL)
	{
		if(is_null($compiledTime))
		{
			$r = mysql_query('SELECT `code` FROM `templates`
				WHERE `title` = \''.$title.'\'');
		}
		else
		{
			$r = mysql_query('SELECT `code` FROM `templates`
				WHERE `title` = \''.$title.'\' AND
				`lastmod` > \''.$compiledTime.'\'');
		}
		if($row = mysql_fetch_row($r))
		{
			return $row[0];		
		}
		return false;	
	} // end optResourceDatabase();
											  
?>]]></programlisting>
			</example>
			<para>The prefix of the function is <emphasis>optResource</emphasis>. It may be
				registered with <link linkend="library.optclass.register-resource" endterm="">optClass::registerResource()</link> method:</para>
			<programlisting><![CDATA[$tpl -> registerResource('db', 'Database');]]></programlisting>
			<para>The first parameter is the handle. Using it, we can tell the parser that this
				template is located in the specified resource:</para>
			<programlisting><![CDATA[$tpl -> parse('db:sample_template');]]></programlisting>
			<para>Note that the <emphasis>file</emphasis> handle is reserved for the default
				OPT resource, although you do not have to specify it while calling the templates.</para>
		</sect1>
		<sect1 id="extending.filters">
			<title>New filters</title>
			<para>Creating new filters resembles creating functions. The filter source code gets
				two parameters: <link linkend="library.optclass" endterm="">optClass</link> object,
				and the content to modify. There are three types of filters in OPT:</para>
			<orderedlist>
				<listitem>Prefilter - processes the template source just before the compilation.</listitem>
				<listitem>Postfilter - processes the compiled template right after the compilation.</listitem>
				<listitem>Output filter - processes the template output.</listitem>				
			</orderedlist>
			<para>The filter function name must begin with a prefix: <emphasis>optPrefilter</emphasis>, <emphasis>optPostfilter</emphasis> or <emphasis>optOutputfilter</emphasis>, depending on
				the filter type we want to create. It must return the modified content. Like in functions,
				we do not use the prefix while registering the filter.</para>
		</sect1>
		<sect1 id="extending.components">
			<title>New components</title>
			<para>In this tutorial we will show, how to write an automated component for the
			input fields. Its features:</para>
			<orderedlist>
				<listitem>The component will check, whether the form validation is OK.</listitem>
				<listitem>If not, it will automatically get the previously written data
				from the <variable>$_POST</variable> array.</listitem>
				<listitem>In case of error, it will automatically get and print the
				message for the user.</listitem>
			</orderedlist>
			<para>Such automated component will be useful while form building. You can easily
			handle the invalid data events by refreshing the form. The components will do
			everything else, and moreover - the templates will be clear. The requested information
			will be retrieved from the template blocks, which we will pass to the parser using
			the <link linkend="library.optclass.assign" endterm="">assign()</link> method.</para>
			<para>The component creation consists in implementing the
			<link linkend="library.ioptcomponent" endterm="">ioptComponent</link> interface
			and registering the new component in the library. Create a directory somewhere
			in your project tree, and put there a file named <filename>component.myInputComponent.php</filename>.
			</para>
			<programlisting><![CDATA[<?php
 
	class myInputComponent implements ioptComponent
	{
		private $name;
		private $validForm = true;
		private $predefinedValues = array();
		private $messageBuffer = array();
		private $htmlTags = array();
		private $opt;]]></programlisting>
			<para>We define here some class fields:</para>
			<orderedlist>
				<listitem><variable>$name</variable> - remembers the input field name.</listitem>
				<listitem><variable>$validForm</variable> - the information whether the form
					is correctly validated..</listitem>
				<listitem><variable>$predefinedValues</variable> - a reference to the predefined
					form vield value list.</listitem>
				<listitem><variable>$messageBuffer</variable> - a reference to the error message
					list.</listitem>
				<listitem><variable>$htmlTags</variable> - the array of the HTML attributes
					defined for the input tag.</listitem>
				<listitem><variable>$opt</variable> - an optClass instance.</listitem>				
			</orderedlist>
			<para>The data for the first four fields are read directly from the template engine.
			The last two ones are the internal class fields. Let's write a class constructor:</para>
			<programlisting><![CDATA[		public function __construct($name = '')
		{
			if($name != '')
			{
				$this -> htmlTags['name'] = $this -> name = $name;
			}
		} // end __construct();]]></programlisting>
			<para>In case of creating components on the script side, we allow to define their
			name in the constructor, which is comfortable for the programmer. The next method,
			<function>setOptInstance()</function> is a part of the component interface. It
			gets the <classname>optClass</classname> object and reads the necessary data
			from the parser.</para>
			<programlisting><![CDATA[		public function setOptInstance(optClass $tpl)
		{
			$this -> tpl = $tpl;
			
			if(isset($this -> tpl -> data['validForm']))
			{
				$this -> validForm =
					(bool)$this -> tpl -> data['validForm'];
			}
			if(isset($this -> tpl -> data['messageBuffer']))
			{
				$this -> messageBuffer =
					&$this -> tpl -> data['messageBuffer'];
			}
			if(isset($this -> tpl -> data['predefinedValues']))
			{
				$this -> predefinedValues =
					&$this -> tpl -> data['predefinedValues'];
			}
		} // end setOptInstance();]]></programlisting>
			<para>To receive the data, we use the object we have already got. They are
			stored in the block memory: <variable>optClass::$data</variable> assotiative
			array.</para>
			<programlisting><![CDATA[		public function set($name, $value)
		{
			$this -> htmlTags[$name] = $value;
			if($name == 'name')
			{
				$this -> name = $value;
			}
		} // end set();]]></programlisting>
			<para>The method above helps us to set the component parameter values. By default,
			we treat them as HTML attributes, however, in case of the parameter named "name",
			we have to change additional class field.</para>
			<programlisting><![CDATA[		public function push($name, $value, $selected = false)
		{		
		} // end push();
 
		public function setDatasource(&$source)
		{
			$this -> predefinedValues = $source;
		} // end setDatasource(); ]]></programlisting>
			<para>Our component does not support the <function>push()</function> method, which
			is used to handle the <emphasis>listItem</emphasis> component tags. Let's take a
			look at the next method. As you might have noticed, the component normally loads
			the predefined value list automatically in <function>setOptInstance()</function>.
			Here we allow the programmer to define manually the datasource, which is treated
			as a new predefined value list. It may be changed with the <variable>datasource</variable>
			component parameter.</para>
			<programlisting><![CDATA[		public function begin()
		{
			if(!$this -> validForm)
			{
				$this -> htmlTags['value'] = $_POST[$this -> name];
			}
			else
			{
				$this -> htmlTags['value'] = '';
				if(isset($this -> predefinedValues[$this->name]))
				{
					$this -> htmlTags['value'] =
						$this -> predefinedValues[$this->name];
				}
			}
			
			echo '<input type="text" '.
				generateTagElementList($this->htmlTags).'/>';
		} // end begin();
 
		public function end()
		{		
		} // end end(); ]]></programlisting>
			<para>Now, it is time for the heart of the component - HTML code generation. We
			will stop here for a minute to describe the process. There are two methods that
			perform the task - <function>begin()</function> and <function>end()</function>.
			Between them, OPT runs the component events with the "middle" position attribute.
			In our case, there is absolutely nothing to do in <function>end()</function>,
			so we simply make "middle" be identical to position "down".</para>
			<para>The most of the <function>begin()</function> code concerns the default
			value receiving. If the form is not valid, we read the value that the user has
			already typed in order not to do this again, when the form is refreshed. In the
			other case, we first set the null value and check, if the script has got some
			predefined ones. If yes, we assign them to the component. Note that the HTML
			code is generated by simple <emphasis>echo</emphasis> command. To link the
			attribute array into a tag, we use the function <function>generateTagElementList()</function>
			available in OPT.</para>
			<programlisting><![CDATA[		public function onMessage($msg)
		{
			if(!$this -> validForm)
			{
				if(isset($this -> messageBuffer[$this->name]))
				{
					$this -> tpl -> vars[$msg] =
						$this -> messageBuffer[$this->name];
					return true;
				}
			}
			return false;
		} // end onMessage();
 
	}
 
?>]]></programlisting>
			<para>The last thing to do is to write some events. Our component has only one,
			which handles the situation, when the field is incorrectly filled in and we should
			display a message, what is wrong. The event method works in this way: it checks,
			whether the event has taken place. In this case, it returns <emphasis>true</emphasis>
			and sets a template variable with the name provided in the <variable>$msg</variable>
			variable. In our example, we set there the error message.</para>
			<para>The event activation makes the assigned HTML code displayed, which obviously
			means that the user can see the error message.</para>
			<para>Now some practical examples, how to use our newly created component. You can
			register it manually or include as a plugin. For more details, see
			<link linkend="extending.plugins" endterm="">OPT Plugins</link>. First, we will
			show a template with the component.</para>
			<programlisting><![CDATA[<html>
<head>
  <title>Open Power Template: components</title>
</head>
<body>
<opt:bindEvent id="defaultMessage" name="onMessage"
	message="msg" position="down">
<br/><span style="color: #ff0000;">{@msg}</span>
</opt:bindEvent>
 
<opt:if test="not $validForm">
<p>The form was incorrectly filled in.</p>
</opt:if>
 
<form method="post" action="script.php">
<table border="0" width="50%">
 <opt:section name="components">
 <tr>
   <td width="40%"><strong>{$components.title}</strong></td>
   <td width="60%"><opt:component id="$components.item">
	<opt:load event="defaultMessage"/>
   </opt:component></td>
 </tr>
 </opt:section>
 <tr>
   <td width="40%">&nbsp;</td>
   <td width="60%"><input type="submit" value="Send"/></td>
 </tr>
</table>
</form>
</body>
</html>]]></programlisting>
			<para>The form is fully dynamic - the components are created in the script and
			sent to the template in a section. We provided there only an undefined component,
			where we can port the objects of our class. Note also that we created the event
			outside the component - it can be now placed in a master template and used in
			other forms, so that the code is much shorter and clearer.</para>
			<para>Here we can see the power of the components - the logic of form processing,
			such as choosing the predefined value or how to handle the error messages, is hidden.
			We only point a place, where we want to have everything and provide a HTML code
			for the message.</para>
			<para>To run the example, we need one more template, to print the results.</para>
			<programlisting><![CDATA[<html>
<head>
  <title>Open Power Template: components</title>
</head>
<body>
<table border="0" width="50%">
 <tr>
   <td width="40%">Name:</td>
   <td width="60%">{$name}</td>
 </tr>
 <tr>
   <td width="40%">Surname:</td>
   <td width="60%">{$surname}</td>
 </tr>
  <tr>
   <td width="40%">E-mail:</td>
   <td width="60%">{$email}</td>
 </tr>
</table>
</body>
</html>]]></programlisting>
			<para>And now it is time for the final cut - the PHP script.</para>
			<programlisting><![CDATA[<?php
	define('OPT_DIR', './lib/');
	require('./lib/opt.class.php');
 
	try
	{	
		$tpl = new optClass;
		$tpl -> root = './templates/';
		$tpl -> compile = './templates_c/';
		$tpl -> plugins = './plugins/';
		$tpl -> gzipCompression = true;
		$tpl -> xmlsyntaxMode = true;
		$tpl -> httpHeaders(OPT_HTML);
		$tpl -> loadPlugins();]]></programlisting>
			<para>This is a simple OPT initialization. In addition to the standard procedure,
			we also load our component plugin.</para>
			<programlisting><![CDATA[		$components = array();
		$components[0] = array(
			'title' => 'Name',
			'item' => new myInputComponent('name')
		);
		$components[1] = array(
			'title' => 'Surname',
			'item' => new myInputComponent('surname')
		);
		$components[2] = array(
			'title' => 'E-mail address',
			'item' => new myInputComponent('email')
		);]]></programlisting>
			<para>The script creates here an array for the section that contains all the
			form components. We create them as normal class objects with the description
			and HTML name defined.</para>
			<programlisting><![CDATA[		if($_SERVER['REQUEST_METHOD'] == 'POST')
		{
			$valid = 1;
			$messages = array();
			if(strlen($_POST['name']) < 3)
			{
				$valid = 0;
				$messages['name'] = 'Specified name is too short!';
			}
			if(strlen($_POST['surname']) < 3)
			{
				$valid = 0;
				$messages['surname'] = 'Specified surname is too short!';
			}
			if(!preg_match('/(.+)\@(.+)\.(.+)/',
			$_POST['email']))
			{
				$valid = 0;
				$messages['email'] = 'Specified e-mail address is invalid.';
			}]]></programlisting>
			<para>Here we start the form validation. By default, we assume that the
			form is correct. Only if we notice that something is wrong with a field,
			we change the state and provide the error message to display.</para>
			<programlisting><![CDATA[			if(!$valid)
			{
				$tpl -> assign('validForm', false);
				$tpl -> assign('messageBuffer', $messages);
				$tpl -> assign('components', $components);
				$tpl -> parse('form.tpl');
			}
			else
			{
				$tpl -> assign('name', $_POST['name']);
				$tpl -> assign('surname', $_POST['surname']);
				$tpl -> assign('email', $_POST['email']);
				$tpl -> parse('results.tpl');
			}]]></programlisting>
			<para>The next part of the form processing. If the data are correct, we display
			the results in the browser, or do everything else with them. In the other case,
			the form is begin refreshed. We have to assign the information that something
			went wrong, the error messages and the component list, but nothing else. The
			rest of the login, including the previously written values, is hidden in the
			component.</para>
			<programlisting><![CDATA[		}
		else
		{
			$tpl -> assign('validForm', true);
			$tpl -> assign('components', $components);
			$tpl -> parse('form.tpl');
		} 
	}
	catch(optException $exception)
	{ 
		optErrorHandler($exception); 
	}
?>]]></programlisting>
			<para>The last lines of the script handle the situation, when the form is
			displayed for the first time. We have to tell it by setting the <variable>validForm</variable>
			block to true and provide the component array.</para>
			<para>This is the end of the component tutorial. We hope you have convinced that
			components are very nice things both for the programmer and template designer and
			you will be using it in your projects. We are currently working on the official
			OPT add-on called "Open Power Forms". It makes a strong use of the components in
			the form processing. They are connected there with the validation system and are
			easy to customize, however everything lies on the basic idea presented above.</para>
		</sect1>
		<sect1 id="extending.instructions">
			<title>New instructions</title>
			<para>This chapter describes all the issues concerning writing your own compiler
				instructions.</para>
			<sect2 id="extending.instructions.overview">
				<title>Compiler overview</title>
				<para>An instruction is an exact template compiler plugin, so first we should know,
					how it works. The OPT compiler changes the template source into a PHP code, which
					is stored in the compilation cache directory. The inspiration for it was the
					XML parser, which generates a tree of nodes, and allows to process it by our
					application. OPT also generates such tree, but it touches only the OPT tags
					and keeps away of any other XML or HTML-style data. This means you may use
					the compiler for every text content you are able to invent. Moreover, there
					are some differences between the OPT and XML connected with the alternative
					tags and the parameter handling.</para>
				<para>Let's consider the following example:</para>
				<example id="example.extending.instructions.e1">
					<title>A sample template</title>
					<programlisting><![CDATA[static text
{tag}
	static text enclosed between the tags and the block: {$block} .
{tagelse}
	alternative static text
{/tag}
static text]]></programlisting>
				</example>
				<para>The question is, what tree is generated from this simple template.</para>
				<mediaobject>
					<imageobject>
					<imagedata fileref="code-tree.png" format="png" />
					</imageobject>
				</mediaobject>
				<para>The blue elements are simply called nodes, but they contain yellow blocks. As
					you can see, blocks are used to implement the alternative tags. Moreover, they
					physically represent every tag in the template, whereas the nodes are a skeleton
					of this structure. Depending on the node type, the compiler selects the processor
					to process the node, and the processor decides, how to process the blocks. To sum
					up: the compilation algorithm is very simple. The compiler generates the tree, and
					runs the generic processor on the root node. The processor generates the PHP code
					for all the block, and if they contain some lower-level nodes, runs another
					processors for them, that generate more and more code. As a result, we get a
					fully compiled template.</para>
				<para>There are seven types of nodes in OPT:</para>
				<orderedlist>
					<listitem>Root node (<emphasis>OPT_ROOT</emphasis>) - the base of every tree. Its
						task is to run lower-level nodes.</listitem>
					<listitem>Text node (<emphasis>OPT_TEXT</emphasis>) - represents static text. It does
						not contain blocks.</listitem>
					<listitem>Instruction node (<emphasis>OPT_INSTRUCTION</emphasis>) - represents an 
						instruction. The blocks inside represent the tags to process and their content.</listitem>					
					<listitem>Expression node (<emphasis>OPT_EXPRESSION</emphasis>) - represents an
						expression. They always contain one block with the expression source as an
						attribute.</listitem>
					<listitem>Component node (<emphasis>OPT_COMPONENT</emphasis>) - represents a component.
						It is parsed by the component processor.</listitem>
					<listitem>Unknown node (<emphasis>OPT_UNKNOWN</emphasis>) - generated, if OPT does not
						know, how to process the tag. However, it is included in the tree, because maybe
						some instructions will know, what to do with it. If not, its content and children
						are lost - that is why OPT does not report the mistakes in the instruction names.</listitem>
					<listitem>Attribute node (<emphasis>OPT_ATTRIBUTE</emphasis>) - represents the
						OPT attribute. It contains one block with the attribute value.</listitem>				
				</orderedlist>
				<para>There are five types of blocks in OPT:</para>
				<orderedlist>
					<listitem><emphasis>OPT_MASTER</emphasis> - a beginning tag: {tag}</listitem>
					<listitem><emphasis>OPT_ALT</emphasis> - an alternative tag: {tagelse}</listitem>
					<listitem><emphasis>OPT_ENDER</emphasis> - a closing tag: {/tag}</listitem>
					<listitem><emphasis>OPT_COMMAND</emphasis> - a single tag: {tag /}</listitem>
					<listitem><emphasis>OPT_ATTRIBUTE</emphasis> - an OPT attribute: opt:attribute="value"</listitem>				
				</orderedlist>
				<para>The instruction processor gives hints, what instructions and attributes it can
				process, so that they could be redirected there by the compiler. The processor generates
				a PHP code then. The hints are very exact, so the compiler does not have to worry so
				much about the syntax. It is even possible to handle the <emphasis>{/tag}</emphasis> as
				the beginning tag, if the processor wants it.</para>
				<para>The blocks provide also an attribute string, which can be splitted into the
				instruction parameters. To improve this, OPT provides a built-in parameter parser, which
				must be only configured.</para>
			</sect2>
			<sect2 id="extending.instructions.first">
				<title>Your first instruction</title>
				<para>This is the time to write your first OPT instruction. It will be very simple and 
					do nothing interesting, but it will give you a clue, what is going on here. First,
					an instruction processor is a class that extends optInstruction class and overwrites
					some of its methods. In configure() we return an array with the information about
					the tags we want to register, and  instructionNodeProcess() is called by the
					parent-level processor to process the node. Here we will write our code.</para>
				<example id="example.extending.instructions.e2">
					<title>Your first instruction</title>
					<programlisting><![CDATA[<?php
	class optFirst extends optInstruction // 1
	{
		public function configure()
		{
			return array( // 2
				// processor name
				0 => 'first',
				// instructions
				'first' => OPT_MASTER,
				'/first' => OPT_ENDER
			);
		} // end configure();
		
		public function instructionNodeProcess(ioptNode $node)
		{
			foreach($node as $block) // 3
			{
				switch($block -> getName()) // 4
				{
				case 'first':
					$this -> firstBegin($block-> getAttributes());
					$this -> defaultTreeProcess($block); // 5
					break;						
				case '/first':
					$this -> firstEnd();
					break;
				}			
			}		
		} // end process();
		
		private function firstBegin($attributes)
		{
			$this -> compiler -> out('Beginning tag<br/>', true); // 6
		} // end firstBegin();
		
		private function firstEnd()
		{
			$this -> compiler -> out('Ending tag<br/>', true);
		} // end firstEnd();
	}
?>]]></programlisting>
				</example>
				<para>The description of the main parts:</para>
				<orderedlist>
					<listitem>An instruction processor has to extend <classname>optInstruction</classname> class, which
						has some very important methods and all the logic of the tree
						processing.</listitem>
					<listitem>The array returned by this method is very simple. In the element
						0, we specify the processor's name, and the rest of items (assotiative)
						register the blocks that must be recognized as "ours" and redirected
						to this processor. We also specify their types (for example
						"OPT_MASTER" for opening tag and "OPT_ENDER" for the enclosing one).</listitem>
					<listitem>The compilation tree is very easy to parse. The interface has some
						similarities to Document Object Model, and moreover - it supports natively
						PHP 5 iterators. Using a node object with a foreach loop will give us the
						blocks assigned to it.</listitem>
					<listitem>Depending on the block name (for example "first" and "/first") we
						decide, what to do now. It's good to write the block processing code in
						a separate method, because the class is much clearer then.</listitem>
					<listitem>If the block may contain some subnodes, we have to call
						<link linkend="library.optinstruction.default-tree-process" endterm="">defaultTreeProcess()</link>link>
						method and pass the current block as a parameter
						in order to process them. Don't forget about it. On the other hand, if
						you want to handle some unknown blocks, you should write your own tree
						processing method. We will show it later.</listitem>
					<listitem>This method allows to send something to the compiler output. The
						second parameter is optional. If it is not specified, the first value is
						treated as a dynamic PHP code, otherwise (true) - as a static text.</listitem>					
				</orderedlist>
				<para>In order to install this instruction, copy it to your <emphasis>plugins</emphasis>
					directory, set the path (do not forget to remove <filename>plugins.php</filename>
					and <filename>compile.php</filename> files) and try to parse the following template:</para>
				<example id="example.extending.instructions.e3">
					<title>Using the instruction</title>
					<programlisting><![CDATA[A text
{first}
A text
{/first}
A text]]></programlisting>
				</example>
				<para>Here is a small guide through the <classname>optInstruction</classname>
					class (Where To Find The Things I Need):</para>
				<itemizedlist>
					<listitem><emphasis>$this -> tpl</emphasis> - an optClass object. Refer to it in order to read the configuration.</listitem>
					<listitem><emphasis>$this -> compiler</emphasis> - an optCompiler object.</listitem>
					<listitem><emphasis>$this -> tpl -> data</emphasis> - an assotiative array of OPT blocks.</listitem>
					<listitem><emphasis>$this -> data</emphasis> - OPT blocks (inside the generated PHP code)</listitem>
					<listitem><emphasis>$this -> tpl -> vars</emphasis> - an assotiative array of OPT variables.</listitem>
					<listitem><emphasis>$this -> vars</emphasis> - OPT variables (inside the generated PHP code)</listitem>
					<listitem><emphasis>$this -> compiler -> processors</emphasis> - an assotiative array of current tag processors.</listitem>
					<listitem><emphasis>$this -> compiler -> genericBuffer</emphasis> - a buffer for the instuctions that may want to share
						some data with the others. In order to use them, create an item inside it with the
						processor name as an index.</listitem>				
				</itemizedlist>
			</sect2>
			<sect2 id="extending.instructions.parameters">
				<title>Parameter parsing</title>
				<para>This is a guide to the parameter parsing in OPT. As we mentioned, the compiler
					does not do it automatically, because you have to tell it, what you want to get
					and how to parse it. In the code above, the block methods receive the <variable>$attributes</variable>
					parameter, which contains the whole attribute string. You have two choices now:
					to parse it manually, or to use the parametrize() method. This is a sample code
					from one of the built-in instructions:</para>
				<example id="example.extending.instructions.e4">
					<title>Sample parameter parser configuration</title>
					<programlisting><![CDATA[$params = array(
	'name' => array(OPT_PARAM_REQUIRED, OPT_PARAM_ID),
	'order' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_STRING, NULL),
	'state' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_EXPRESSION, NULL),
	'datasource' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_EXPRESSION, NULL)
);
$this -> compiler -> parametrize('section', $attributes, $params);]]></programlisting>
				</example>
				<para>We build an assotiative array, where we match another arrays to the indexes
					representing the parameter names. These arrays contain two or three elements:</para>
				<orderedlist>
					<listitem>Whether it is optional or not: <emphasis>OPT_PARAM_REQUIRED</emphasis> or
						<emphasis>OPT_PARAM_OPTIONAL</emphasis>.</listitem>
					<listitem>The type of the data:
					<itemizedlist>
						<listitem><emphasis>OPT_PARAM_ID</emphasis> - an identifier containing letters, numbers and the underline.</listitem>
						<listitem><emphasis>OPT_PARAM_STRING</emphasis> - a string</listitem>
						<listitem><emphasis>OPT_PARAM_NUMBER</emphasis> - a number</listitem>
						<listitem><emphasis>OPT_PARAM_VARIABLE</emphasis> - an OPT variable (it must begin with @).</listitem>
						<listitem><emphasis>OPT_PARAM_EXPRESSION</emphasis> - an OPT expression (assignment operator not allowed)</listitem>
						<listitem><emphasis>OPT_PARAM_ASSIGN_EXPR</emphasis> - an OPT expression (assignment operator allowed).</listitem>				
					</itemizedlist>
					</listitem>
					<listitem>Optional value (set only, if you have chosen <emphasis>OPT_PARAM_OPTIONAL</emphasis> in the first item).</listitem>		
				</orderedlist>
				<para>Remember that the required parameters must be specified before the optional ones!
					After creating the array, you call the parametrize() method with the following
					parameters:</para>
				<orderedlist>
					<listitem>The instruction name (only for debug purposes).</listitem>
					<listitem>The attribute string</listitem>
					<listitem>The array (note this parameter requires a reference).</listitem>					
				</orderedlist>
				<para>The method will process the string and replace the values in the
					<variable>$params</variable> array with the compiled content. Now we can use
					<variable>$params['name']</variable>, when we want to put the name parameter
					somewhere.</para>
				<para>To show it in practise, we are going to modify the instruction from the previous
					example. Now it will take a block or variable, and make the code inside a bit dynamic:
					if the block is not set, the content between the tags will not be displayed.</para>
				<example id="example.extending.instructions.e5">
					<title>Parameter parsing</title>
					<programlisting><![CDATA[<?php
	class optFirst extends optInstruction
	{
		public function configure()
		{
			return array(
				// processor name
				0 => 'first',
				// instructions
				'first' => OPT_MASTER,
				'/first' => OPT_ENDER
			);
		} // end configure();
		
		public function instructionNodeProcess(ioptNode $node)
		{
			foreach($node as $block)
			{
				switch($block -> getName())
				{
				case 'first':
					$this -> firstBegin($block -> getAttributes());
					$this -> defaultTreeProcess($block);
					break;						
				case '/first':
					$this -> firstEnd();
					break;
				}			
			}		
		} // end process();
		
		private function firstBegin($attributes)
		{
			$params = array(
				'test' => array(OPT_PARAM_REQUIRED,
					 OPT_PARAM_EXPRESSION)
			);
			$this -> compiler -> parametrize('first',
				$attributes, $params);
			// A dynamic code
			$this -> compiler -> out(' if(isset('.$params['test'].')){ ');
		} // end firstBegin();
		
		private function firstEnd()
		{
			$this -> compiler -> out(' } ');
		} // end firstEnd();
	}	
?>]]></programlisting>
				</example>
				<para>The OPT parameter parser can do more than we have already shown. There
					are some extra issues:</para>
				<orderedlist>
					<listitem>By default, OPT supports both of the parameter styles:
						<emphasis>=value1; value2; value3;</emphasis> and
						<emphasis>name1="value" name2="value" name3="value"</emphasis>. However, you
						can force using only one of them with the fourth, optional parameter of the
						parametrize() method. It takes the following values: <emphasis>OPT_STYLE_BOTH</emphasis> - both
						styles accepted; <emphasis>OPT_STYLE_OPT</emphasis> - only the OPT style;
						<emphasis>OPT_STYLE_XML</emphasis> - only the HTML/XML style.</listitem>
					<listitem>This method can also handle unlimited number of parameters. To
						describe, how to parse undefined parameters, add a special parameter named
						<emphasis>__UNKNOWN__</emphasis>. All the parameters not appearing on the
						list will be now parsed using this pattern and returned by the method as a
						separate array:</listitem>					
				</orderedlist>
				<example id="example.extending.instructions.e6">
					<title>Undefined parameters</title>
					<programlisting><![CDATA[$params = array(
	'__UNKNOWN__' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_EXPRESSION, NULL)
);
$undef = $this -> compiler -> parametrize('include', $attributes, $params);]]></programlisting>
				</example>
				<para>The undefined parameters are kept in <variable>$undef</variable> assotiative array,
					whereas the defined ones - in <variable>$params</variable>.</para>
			</sect2>
			<sect2 id="extending.instructions.unknown">
				<title>Handling OPT_UNKNOWN nodes</title>
				<para>Each node is an object of
					<link linkend="library.optnode" endterm="">optNode</link> class. Each block is an
					object of <link linkend="library.optblock" endterm="">optBlock</link> class. They
					support the <classname>Iterator</classname> interface by default, so you can get
					their children with a normal foreach loop:</para>
				<example id="example.extending.instructions.e7">
					<title>Iterators</title>
					<programlisting><![CDATA[foreach($block as $node)
{
	// Your code here
}]]></programlisting>
				</example>
				<para>See the reference for these two classes in order to find useful methods that help
					in the tree processing. Write your own code instead of calling <emphasis>defaultTreeProcess()</emphasis> method
					in your instruction processor. Use the loops and the methods to receive the information
					about the tags, and then generate some PHP code for them.</para>
			</sect2>
			<sect2 id="extending.instructions.attributes">
				<title>Handling OPT attributes</title>
				<para>The OPT attributes are redirected to the <emphasis>processAttribute()</emphasis>
				method, which you have to extend in order to capture them. The method takes one parameter:
				the object of <link linkend="library.optblock" endterm="">optBlock</link> class with
				the attribute data.</para>
				<example id="example.extending.instructions.e8">
					<title>Handling OPT attributes</title>
					<programlisting><![CDATA[<?php
	class optFirst extends optInstruction // 1
	{
		public function configure()
		{
			return array( // 2
				// processor name
				0 => 'first',
				// instructions
				'first' => OPT_MASTER,
				'/first' => OPT_ENDER,
				'attribute' => OPT_ATTRIBUTE,
				'attr2' => OPT_ATTRIBUTE
			);
		} // end configure();
		
		public function instructionNodeProcess(ioptNode $node)
		{
			foreach($node as $block) // 3
			{
				switch($block -> getName()) // 4
				{
				case 'first':
					$this -> firstBegin($block-> getAttributes());
					$this -> defaultTreeProcess($block); // 5
					break;						
				case '/first':
					$this -> firstEnd();
					break;
				}			
			}		
		} // end process();
		
		private function firstBegin($attributes)
		{
			$this -> compiler -> out('Beginning tag<br/>', true); // 6
		} // end firstBegin();
		
		private function firstEnd()
		{
			$this -> compiler -> out('Ending tag<br/>', true);
		} // end firstEnd();
					
		public function processAttribute(optBlock $block)
		{
			switch($block -> getName())
			{
				case 'attribute':
					$this -> compiler -> out(' echo \'Im an attribute!\'; ');
					break;	
				case 'attr2':
					$this -> compiler -> out(' echo \'Im another attribute!\'; ');
					break;
			}					
		} // end processAttribute();
	}
?>]]></programlisting>
				</example>
				<para>The attributes are first registered in the <emphasis>configure()</emphasis> method
				and then we choose, what to do with them, with a simple switch statement. The method
				must generate some PHP code for the compiler.</para>
			</sect2>
			<sect2 id="extending.instructions.opt">
				<title>Handling $opt special block</title>
				<para>1.Your instructions can extend the <variable>$opt</variable> special block. Just
					write a special method <emphasis>processOpt()</emphasis> in the processor. The
					compiler will redirect there the calls of <variable>$opt.processorname.etc</variable>.
					The method must take exactly one parameter, which is an array of the block
					structure (for the code above it will be: 0=>opt; 1=>processorname; 2=>etc). The
					method must return the PHP code that the block will be replaced to.</para>
				<example id="example.extending.instructions.e9">
					<title>Handling $opt special block</title>
					<programlisting><![CDATA[public function processOpt($namespace)
{
	return '\''.sha1($namespace[2]).'\'';
} // end processOpt();]]></programlisting>
				</example>
				<para>This code will handle each call of <variable>$opt.processor.ppp</variable> and
					will encrypt the ppp string with the SHA1 algorithm.</para>
			</sect2>
			<sect2 id="extending.instructions.other">
				<title>Other features and tricks</title>
				<orderedlist>
					<listitem>Closing tags can also have attributes. OPT does not require non-attribute tags in this place, so you can handle them, like in any other tag type.</listitem>
					<listitem>In order to make some PHP code "dynamic" (in sense of the output caching),
						call the <emphasis>$this->compiler->dynamic()</emphasis> method and pass the
						new state as a parameter (true - begins the dynamic code). But notice that
						this method is also used by the <emphasis>{dynamic}</emphasis> instruction.
						If you do not want to create conflicts, always check the state in this
						instruction's processor (<emphasis>$this->compiler->processors['dynamic']->active</emphasis>).</listitem>
					<listitem>In order to generate a compiler error, call the
						<emphasis>$this->tpl->error()</emphasis> method. It takes three parameters:
						the error type (<emphasis>E_USER_ERROR</emphasis> or <emphasis>E_USER_WARNING</emphasis>),
						the error description and the error code. For user extensions, the codes from 401 are reserved.</listitem>
					<listitem>The instructions can control, whether they can be executed in master templates,
					or not. Define the protected class variable <variable>$inMaster</variable> set to
					true in order to allow the use in the master template. While processing, you can always
					check the current state by the <variable>$this -> compiler -> master</variable>. True means
					the master template is being processed.</listitem>
				</orderedlist>
			</sect2>
		</sect1>
		<sect1 id="extending.plugins">
			<title>OPT plugins</title>
			<para>Open Power Template supports a plugin system. You may download the plugins from the
				Internet or just keep your add-ons in separate files and the library automatically
				loads them during the setup. However, remember that these files have to be included
				by PHP, which is a bit slower, than storing everything in one, big file (especially
				if you have many plugins). If your priority is the performance, consider the second
				solution and linking the new items with <emphasis>registerXXX()</emphasis> methods.</para>
			<para>In order to enable plugins, set the <emphasis>plugins</emphasis> configuration
				directive to the current plugin directory. It must be both readable and writeable
				for PHP, because OPT needs to save there two files containing information about
				the directory content, not to scan it every time. Except those two ones, all other
				files must be named in this way: <filename>type.name.php</filename>, where "type" is
				the type of item we want to add. The following types are available:</para>
			<orderedlist>
				<listitem><emphasis>component</emphasis> - registers a new component class
					with the specified name. It will be also available under it. Sample:
					<filename>component.sampleComponent.php</filename>.</listitem>
				<listitem><emphasis>instruction</emphasis> - registers a new OPT instruction
					processor class with the specified name. Note that the information about
					registered instructions is read from the class.
					Sample: <filename>instruction.optNewInstruction.php</filename> - will register
					"optNewInstruction" instruction processor.</listitem>
				<listitem><emphasis>function</emphasis> - registers a new OPT function with
					the specified name (it must not contain the "opt" prefix). The function
					will be available in the templates under the same name.
					Sample: <filename>function.Power.php</filename> will register a function "Power", which
					source code is located in "optPower" PHP function.</listitem>
				<listitem><emphasis>prefilter, postfilter, outputfilter</emphasis> - these
					types represent three content filters available in OPT. They register them
					under the specified name (without the "optSomefilter" prefix!). Sample:
					<filename>postfilter.Optimize.php</filename> will register the "Optimize" postfilter, which
					code is stored in "optPostfilterOptimize" PHP function.</listitem>
				<listitem><emphasis>resource</emphasis> - not tested yet.</listitem>			
			</orderedlist>
			<para>Remember that after installing new plugins you have to remove the files
				<filename>plugins.php</filename> and <filename>compile.php</filename> manually
				from the plugin directory.</para>
			<para>By default, the plugins are loaded automatically, when OPT needs them. However,
				you can call the <link linkend="library.optclass.load-plugins" endterm="">loadPlugins()</link>
				manually, which may be especially useful, when working with components on the script-side.</para>
		</sect1>
		<sect1 id="extending.api">
			<title>OPT API</title>
			<para>OPT API is a simplified version of the main OPT parser. It contains only the
				most important methods and fields necessary to run the compiler. OPT API is the
				best solution, if you want to use OPT as a parser in your e-mailer class or 
				similar. The <classname>optApi</classname> class contains the following methods
				and fields from the main parser:</para>
			<orderedlist>
				<listitem><emphasis>assign()</emphasis></listitem>
				<listitem><emphasis>assignGroup()</emphasis></listitem>
				<listitem><emphasis>assignRef()</emphasis></listitem>
				<listitem><emphasis>error()</emphasis></listitem>
				<listitem><emphasis>fetch()</emphasis></listitem>
				<listitem><emphasis>registerInstruction()</emphasis></listitem>
				<listitem><emphasis>registerInstructionFile()</emphasis></listitem>
				<listitem><emphasis>setDefaultI18n()</emphasis></listitem>
				<listitem><emphasis>setObjectI18n()</emphasis></listitem>
				<listitem><emphasis>parse()</emphasis></listitem>
				<listitem>All the configuration directives.</listitem>
				<listitem>All the fields with the registered items.</listitem>
				<listitem>All the template data fields.</listitem>
			</orderedlist>
			<para>In order to use OPT API, load the <filename>opt.api.php</filename> file into
			your script. You can keep both the main parser and the API loaded - just remember
			to include the <filename>opt.api.php</filename> <emphasis>after</emphasis> you
			load the <filename>opt.class.php</filename> file.</para>
			<para>By default, OPT API is null - there are no instructions or functions registered.
			It is you, who decides, what the parser can. The API provides a method only for
			instruction adding, because it is a bit complicated task. To add other features,
			you fill the following class fields manually:</para>
			<orderedlist>
				<listitem><emphasis>optApi::$functions</emphasis> - an assotiative array of
					registered functions. It contains the pairs: "OPT function name" => "PHP
					function name (without prefix!)"</listitem>
				<listitem><emphasis>optApi::$phpFunctions</emphasis> - an assotiative array of
					PHP functions available in the templates. It contains the pairs: "OPT
					function name" => "PHP function name"</listitem>
				<listitem><emphasis>optApi::$namespaces</emphasis> - an array of registered
					namespaces. "opt" is available by default.</listitem>
				<listitem><emphasis>optApi::$components</emphasis> - an assotiative array of
					registered components. The component class name is an index, the value must
					be set to 1.</listitem>
				<listitem><emphasis>optApi::$delimiters</emphasis> - a list of Perl regular
					expressions that define the available delimiters.</listitem>
				<listitem><emphasis>optApi::$filters</emphasis> - the field contains three arrays:
					"pre", "preMaster", "post" and "output" - the buffers for the available
					filter types. The arrays are pairs of "filter identifier" => "PHP function
					name (without prefix!)"</listitem>
			</orderedlist>
			<para>Note that OPT API does not have custom resource support.</para>
			<para>Although OPT API provides some simple template parsing methods, you can freely
			write new ones, if you need it. To load and (optionally) compile a template,
			the parsing method must contain the following code:</para>
			<example id="example.extending.api.e1">
				<title>Writing custom parsing methods</title>
				<programlisting><![CDATA[public function customParse($tpl)
{
	$compiled = $this -> needCompile($tpl); // 1
				
	$oldErrorReporting = error_reporting(E_ALL ^ E_NOTICE); // 2
	include($this -> compile.$compiled);
	error_reporting($oldErrorReporting);
} // end customParse();]]></programlisting>
			</example>
			<orderedlist>
				<listitem>The <emphasis>needCompile()</emphasis> method generates a compiled
				template name, which is later returned, and tries to compile the template,
				if it has not been done yet.</listitem>
				<listitem>To parse a template, we simply include the compiled version. Before
				that, we must change the error reporting level in order not to report the null
				blocks as notices. After that, we restore the original level.</listitem>
			</orderedlist>
			<para>To capture the generated output, OPT uses <emphasis>ob_start()</emphasis>
			and <emphasis>ob_get_clean()</emphasis> methods.</para>
			<para>To explain, how to control the compiler manually, we are going to describe
			the <emphasis>needCompile()</emphasis> method:</para>
			<example id="example.extending.api.e2">
				<title>Controlling the compiler</title>
				<programlisting><![CDATA[protected function needCompile($filename, $noException = false)
{
	$compiled = optCompileFilename($filename); // 1
	
	$compiledTime = @filemtime($this -> compile.$compiled); // 2
	$result = false;
	$rootTime = @filemtime($this -> root.$filename);
	if($rootTime === false)
	{
		// 3
		if($noException)
		{
			return NULL;
		}
		$this -> error(E_USER_ERROR, '"'.$filename.'" not found in '.$this->root.' directory.', OPT_E_FILE_NOT_FOUND);
	}
	if($compiledTime === false || $compiledTime < $rootTime || $this -> alwaysRebuild)
	{
		// 4
		$result = file_get_contents($this -> root.$filename);
	}
		
	if($result === false)
	{
		// 5
		return $compiled;
	}

	if(!is_object($this -> compiler))
	{
		// 6
		require_once(OPT_DIR.'opt.compiler.php');
		$this -> compiler = new optCompiler($this);
	}
	$this -> compiler -> parse($this -> compile.$compiled, $result); // 7
	return $compiled; // 8
} // end needCompile();]]></programlisting>
			</example>
			<orderedlist>
				<listitem>First, we generate the compiled template filename.</listitem>
				<listitem>We check the modification time. Note that we also check whether
				the files exist, using <emphasis>filemtime()</emphasis> function, to minimize
				the number of disk operations.</listitem>
				<listitem>There is no such template - we have an error!</listitem>
				<listitem>Here we have a situation, where the template is not compiled - we
				load its source into memory.</listitem>
				<listitem>If there is no need to recompile the template, the <variable>$result</variable>
				will be empty - the script can return the compiled filename here.</listitem>
				<listitem>The template must be compiled. If the compiler is not loaded, we
				do it. The API passes itself as a parameter to the compiler constructor. The
				compiler may be also created from the main OPT parser or from another compiler -
				it is needed to import the list of registered features etc.</listitem>
				<listitem>We request the template compilation. As a first parameter, we pass
				the path to the compiled file, as a second - the template source. The optional
				third parameter, which is not used here, tells whether we parse a normal template
				(false, default) or a master template (true).</listitem>
				<listitem>Once we have done the compilation, we return the compiled filename.</listitem>
			</orderedlist>
			<para>As you see in the listing, OPT API does not support the <emphasis>performance</emphasis>
			directive.</para>
		</sect1>
	</chapter>
	<appendix label="A" id="appendix.a">
		<title>Migracja ze Smarty™</title>
		<para>Smarty™ to jeden z najbardziej znanych systemów szablonów dla PHP. Napisano już o
			nim wiele książek i artykułów, jednak został on stworzony dla PHP4, a wiele jego elementów
			nie jest zaprojektowanych tak, jak by sobie wiele osób tego życzyło. Jednym z założeń
			OPT było ulepszenie tego wszystkiego, co w Smartym przeszkadza oraz dodanie nowych
			możliwości. Wymagało to jednak wprowadzenia pewnych różnić między obiema bibliotekami.
			Ten krótki dodatek przeznaczony jest dla osób korzystających dotąd ze Smarty'ego, które
			chciałyby poznać nowy system szybko i bez problemów.</para>
		<para>Zacznijmy od krótkiego słowniczka. Obie biblioteki używają wielu elementów o podobnych
		nazwach, ale w rzeczywistości będących czym innym.</para>
		<table frame="all" id="smarty.opt.glossary">
			<?dbhtml table-width="100%" ?>
			<caption>Słowniczek OPT-Smarty</caption>
			<tgroup cols="3" align="center">
			<thead>
			<row>
			  <entry>Smarty</entry>
			  <entry>OPT</entry>
			  <entry>Komentarze</entry>
			</row>
			</thead>
			<tbody>
			<row>
			  <entry>zmienna</entry>
			  <entry>blok</entry>
			  <entry>W OPT zmienna jest jednym z rodzajów bloku. Zwykłe bloki są tworzone przez programistę w skrypcie, zmienne
				  przez szablony do własnych celów. Takie odróżnienie pozwala unikać konfliktów nazw.</entry>
			</row>
			<row>
			  <entry>funkcja, blok</entry>
			  <entry>instrukcja</entry>
			  <entry>Funkcje i bloki Smarty'ego to w OPT jedno i to samo: instrukcje.</entry>
			</row>
			<row>
			  <entry>modyfikator</entry>
			  <entry>funkcja</entry>
			  <entry>OPT używa składni z języków programowania: <emphasis>name(args)</emphasis>.</entry>
			</row>
			<row>
			  <entry>obiekt</entry>
			  <entry>blok</entry>
			  <entry>W OPT obiekty są jednym z typów bloków.</entry>
			</row>
			<row>
			  <entry>sekcja</entry>
			  <entry>pętla</entry>
			  <entry>Sekcja ze Smarty'ego to tak naprawdę pętla z wieloma dodatkami. W OPT sekcje są
			  znacznie bardziej wyspecjalizowaną konstrukcją.</entry>
			</row>
			<row>
			  <entry>cache</entry>
			  <entry>cache wyjścia</entry>
			  <entry><emphasis>Cache kompilacji</emphasis> oznacza katalog, gdzie OPT przechowuje
				  skompilowane szablony.</entry>
			</row>
			</tbody>
			</tgroup>
		</table>
		<para>Inicjacja OPT jest podobna, jak w Smartym. Główna różnica to standard nazewnictwa. W OPT nazwy są w formacie <emphasis>nazwaNazwa()</emphasis>,
			w Smartym - <emphasis>nazwa_nazwa()</emphasis>. Konfiguracja może być ładowana tylko z poziomu PHP, ale
			za to są trzy sposoby na dokonanie tego:</para>
		<orderedlist>
			<listitem>Plik konfiguracyjny ze składnią a'la <filename>php.ini</filename></listitem>
			<listitem>Stworzenie tablicy PHP z dyrektywami.</listitem>
			<listitem>Ręczne ustawianie każdej dyrektywy, jak w Smartym.</listitem>
		</orderedlist>
		<para>W OPT również nie trzeba określać wszystkich opcji. Jedynymi wymaganymi są: <variable>root</variable> oraz <variable>compile</variable>
			zawierające ścieżki do źródeł szablonów i do katalogu na szablony skompilowane..</para>
		<para>Nagłówki HTTP mogą być wysyłane tylko z poziomu skryptu. Do tego służy metoda
		<link linkend="library.optclass.http-headers" endterm="">optClass::httpHeaders()</link>
		Możesz ustawić w niej rodzaj zawartości (Content-type), proste informacje dot. cache'owania
		oraz informację o kodowaniu (za pomocą konfiguracji). Należy dodać, że OPT potrafi wykryć,
		czy przeglądarka przyjmuje nagłówki XHTML i w razie problemów wysłać zastępczy typ.</para>
		<para>OPT wykorzystuje nowe możliwości PHP5, jak np. wyjątki. Generalnie cały kod korzystający z
			systemu szablonów powinien być umieszczony w bloku <emphasis>try...catch</emphasis>.
			Jeśli nie chcesz pisać własnej obsługi wyjątków, możesz skorzystać z gotowej funkcji:
			<emphasis>optErrorHandler($exception)</emphasis>.</para>
		<example id="example.appendix.a.e1">
			<title>Przykładowa inicjacja OPT</title>
			<programlisting><![CDATA[<?php
define('OPT_DIR', './opt/');
require(OPT_DIR.'opt.class.php');
try{
  $tpl = new optClass;
  $tpl -> root = 'templates/';
  $tpl -> compile = 'templates_c/';
  $tpl -> httpHeaders(OPT_HTML);
 
  // przetwarzanie szablonów
 
}catch(optException $ex){
  optErrorHandler($ex);
}
?>]]></programlisting>
		</example>
		<para>Zamiennikiem dla dyrektywy <variable>compile_check</variable> ze Smarty'ego jest
			<variable>performance</variable>, jednak należy zwrócić uwagę na pewną rzecz.
			<emphasis>$smarty->compile_check=true</emphasis> to w OPT <emphasis>$opt->performance=false</emphasis>
			i na odwrót (czyli innymi słowy, jedna dyrektywa jest negacją drugiej i działa w odwrotny sposób).</para>
		<para>Przyjrzyj się poniższemu szablonowi:</para>
		<programlisting><![CDATA[<ul>
{section name=i loop=$items}
	<li>{$items[i].title} <ul>
		{section name=j loop=$subitems}
			<li>{$subitems[i][j].title}</li>
		{/section}		
		</ul></li>
{/section}
</ul>]]></programlisting>
		<para>W ten sposób Smarty tworzy wszelkiego rodzaju listy itd. Dodanie kolejnego
			poziomu komplikuje kod jeszcze bardziej. OPT nie lubi takich konstrukcji, ponieważ
			zawierają one szereg zbędnych elementów, które w ogóle nie pomagają twórcy szablonów
			i sprawiają, że zaimplementowanie bardziej zaawansowanych rzeczy jest kłopotliwe.
			Wprawdzie zarówno OPT, jak i Smarty oferują pełne języki programowania po stronie szablonów,
			lecz pierwszy z nich zaleca korzystanie z nich tylko w ostateczności, jako że na co dzień
			używa się wielu znacznie prostszych i automatycznych instrukcji, które same wiedzą,
			co mają robić. Jak więc myślisz, jak powyższy kod będzie wyglądać w OPT?</para>
		<programlisting><![CDATA[<ul>
{section=items}
	<li>{$items.title} <ul>
		{section=subitems}
			<li>{$subitems.title}</li>
		{/section}		
	</ul></li>
{/section}
</ul>]]></programlisting>
		<para>Zero zabawy z iteratorami, zagnieżdżeniami itd. OPT łączy wszystko automatycznie. Bardzo
		łatwo można rozszerzyć ten kod tak, aby nie pokazywał znaczników UL, jeśli lista jest pusta:</para>
		<programlisting><![CDATA[{show=items}
<ul>
{section}
	<li>{$items.title} {show=subitems}<ul>
		{section}
			<li>{$subitems.title}</li>
		{/section}		
	</ul>{/show}</li>
{/section}
</ul>
{/show}]]></programlisting>
		<para>Od wersji 1.1.0, OPT zawiera specjalną instrukcję do renderowania hierarchicznych drzew:</para>
		<programlisting><![CDATA[<ol>
{tree=mytree}
	{leaf}
		<li>{$mytree.title}</li>
	{/leaf}
	{opening}
		<li>{$mytree.title}<ol>
	{/opening}
	{closing}
		</ol></li>
	{/closing}
{/tree}
</ol>
]]></programlisting>
		<para>W OPT jest znacznie więcej takich prostych w użyciu instrukcji. W rzeczywistości niemal wszystkie
		rzeczy używane na co dzień są w jakiś sposób zaimplementowane w parserze i mogą być zastosowane bez
		żadnej wiedzy programistycznej, podczas gdy Smarty wymaga w tym samym miejscu używania skomplikowanych lub
		ciężkich do rozczytania algorytmów. Co więcej, takie uproszczenia przydają się również bardziej zaawansowanym
			użytkownikom - upraszczają one kod i czynią go czytelniejszym.</para>

	</appendix>
	<appendix label="B" id="appendix.b">
		<title>Dyrektywy konfiguracyjne</title>
		<para>Pełna lista dyrektyw konfiguracyjnych:</para>
		<glossary>
			<title>Konfiguracja</title>
			<glossentry id="root">
				<glossterm>root</glossterm>
				<glossdef>
				<para>(tekst) Określa katalog, w którym zapisywane są pliki źródłowe szablonów. Skrypt musi mieć w nim prawa do odczytu.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="compile">
				<glossterm>compile</glossterm>
				<glossdef>
				<para>(tekst) Określa katalog, w którym OPT będzie składował skompilowane szablony. Skrypt musi mieć w nim prawa do zapisu.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="cache">
				<glossterm>cache</glossterm>
				<glossdef>
				<para>(tekst) Określa katalog, w którym składowane są pliki systemu cache. Skrypt musi mieć w nim prawa do zapisu. Jeśli dyrektywa ta nie jest ustawiona, system cache nie jest dostępny.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="plugins">
				<glossterm>plugins</glossterm>
				<glossdef>
				<para>(tekst) Definiuje katalog, w którym przechowywane są pluginy dla parsera. Skrypt musi mieć w nim prawa do zapisu, ponieważ generuje tam rezultat skanowania zawartości katalogu w poszukiwaniu pluginów. Od wersji 1.1.3 możliwe jest także używanie tablicy nazw katalogów - OPT załaduje wtedy pluginy z każdego z nich.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="gzipCompression">
				<glossterm>gzipCompression</glossterm>
				<glossdef>
				<para>(boolean) Czy kompresja gZip jest włączona? <emphasis>Ostrzeżenie:</emphasis> jeśli włączasz tę opcję, upewnij się, że NIE WYSŁAŁEŚ dotąd żadnego kodu do przeglądarki (nawet spacji)! W przeciwnym razie ujrzysz na ekranie krzaki zamiast strony internetowej. W szczególności przyjrzyj się, czy skrypt nie wysyła niczego przed pierwszym wywołaniem metody <link linkend="library.optclass.parse" endterm="">optClass::parse()</link>, która włącza kompresję.
					Jeśli kompresja jest włączona po stronie pliku <filename>php.ini</filename>, dyrektywa ta nie robi nic.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="charset">
				<glossterm>charset</glossterm>
				<glossdef>
				<para>(tekst) Definiuje kodowanie używane w generowanych dokumentach. Należy ustawić tę dyrektywę przed wywołaniem metody <link linkend="library.optclass.http-headers" endterm="">optClass::httpHeaders()</link>.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="alwaysRebuild">
				<glossterm>alwaysRebuild</glossterm>
				<glossdef>
				<para>(boolean) Szablon jest rekompilowany za każdym razem. Używać tylko do debugowania.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="showWarnings">
				<glossterm>showWarnings</glossterm>
				<glossdef>
				<para>(boolean) Ustaw na "true", aby OPT generował także komunikaty o ostrzeżeniach.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="debugConsole">
				<glossterm>debugConsole</glossterm>
				<glossdef>
				<para>(boolean) Ustaw na "true", aby aktywować konsolę debugową. Jest to wyskakujące okienko z dodatkowymi informacjami o pracy parsera (m.in. o szybkości przetwarzania szablonów). Jeśli konsola debugowa jest włączona, OPT wysyła nagłówek "text/html" zamiast "application/xml+xhtml".
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="performance">
				<glossterm>performance</glossterm>
				<glossdef>
				<para>(boolean) Ustaw na "true", kiedy skończysz już prace nad serwisem. Dyrektywa ta przyspiesza działanie parsera poprzez wyłączenie sprawdzania, czy szablon został zmieniony. W praktyce oznacza to, że za cenę większej szybkości OPT przestaje automatycznie kompilować szablony nawet, jeśli ich treść została zmieniona. Nie jest również dokonywane sprawdzanie, czy szablon istnieje.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="xmlsyntaxMode">
				<glossterm>xmlsyntaxMode</glossterm>
				<glossdef>
				<para>(boolean) Ustaw na "true", aby aktywować <link linkend="syntax.xmlmode" endterm="">Tryb składni XML</link>.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="strictSyntax">
				<glossterm>strictSyntax</glossterm>
				<glossdef>
				<para>(boolean) Ustaw na "true", aby wymusić używanie przez instrukcje standardowego parsera parametrów. Jeśli włączysz tryb składni XML, ta dyrektywa również włącza się automatycznie.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="entities">
				<glossterm>entities</glossterm>
				<glossdef>
				<para>(boolean) Umożliwia parserowi przetwarzanie encji XHTML w znacznikach i blokach. Jeśli jest włączony tryb składni XML, encje włączone są automatycznie.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="sectionStructure">
				<glossterm>sectionStructure</glossterm>
				<glossdef>
				<para>(int) Określa domyślny format tablicy danych dla sekcji. W <emphasis>OPT_SECTION_MULTI</emphasis> (domyślne) każda sekcja przechowuje swoje dane w oddzielnej tablicy. W <emphasis>OPT_SECTION_SINGLE</emphasis> dane sekcji zagnieżdżonych przechowywane są w tablicy sekcji nadrzędnej.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="sectionDynamic">
				<glossterm>sectionDynamic</glossterm>
				<glossdef>
				<para>(int) Określa sposób przetwarzania sekcji dynamicznych. <emphasis>OPT_SECTION_COMPILE</emphasis> (domyślne) - sprawdzanie, czy sekcja jest dynamiczna,
					zachodzi już na etapie kompilacji szablonu, dzięki czemu kod do ich obsługi jest doklejany tylko do tych sekcji, które tego potrzebują. Wymaga to jednak ustawienia
					sekcji dynamicznych jeszcze przed kompilacją i trzymania się tego wyboru, ponieważ po skompilowaniu nie można już tego zmienić. <emphasis>OPT_SECTION_RUNTIME</emphasis> 
					sprawdza, czy sekcja jest dynamiczna, w trakcie wykonywania, przez co można swobodnie używać tej samej sekcji na obydwa sposoby. Jednakże z powodu konieczności wykonywania
					takiego sprawdzania w każdej sekcji, takie szablony wykonują się nieco wolniej. Oba ustawienia nie powodują konieczności wprowadzania zmian do szablonu.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="parseintDecPoint">
				<glossterm>parseintDecPoint</glossterm>
				<glossdef>
				<para>(string) Separator części ułamkowej dla funkcji <link linkend="syntax.functions.parseint" endterm="">parseInt</link>.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="parseintDecimals">
				<glossterm>parseintDecimals</glossterm>
				<glossdef>
				<para>(int) Ilość cyfr w grupie dla funkcji <link linkend="syntax.functions.parseint" endterm="">parseInt</link>.
				</para>
				</glossdef>
			</glossentry>
			<glossentry id="parseintThousands">
				<glossterm>parseintThousands</glossterm>
				<glossdef>
				<para>(string) Separator części tysięcznych dla funkcji <link linkend="syntax.functions.parseint" endterm="">parseInt</link>.
				</para>
				</glossdef>
			</glossentry>
		</glossary>
	</appendix>
	<appendix label="C" id="appendix.c">
		<title>Debugowanie kodu</title>
		<para>Ten dodatek opisuje zaganienia związane z debugowaniem kodu.</para>
		<sect4 id="appendix.c.template">
			<title>Kompilacja szablonu</title>
			<para>Najczęstsze problemy wiążą się z generowaniem na podstawie szablonu drzewa
				węzłów. Kompilator raportuje każdy niedomknięty znacznik i zwraca uwagę na
				kolejność ich zamykania. Jeśli wystąpi błąd, generowany jest wyjątek, a plik
				wyjściowy nie jest tworzony. Jeśli otrzymasz komunikat  <emphasis>Fatal
				error: Call to a member function restoreBlock() on a non-object</emphasis>,
				także oznacza to niedomknięty znacznik, niemniej zgłoś to jako błąd OPT w
				bugtrackerze wraz z szablonem powodującym problem.</para>
			<para>Kompilator <emphasis>nie zgłasza</emphasis> literówek w nazwach instrukcji.
				W takim wypadku generowany jest węzeł nieznanego typu, co jest dopuszczalne
				przez specyfikację składi OPT (być może jakaś inna instrukcja wie, jak go
				przetworzyć). Jeśli widzisz, że jakiś kawałek kodu w tajemniczy sposób znika
				z generowanego dokumentu i nie jest wykonywany, sprawdź nazwę instrukcji!
				Bardzo możliwe, że zrobiłeś tam literówkę.</para>
			<para>Na czas wykonywania szablonu OPT zmienia poziom raportowania błędów na <emphasis>E_ALL &amp; ~E_NOTICE</emphasis>.
				Oznacza to, że powiadomienia (notices) w kodzie szablonu nie są zgłaszane, co jest
				celowym zabiegiem. Po wykonaniu szablonu OPT przywraca pierwotny poziom raportowania.</para>
		</sect4>
		<sect4 id="appendix.c.expression">
			<title>Kompilacja wyrażeń</title>
			<para>Począwszy od wersji 1.0.0-RC2, OPT wykrywa większość błędów w składni wyrażeń,
				dzięki czemu nie dopuszcza do utworzenia wadliwego kodu PHP. W takich sytuacjach
				generowany jest wyjątek: <emphasis>108 (Unexpected
				token: OPCODE_TOKENNAME (token value) in expression (invalid expression))</emphasis>.
				Oznacza on, że podany token został użyty w wyrażeniu w nieprawidłowy sposób.</para>
			<para>Zastosowany filtr nie jest jeszcze doskonały i zdarza się (aczkolwiek bardzo rzadko),
				że jakieś błędne wyrażenie zostanie przepuszczone. W tej sytuacji otrzymasz błąd składni PHP.</para>
		</sect4>
		<sect4 id="appendix.c.encoding">
			<title>Kodowanie</title>
			<para>Wiele przeglądarek prawidłowo rozpoznaje kodowanie Unicode tylko wtedy, gdy jest ono ustawione
				również w nagłówku HTTP. Aby wysyłać dokumenty unicode do przeglądarki, musisz ustawić dyrektywę
				konfiguracyjną "charset" na żądane kodowanie i wywołać metodę 
				<link linkend="library.optclass.http-headers" enterm="">optClass::httpHeaders()</link>
				Bez niej przeglądarka nie będzie potrafiła wykryć prawidłowo kodowania nawet jeśli będzie ono wpisane
				w znacznikach META.</para>
			<para>Ważna informacja: OPT <emphasis>nie uszkadza</emphasis> definicji dokumentu XHTML lub XML. Jeśli zauważysz
			przed nią tajemnicze spacje, musiały one zostać dodane przez twój skrypt lub przez któryś z szablonów.</para>
		</sect4>
	</appendix>
	<appendix label="D" id="appendix.d">
		<title>Kody błędów</title>
		<para>Przestrzenie kodowe:</para>
		<itemizedlist>
			<listitem>1 do 50: błędy optClass</listitem>
			<listitem>51 do 100: ostrzeżenia optClass</listitem>
			<listitem>101 do 150: błędy optCompiler</listitem>
			<listitem>151 do 200: ostrzeżenia optCompiler</listitem>
			<listitem>201 do 300: błędy predefiniowanych instrukcji.</listitem>
			<listitem>301 do 400: ostrzeżenia predefiniowanych instrukcji.</listitem>
			<listitem>401 i wyżej: ostrzeżenia i błędy użytkownika.</listitem>	
		</itemizedlist>
		<table frame="all" id="errorcodes1">
			<?dbhtml table-width="100%" ?>
			<caption>Błędy i ostrzeżenia optClass</caption>
			<tgroup cols="3" align="center">
			<thead>
			<row>
			  <entry>Kod</entry>
			  <entry>Komunikat</entry>
			  <entry>Komentarz</entry>
			</row>
			</thead>
			<tbody>
			<row>
			  <entry>1</entry>
			  <entry>Unknown content type: content-type</entry>
			  <entry>Do metody httpHeaders() został przekazany nieznany predefiniowany typ zawartości.</entry>
			</row>
			<row>
			  <entry>2</entry>
			  <entry>First parameter must be an array.</entry>
			  <entry>Do metody setDefaultI18n() musi być przekazana tablica.</entry>
			</row>
			<row>
			  <entry>3</entry>
			  <entry>Specified value: "callback" is not a valid resouce function name.</entry>
			  <entry>Funkcja, którą próbujesz zarejestrować jako źródło danych, nie istnieje.
			  </entry>
			</row>
			<row>
			  <entry>4</entry>
			  <entry>Specified value: "callback" is not a valid OPT filter function name. </entry>
			  <entry>Funkcja, którą próbujesz zarejestrować jako filtr, nie istnieje.
			  </entry>
			</row>
			<row>
			  <entry>5</entry>
			  <entry>Specified resource type: "name" does not exist.</entry>
			  <entry>Próba wykonania szablonu w nieistniejącym źródle danych.
			  </entry>
			</row>
			<row>
			  <entry>6</entry>
			  <entry>"filename" not found in the "root" directory.</entry>
			  <entry>Szablon nie został odnaleziony. Sprawdź nazwę pliku.
			  </entry>
			</row>
			<row>
			  <entry>7</entry>
			  <entry>"directory" is not a writeable directory.</entry>
			  <entry>Ten katalog musi mieć ustawione prawa do zapisu, aby OPT mógł z niego skorzystać.
			  </entry>
			</row>
			<row>
			  <entry>8</entry>
			  <entry>Could not load the configuration from the file "config file".</entry>
			  <entry>Sprawdź, czy podałeś właściwą ścieżkę do pliku konfiguracyjnego.
			  </entry>
			</row>
			</tbody>
			</tgroup>
		</table>
		
		<table frame="all" id="errorcodes2">
			<?dbhtml table-width="100%" ?>
			<caption>Błędy i ostrzeżenia optCompiler</caption>
			<tgroup cols="3" align="center">
			<thead>
			<row>
			  <entry>Kod</entry>
			  <entry>Komunikat</entry>
			  <entry>Komentarz</entry>
			</row>
			</thead>
			<tbody>
			<row>
			  <entry>101</entry>
			  <entry>Unexpected enclosing statement: "statement".</entry>
			  <entry>Znaczniki nie zostały zamknięte we właściwej kolejności.
			  </entry>
			</row>
			<row>
			  <entry>102</entry>
			  <entry>Unexpected "item".</entry>
			  <entry>Wystąpił problem w trakcie kompilacji szablonu. Sprawdź, czy użyłeś elementów składni we właściwy sposób.</entry>
			</row>
			<row>
			  <entry>103</entry>
			  <entry>Call to undefined function: "function"</entry>
			  <entry>Szablon próbuje odwołać się do nieistniejącej funkcji. Sprawdź, czy ją zarejestrowałeś i czy
				  nie zrobiłeś literówki w nazwie.
			  </entry>
			</row>
			<row>
			  <entry>104</entry>
			  <entry>Unknown constant: "constant".</entry>
			  <entry>Próba wywołania nieistniejącej stałej za pomocą bloku <emphasis>$opt</emphasis>.
			  </entry>
			</row>
			<row>
			  <entry>105</entry>
			  <entry>Unknown OPT command: "command"</entry>
			  <entry>Blok specjalny <emphasis>$opt</emphasis> nie może być przetworzony - wywołałeś nieobsługiwaną operację.
			  </entry>
			</row>
			<row>
			  <entry>106</entry>
			  <entry>Unexpected token: "token type" (token) in expression ...</entry>
			  <entry>Wystąpił problem z przetwarzaniem podanego wyrażenia. Próba użycia podanego tokenu w niewłaściwym miejscu.
			  </entry>
			</row>
			<row>
			  <entry>107</entry>
			  <entry>Required parameter "parameter" not specified in "instruction" instruction.</entry>
			  <entry>Nie podałeś jednego z wymaganych przez podaną instrukcję parametrów.
			  </entry>
			</row>
			<row>
			  <entry>108</entry>
			  <entry>Invalid parameter #num in "instruction" instruction.</entry>
			  <entry>Sprawdź, czy podałeś prawidłową wartość.
			  </entry>
			</row>
			<row>
			  <entry>109</entry>
			  <entry>Cannot use <variable>!x</variable> marker for a required parameter in "instruction" instruction.</entry>
			  <entry>Symbol !x może być używany tylko z parametrami opcjonalnymi, podczas gdy szablon próbuje użyć go do parametru wymaganego,
				  którego nie wolno pominąć.
			  </entry>
			</row>
			<row>
			  <entry>110</entry>
			  <entry>__UNKNOWN__ is a reserved parameter name in "instruction" instruction.</entry>
			  <entry>Próbowałeś stworzyć parametr __UNKNOWN__, podczas gdy jest to nazwa zarezerwowana.
			  </entry>
			</row>
			<row>
			  <entry>111</entry>
			  <entry>The "instruction" instruction requires "style" style parameters.</entry>
			  <entry>Niektóre instrukcje mogą wymagać użycia określonego stylu składni parametrów. Ten komunikat mówi, że próbowałeś
				  użyć nie tego, co trzeba.
			  </entry>
			</row>
			<row>
			  <entry>151</entry>
			  <entry>The language block group@id does not exist.</entry>
			  <entry>To ostrzeżenie jest zgłaszane, jeśli nastąpiła próba odwołania się do nieistniejącego bloku językowego.
			  </entry>
			</row>
			</tbody>
			</tgroup>
		</table>
	</appendix>
	<appendix label="E" id="appendix.e">
		<title>Problemy</title>
		<qandaset defaultlabel="qanda">
			<qandaentry>
				<question><para>W szablonach mam trochę kodu JavaScript. Jednak OPT próbuje przetwarzać znaki { i } wewnątrz tego kodu, co
					oczywiście powoduje błędy.</para></question>
				<answer>
					<para>Umieść kod JavaScript wewnątrz instrukcji <emphasis>{literal}</emphasis> oraz
						<emphasis>{/literal}</emphasis>.</para>
				</answer>				
			</qandaentry>
			<qandaentry>
				<question><para>Przetwarzam trochę szablonów UTF-8 i OPT niszczy w nim znaki diaktryczne.</para></question>
				<answer>
					<para>OPT nie ma nic wspólnego z Unikodem i to nie on niszczy Twoje dokumenty, lecz nowoczesne przeglądarki.
						Nie zapomnij, że aby używać tego kodowania, nie wystarczy informacja w tagu META. Musisz dodatkowo wysłać
						nagłówek HTTP z informacją o użyciu tego kodowania. W OPT ustaw dyrektywę konfiguracyjną <variable>charset</variable>
					na "utf-8" i wywołaj metodę
					<link linkend="library.optclass.http-headers" endterm="">optClass::httpHeaders()</link> aby wysłać poprawne nagłówki.</para>
				</answer>				
			</qandaentry>
			<qandaentry>
				<question><para>Kod źródłowy OPT wykorzystuje operator @. Napisałem mój własny przechwytywacz błędów,
					jednak wyłapuje on wszystkie komunikaty, nawet gdy są ukryte przez ten operator. Jak mogę temu
					zapobiec?</para></question>
				<answer>
					<para>Jeśli przechwycony błąd PHP jest poprzedzony przez @, funkcja <emphasis>error_reporting()</emphasis>
					wywołana wewnątrz funkcji przechwytującej zwróci 0:</para>
					<programlisting><![CDATA[function myErrorHandler($errno, $errstr, $errfile, $errline)
{
	if(error_reporting() != 0)
	{
		// twój kod
	}
}]]></programlisting>					
				</answer>				
			</qandaentry>
			<qandaentry>
				<question><para>Mój serwer akceptuje PHP5 tylko w skryptach z rozszerzeniem <filename>.php5</filename>, natomiast <filename>.php</filename>
					jest zarezerwowane dla PHP4. Jak mogę prosto zmienić rozszerzenie plików biblioteki?</para></question>
				<answer>
					<para>Nie musisz wcale nic zmieniać. Ten wymóg dotyczy jedynie skryptów wywoływanych
						z przeglądarki. Dołączane pliki mogą mieć dowolne rozszerzenie, nawet tak zwariowane,
						jak "terefere". Po prostu dołącz pliki OPT i nie przejmuj się rozszerzeniem.</para>
				</answer>				
			</qandaentry>
			<qandaentry>
				<question><para>Przyjrzyj się poniższemu szablonowi:</para>
				<programlisting><![CDATA[foo{var=foo; "bar"}
bar]]></programlisting>
				<para>Spodziewany rezultat:</para>
				<programlisting><![CDATA[foo
bar]]></programlisting>
				<para>Otrzymany rezultat:</para>
				<programlisting><![CDATA[foobar]]></programlisting>
				<para>Co się dzieje?</para>
				</question>
				<answer>
					<para>Szablony są kompilowane do postaci kodu PHP. Wykonaliśmy kilka testów i odkryliśmy, że
						znaki nowej linii usuwa parser PHP, a nie kompilator OPT, tak więc za problem odpowiadają
						twórcy PHP.</para>
				</answer>				
			</qandaentry>
			<qandaentry>
				<question><para>Mam w wyrażeniach OPT trochę ciągów tekstowych i chciałbym w nich używać znaków { i }.
					Lecz wtedy w moich szablonach powstają dziwne błędy.</para>
				</question>
				<answer>
					<para>Te znaki zawsze otwierają i kończą znaczniki OPT, nawet wewnątrz nich samych.
						Aby je wyświetlić, użyj specjalnych encji: &amp;lb;
						oraz &amp;rb;. Są one dostępne nawet, jeśli dyrektywy <variable>entities</variable>
						lub <variable>xmlsyntaxMode</variable> nie są włączone.</para>
				</answer>
			</qandaentry>
		</qandaset>
	</appendix>
	<appendix label="F" id="appendix.f">
		<title>Wsparcie</title>
		<para>Jeśli masz problem z OPT, możesz zawsze znaleźć pomoc na forum dyskusyjnym projektu pod
			adresem <ulink url="http://forum.openpb.net">forum.openpb.net</ulink>. Jest to
			forum międzynarodowe z domyślnym językiem angielskim, lecz duże grupy użytkowników danej
			narodowości mogą uzyskać także własne fora - tak też jest w przypadku języka polskiego.
			Poniżej zamieszczamy kilka zasad, których należy się trzymać.</para>
		<para>Prosimy nie kontaktować się bezpośrednio z autorami np. poprzez e-mail. Odpowiedzi na
		tak zadane pytania nie będą udzielane, dopóki pytanie nie znajdzie się na forum!</para>
		<orderedlist>
			<listitem>Nie atakuj nikogo.</listitem>
			<listitem>Nie przeklinaj.</listitem>
			<listitem>Użyj tagów BBCode, aby nadać swoim wiadomościom klarowny wygląd.</listitem>
			<listitem>Jeśli zgłaszasz problem, opisz go wyczerpująco i dokładnie.</listitem>
			<listitem>Umieść temat na właściwym forum.</listitem>
			<listitem>Spam oraz rozmaite ogłoszenia są zakazane.</listitem>
			<listitem>Nie zgłaszaj błędów biblioteki na forum. Od tego masz <ulink url="http://openpb.net/bugs">bugtracker</ulink>.</listitem>
			<listitem>Moderatorzy udzielają banów i ostrzeżeń, jeśli ktoś nie stosuje się do reguł.</listitem>
			<listitem>Jeśli naprawdę chcesz wiedzieć, jak prawidłowo zadawać pytania na forach dyskusyjnych,
				zajrzyj pod następujący adres:
				<ulink url="http://rtfm.bsdzine.org">http://rtfm.bsdzine.org</ulink></listitem>		
		</orderedlist>
		<para>Zasady forum międzynarodowego:</para>
		<orderedlist>
			<listitem>Komunikacja tylko w języku angielskim.</listitem>
			<listitem>Nie wolno atakować innych nacji.</listitem>
			<listitem>Jeśli na forum jest duża grupa użytkowników danej narodowości, możliwe jest
				utworzenie dla nich wydzielonego forum.</listitem>
		</orderedlist>
	</appendix>
	<appendix label="G" id="appendix.g">
		<title>Zgłaszanie błędów</title>
		<para>Każde nowe wydanie biblioteki przechodzi przed opublikowaniem szereg testów:</para>
		<orderedlist>
			<listitem>Parser unit test - test klasy parsera optClass.</listitem>
			<listitem>Compiler unit test - testowanie wyników działania kompilatora w różnych sytuacjach.</listitem>
			<listitem>Example passing - każdy dołączony do biblioteki przykład musi zadziałać poprawnie.</listitem>
			<listitem>Development passing - do OPT istnieje również duża liczba nieopublikowanych plików testowych testujących całą funkcjonalność. One również muszą zadziałać.</listitem>
			<listitem>Rzeczywiste projekty - zazwyczaj podpinamy nowe wydanie pod jakiś rzeczywisty projekt stworzony z użyciem
				biblioteki i rekompilujemy w nim wszystkie szablony.</listitem>
		</orderedlist>
		<para>Jednak przez taki filtr wciąż mogą prześlizgnąć się niezauważone problemy. Jeśli masz pewność, że znalazłeś taki, zgłoś go
			w naszym bugtrackerze: <ulink url="http://bugs.openpb.net">bugs.openpb.net</ulink>! Raport musi być napisany w języku
			angielskim (jest to ważne, tu już nie można zrobić podziału, jak na forum). Jeśli nie znasz dobrze angielskiego, poproś kogoś
			o przetłumaczenie (nawet Slumpa). Nie zapomnij o dołączeniu przypadku testowego, który pozwoli odtworzyć błąd
			twórcom biblioteki - jest to niezbędne, aby w ogóle zacząć myśleć o jego usunięciu.</para>
	</appendix>
	<appendix label="H" id="appendix.h">
		<title>W następnej wersji</title>
		<para>W najbliższej przyszłości rozpoczniemy prace nad nowym, alternatywnym kompilatorem, w pełni wspierającym
		język XHTML oraz XML. Zostanie on zaimplementowany w wydaniu OPT 2.0.0. Jednocześnie dalej rozwijać będziemy gałąź
		1.1.x, usuwając znalezione błędy.</para>
	</appendix>
	<appendix label="I" id="appendix.i">
		<title>Autorzy i licencja</title>
		<para>Open Power Template jest rozpowszechniany na licencji GNU Lesser General Public License 2.1. Pełen tekst jest
		dołączony do każdego wydania OPT. Ta dokumentacja rozpowszechniana jest na licencji GNU Free Documentation License 2.1.
		Jej pełen tekst znajduje się w archiwum z dokumentacją.</para>
		<para>Autorzy projektu:</para>
		<orderedlist>
			<listitem><ulink url="http://www.zyxist.com">Tomasz "Zyx" Jędrzejewski</ulink> - głównodowodzący projektu, programista.</listitem>
			<listitem>Tomasz "Slump" Szczupliński - koordynator i tłumacz (polska wersja dokumentacji).</listitem>
		</orderedlist>
		<para>Dane kontaktowe dostępne są na stronie <ulink url="http://opt.openpb.net">opt.openpb.net</ulink>.</para>
		<para>Pragniemy serdecznie podziękować:</para>
		<orderedlist>
			<listitem>Jackowi "eXtreme" Jędrzejewskiemu - za wiele ciekawych pomysłów i wykrytych błędów.</listitem>
			<listitem>Mirosławowi "normanos" Okońskiemu - za cenne pomysły dot. cachowania wyjścia.</listitem>
			<listitem>Krzysztofowi J. Szklarskiemu - za wsparcie finansowe projektu.</listitem>
			<listitem><ulink url="http://www.acs.pl">acs.pl</ulink> za porządny hosting witryn internetowych projektu.</listitem>
			<listitem>Wszystkich korzystających z OPT w codziennej pracy.</listitem>		
		</orderedlist>
		<para>Gratulujemy, dotarłeś do końca dokumentacji OPT.</para>
	</appendix>
</book>
