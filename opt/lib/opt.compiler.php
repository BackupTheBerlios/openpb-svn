<?php  //  --------------------------------------------------------------------  //  //                          Open Power Board                              //  //                        Open Power Template                             //  //         Copyright (c) 2005 OpenPB team, http://opt.openpb.net/         //  //  --------------------------------------------------------------------  //  //  This program is free software; you can redistribute it and/or modify  //  //  it under the terms of the GNU Lesser General Public License as        //  //  published by the Free Software Foundation; either version 2.1 of the  //  //  License, or (at your option) any later version.                       //  //  --------------------------------------------------------------------  //	// parameter flags	define('OPT_PARAM_REQUIRED', 0);	define('OPT_PARAM_OPTIONAL', 1);	// parameter types	define('OPT_PARAM_ID', 2);	define('OPT_PARAM_EXPRESSION', 3);	define('OPT_PARAM_ASSIGN_EXPR', 4);	define('OPT_PARAM_STRING', 5);	define('OPT_PARAM_NUMBER', 6);	define('OPT_PARAM_VARIABLE', 7);	define('OPT_ROOT', 0);	define('OPT_TEXT', 1);	define('OPT_INSTRUCTION', 2);	define('OPT_EXPRESSION', 3);	define('OPT_COMPONENT', 4);	define('OPT_EVENT', 5);	define('OPT_MASTER', 0);	define('OPT_ALT', 1);	define('OPT_ENDER', 2);	define('OPT_COMMAND', 3);	// Compilation tree classes	class opt_node	{		protected $name;		public $data;		protected $subitems;		protected $current_si;		protected $type;		protected $parent;		protected $compiler;		protected $output;				public function __construct($name, &$output, $compiler, $type, $parent)		{			$this -> name = $name;			$this -> output = &$output;			$this -> compiler = $compiler;			$this -> parent = $parent;			$this -> type = $type;			$this -> data = NULL;			$this -> current_si = NULL;			$this -> subitems = array();		} // end __construct();				public function add_subitem(opt_node $node)		{			$this -> subitems[$this -> current_si][] = $node;				} // end add_subitem();				public function add_group($data)		{			if($this -> current_si === NULL)			{				$this -> current_si = 0;			}			else			{				$this -> current_si++;			}			$this -> subitems[$this -> current_si] = array();			$this -> data[$this -> current_si] = $data;		} // end add_group();				public function get_type()		{			return $this -> type;		} // end get_type();				public function get_name()		{			return $this -> name;		} // end get_name();				public function process()		{			foreach($this -> subitems as &$list)			{				if(count($list) > 0)				{					foreach($list as $subitem)					{						$subitem -> process();								}				}			}				} // end process();				final public function move_to_parent()		{			return $this -> parent;				} // end move_to_parent();	}		class opt_text extends opt_node	{		public function add_group($data)		{			$this -> data .= $data;		} // end add_group();				public function process()		{			$this -> output .= $this -> data;		} // end process();		}		class opt_expression extends opt_node	{		public function add_group($data)		{			$this -> data = $data;		} // end add_group();				public function process()		{			$result = $this -> compiler -> compile_expression($this->data, 1);			if($result[1] == 1)			{				// we have an assignment, so we must build different code				$this -> output .= '\'; '.$result[0].'; '.$this -> compiler -> tpl -> capture_to.' \'';			}			$this -> output .= '\'.(string)('.$result[0].').\'';		} // end process();		}	// Instruction tree classes	require('opt.instructions.php');	// Main compiler	final class opt_compiler	{		public $code;		public $tpl;		public $nesting_names;		public $nesting_level;		public $literal_enabled;				public $comments;		public $ne; // E_NOTICE resistance		public $translator;		private $stack;		private $stack_level;		public function __construct($tpl)		{			if($tpl instanceof opt_template)			{				$this -> tpl = $tpl;			}			elseif($tpl instanceof opt_compiler)			{				$this -> tpl = $tpl -> tpl;				$this -> nesting_names = $tpl -> nesting_names;				$this -> nesting_level = $tpl -> nesting_level;				$this -> literal_enabled = $tpl -> literal_enabled;				$this -> comments = $tpl -> comments;				$this -> ne = $tpl -> ne;			}						foreach($this -> tpl -> control as $class)			{				eval('$data = '.$class.'::configure();');								foreach($data as $name => $type)				{					$this -> translator[$name] = array(0 => $class, 1 => $type);								}			}		} // end __construct();		public function parse($code)		{			static $regex;			$this -> literal_enabled = 0;			if(count($this -> tpl -> code_filters['pre']) > 0)			{				foreach($this -> tpl -> code_filters['pre'] as $name)				{					// @ used because of stupid notice					// "Object of class opt_template to string conversion".					// Whatever it means, I couldn't recognize, why PHP does such things.					$this -> code = @$name($code, $this -> tpl);				}			}			// template escaping			$code = str_replace(array(				'\\',				'\''				),				array(				'\\\\',				'\\\''				), $code			);			if($regex == NULL)			{				$regex = implode('|', $this -> tpl -> delimiters);				if($this -> tpl -> conf['xmlsyntax_mode'] == 1)				{					$regex = '\<\!\-\-.+\-\-\>|<\!\[CDATA\[|\]\]>|'.$regex;				}			}			// build a tree			preg_match_all('#({\*.+?\*\}|'.$regex.'|(.?))#si', $code, $result, PREG_PATTERN_ORDER);			foreach($result as $i => &$void)			{				if($i != 0)				{					unset($result[$i]);				}			}			$output = $this -> tpl -> capture_to.' \'';			$root = $current = new opt_node(NULL, $output, $this, OPT_ROOT, NULL);			$root -> add_group(array());			$text = NULL;			$text_assign = 0;			$commented = 0;			foreach($result[0] as $item)			{				// comment usage				if(strlen($item) > 1)				{					if(preg_match('/{\*.+?\*\}/s', trim($item))|| preg_match('/\<\!\-\-.+\-\-\>/s', $item))					{						continue;					}					// a command					$text_assign = 0;					if(is_object($text))					{						$current -> add_subitem($text);										}					// grep the data					$sort_matches = array(0 => '', 1 => '');					preg_match('/'.$regex.'/', $item, $matches);					foreach($matches as $id => $val)					{						$val = trim($val);						if($val != '')						{							if($val == '/')							{								$sort_matches[0] = '/';							}							elseif($id != 0 )							{								$sort_matches[1] = $val;							}						}					}					if(preg_match('/(([a-zA-Z0-9\_]+)([= ]{1}(.*))?)/', $sort_matches[1], $found))					{						// we have an instruction												$realname = $found[2];						if($sort_matches[0] == '/')						{												$found[2] = '/'.$found[2];						}						$found[6] = $item;						// component parsing						if($current -> get_type() === OPT_COMPONENT)						{													switch($realname)							{								case 'param':										$params = array(											'name' => array(OPT_PARAM_REQUIRED, OPT_PARAM_ID),											'value' => array(OPT_PARAM_REQUIRED, OPT_PARAM_EXPRESSION)										);										$this -> parametrize_error('component parameter', $this -> parametrize($found, $params));										$current -> add_param($params['name'], $params['value']);										break;								default:										if($current -> get_name() == $realname)										{											// the end of the component											$current -> add_group($found);											$current = $current -> move_to_parent();										}										elseif(strlen($realname) == strlen($found[2]))										{											$params = array(												'message' => array(OPT_PARAM_REQUIRED, OPT_PARAM_ID),												'position' => array(OPT_PARAM_OPTIONAL, OPT_PARAM_ID, 0)											);											$this -> parametrize_error('component event', $this -> parametrize($found, $params));											$token = new opt_event($realname, $output, $this, OPT_EVENT, $current);											$token -> add_group($params);											$current -> add_subitem($token);											$current = $token;										}										else										{											$this -> tpl -> error(E_USER_ERROR, 'Invalid event closing location: '.$item, 105);																				}													}									}						elseif($current -> get_type() == OPT_EVENT && $current -> get_name() === $realname)						{							// the end of the event							$current -> add_group($found);							$current = $current -> move_to_parent();						}																elseif($realname == 'component' || isset($this -> tpl -> components[$realname]))						{							$token = new opt_component($realname, $output, $this, OPT_COMPONENT, $current);							$token -> add_group($found);							$current -> add_subitem($token);							$current = $token;						}						elseif(isset($this -> translator[$found[2]]))						{							// php 5 bug							$classname = $this -> translator[$found[2]][0];							// what to do?							switch($this -> translator[$found[2]][1])							{								case OPT_COMMAND:										$token = new $classname($realname, $output, $this, OPT_INSTRUCTION, $current);										$token -> add_group($found);										$current -> add_subitem($token);										break;								case OPT_MASTER:										$token = new $classname($realname, $output, $this, OPT_INSTRUCTION, $current);										$token -> add_group($found);										$current -> add_subitem($token);										$current = $token;										break;								case OPT_ALT:										if($current -> get_type() == OPT_INSTRUCTION)										{											$current -> add_group($found);										}										else										{											$this -> tpl -> error(E_USER_ERROR, 'Invalid alternative statement: '.$item, 105);										}										break;								case OPT_ENDER:										if($current -> get_type() == OPT_INSTRUCTION && $current -> get_name() == $realname)										{											$current -> add_group($found);											$current = $current -> move_to_parent();										}										else										{											$this -> tpl -> error(E_USER_ERROR, 'Invalid closing statement: '.$item, 105);										}										break;													}												}						else						{							// we have an expression							$token = new opt_expression(NULL, $output, $this, OPT_EXPRESSION, $current);							$token -> add_group($sort_matches[1]);							$current -> add_subitem($token);						}						$text = new opt_text(NULL, $output, $this, OPT_TEXT, $current);					}					else					{						// we have an expression						$token = new opt_expression(NULL, $output, $this, OPT_EXPRESSION, $current);						$token -> add_group($sort_matches[1]);						$current -> add_subitem($token);					}				}				else				{					if(!is_object($text))					{						$text = new opt_text(NULL, $output, $this, OPT_TEXT, $current);					}					$text -> add_group($item);					$text_assign = 1;				}						}			if($text_assign)			{				$root -> add_subitem($text);			}						// execute the tree			$root -> process();			$code = $output.'\';';						// apply postfilters			if(count($this -> tpl -> code_filters['post']) > 0)			{				foreach($this -> tpl -> code_filters['post'] as $name)				{					$code = $name($code, $this -> tpl);				}			}						return $code;		} // end parse();		public function compile_block($name, $nest = 0)		{			if($nest > 12)			{				$this -> tpl -> error(E_USER_ERROR, 'nesting level too deep for blocks (max level: 12)', 105);			}			$value = substr($name, 1, strlen($name) - 1);			if($name{0} == '#')			{								// configuration blocks				if($this -> tpl -> conf['show_warnings'])				{					if(!isset($this -> tpl -> conf[$value]))					{						$this -> tpl -> error(E_USER_ERROR, 'the configuration directive {'.$name.'} is not defined', 107);					}					return '$this -> conf[\''.$value.'\']';				}				else				{					return '$this -> conf[\''.$value.'\']';				}			}			elseif($name{0} == '@')			{				// variables				return '$this -> vars[\''.$value.'\']';			}			else			{				$ns = explode('.', $name);				$cnt = count($ns);				if($cnt == 1)				{					return '$this->data[\''.$name.'\']';				}				else				{					return '$__'.$ns[$cnt-2].'_val[\''.$ns[$cnt-1].'\']';				}			}			return FALSE;		} // end compile_block();		public function compile_expression($expr, $allow_assignment=0)		{			/* Based on Smarty */			preg_match_all('/(?:        			"[^"\\\\]*(?:\\\\.[^"\\\\]*)*" |					\-?0[xX][0-9a-fA-F]+			|					[0-9]+\.?[0-9]+					|					\$opt\.[a-zA-Z0-9\_\.]+				|					\-\>|!==|===|==|!=|<>|<<|>>|<=|>=|\&\&|\|\||\(|\)|,|\!|\^|=|\&|\~|<|>|\||\%|\+|\-|\/	|\[|\]|\.|`|					[\$\#\@]?[a-zA-Z0-9\_\@]+							)/x', $expr, $match);			$tokens = $match[0];			$brackets = 0;						// word tokens conversion table			$word_tokens = array(				'eq' => '==',				'ne' => '!=',				'neq' => '!=',				'lt' => '<',				'le' => '<=',				'lte' => '<=',				'gt' => '>',				'ge' => '>=',				'gte' => '>=',				'and' => '&&',				'or' => '||',				'xor' => 'xor',				'not' => '!',				'mod' => '%',				'div' => '/',				'add' => '+',				'sub' => '-',				'mul' => '*'			);						$state = array(				// previous token				'prev' => NULL,				// temporary previous token				'pb' => 0,				// brackets nesting				'brackets' => 0,				// quad brackets nesting				'qbrackets' => 0,				// have we opened a function?				'function_opened' => 0,				// quad bracket constant token conversion				'qbc'	=> 0,				// where has the section block begun?				'sstart' => -1,				// what sort of section token should be next?				'spt' => 1,				// section block buffer				'sb' => '',				// is the assignment made				'assignment' => 0,				// is special function "apply" began?				'apply_began' => 0			);			$qbc = 0;			foreach($tokens as $i => &$token)			{				$state['pb'] = $token;				//	section blocks parsing								if($state['sstart'] != -1)				{					// ok, if there's a dot token, set your wishes to a text...					if($token == '.' && $state['spt'] == 1)					{						$state['sb'] .= $token;						$state['spt'] = 0;						continue;					}					// ok, we've some text					elseif(preg_match('/([a-zA-Z0-9\_]+?)/', $token) && $state['spt'] == 0)					{						$state['sb'] .= $token;						$state['spt'] = 1;						$bbbb = 2;						continue;					}					else					{					// ok, section token has been ended, parse it, reset the state and remove some recently unnecessary tokens from $tokens						$tokens[$state['sstart']] = $this -> compile_block($state['sb']);						for($n = $state['sstart'] + 1; $n < $i; $n++)						{							unset($tokens[$n]);						}						$state['sstart'] = -1;						$state['spt'] = 1;					}				}				/*					expression blocks parsing				*/				switch($token)				{				// Non-word tokens					case '!':					case '%':					case '!==':					case '==':					case '===':					case '>':					case '<':					case '!=':					case '<>':					case '<<':					case '>>':					case '<=':					case '>=':					case '&&':					case '||':					case '|':					case '^':					case '&':					case '~':					case ',':					case '+':					case '-':					case '*':					case '/':					case 'xor':						break;					case '.':						$token = '';						break;					case '`':						$token = '\"';						break;					case '[':						$state['qbrackets']++;						$qbc = 1;						break;					case ']':						$state['qbrackets']--;						break;					case ')':						$state['brackets']--;						if($state['function_opened'] == -1)						{							$state['function_opened'] = 0;						}						break;					case '(':						if($state['function_opened'] == 1)						{							$token = '($this ';							$state['function_opened'] = -1;						}						elseif($state['function_opened'] == 2)						{							$token = '(';							$state['function_opened'] = 0;						}						$state['brackets']++;						break;					case '->':						break;					case '.':						unset($tokens[$i]);						break;				// Word tokens					case 'eq':					case 'ne':					case 'neq':					case 'lt':					case 'le':					case 'lte':					case 'gt':					case 'ge':					case 'gte':					case 'and':					case 'or':					case 'not':					case 'mod':								case 'div':										case 'add':											case 'sub':									case 'mul':						$token = $word_tokens[$token];						break;					// IS EXPRESSION					case '=':					case 'is':						if($allow_assignment)						{							$state['assignment'] = 1;							$token = '=';						}						else						{							$this -> tpl -> error(E_USER_ERROR, 'assignment operators not allowed in '.$expr, 109);						}						break;					// variables, blocks, functions etc. parsing					default:						if(@(trim($tokens[$i+1]) == '('))						{							$token = trim($token);							if(function_exists('opt_'.(@$this -> tpl -> functions[$token])))							{								if($token == 'apply')								{									if($this -> tpl -> i18n_type == 1)									{										if($this -> tpl -> lang['apply_class'] != NULL)										{											$token = $this -> tpl -> lang['apply_class'].'->apply';																		}										else										{											$token = 'opt_'.$this -> tpl -> functions[$token];										}									}									else									{										$token = 'opt_predef_apply';									}									$state['apply_began'] = 1;								}								else								{									$token = 'opt_'.$this -> tpl -> functions[$token];								}								$state['function_opened'] = 1;							}							elseif(isset($this -> tpl -> php_functions[$token]))							{								$token = $this -> tpl -> php_functions[$token];								$state['function_opened'] = 2;							}							elseif(@(trim($tokens[$i-1]) == '->'))							{								// we have a method								$state['function_opened'] = 2;							}							else							{								$this -> tpl -> error(E_USER_ERROR, 'function '.$token.' not defined in expression '.$expr, 110);							}						}						elseif($token{0} == '$')						{							$token = substr($token, 1, strlen($token) - 1);							// is it a language block?							if(strpos($token, '@') !== FALSE)							{								$ns = explode('@', $token);								if($this -> tpl -> conf['show_warnings'] == 1)								{									if(!isset($this -> tpl -> lang[$ns[0]][$ns[1]]))									{										$this -> tpl -> error(E_USER_ERROR, 'the language block {'.$name.'} does not exist.', 106);									}								}								if($state['apply_began'] == 1)								{									$token = '\''.$ns[0].'\',\''.$ns[1].'\'';									$state['apply_began'] = 0;																}								else								{									// custom block									if($this -> tpl -> i18n_type == 1)									{										$token = sprintf($this -> tpl -> lang['template'], $ns[0], $ns[1]);																		}									else									{										$token = '$this -> lang[\''.$ns[0].'\'][\''.$ns[1].'\']';									}								}							}							// or maybe an $opt block?							elseif(preg_match('/opt\.[a-zA-Z0-9\_\.]+/', $token))							{								$token = $this -> compile_opt(explode('.', $token));							}							else							{							// or sth else?															if(@($this -> nesting_level['section'] > 0))								{									$state['sb'] = $token;									$state['sstart'] = $i;								}								else								{									$token = '$this -> data[\''.$token.'\']';								}							}						}						elseif($token{0} == '#' || $token{0} == '@')						{							$data = $this -> compile_block($token);							if($data === FALSE)							{								$this -> tpl -> error(E_USER_ERROR, 'unknown block type: '.$token, 111);							}							$token = $data;						}else{							// constant value, maybe it's a part of a table block name...							if($state['prev'] == '.')							{								$token = '[\''.$token.'\']';							}							elseif($state['prev'] == '->')							{								$token = $token;							}														elseif((!preg_match('/([0-9 \-\.]+?)/', (string)$token)) && $token{0} != '"' && $token{strlen($token) - 1} != '"')							{								if($qbc == 2)								{									$token = '\''.$token.'\'';								}								else								{									$token = '\''.$token.'\'';								}							}						}						if($state['function_opened'] == -1)						{							// we have an OPT function, which passes the parser as the first parameter...							$token = ', '.$token;							$state['function_opened'] = 0;						}						        		} // end of switch();        		if($qbc == 1)        		{        			$qbc++;        		}        		else        		{        			$qbc = 0;        		}        		// loop end, save recent state as previous        		$state['prev'] = $state['pb'];			}						// if the section token was the last part of the block...			if($state['sstart'] != -1)			{				$tokens[$state['sstart']] = $this -> compile_block($state['sb']);				$cnt = count($tokens);				for($n = $state['sstart'] + 1; $n < $cnt; $n++)				{					unset($tokens[$n]);				}			}			if($state['brackets'] != 0)			{				$this -> tpl -> error(E_USER_ERROR, 'expression syntax error in '.$expr.': brackets not closed', 112);			}			if($allow_assignment)			{				return array(0 => implode(' ', $tokens), $state['assignment']);			}			return implode(' ', $tokens);		} // end parse_expression();		private function compile_opt($namespace)		{			switch($namespace[1])			{				case 'section':						switch($namespace[3])						{							case 'count':									return 'count('.'$this -> data[\''.$namespace[2].'\'])';							case 'id':									return '$__'.$namespace[2].'_id';							case 'size':									return 'count($__'.$namespace[2].'_val)';							case 'first':									return '($__'.$namespace[2].'_id == 0)';							case 'last':									return '($__'.$namespace[2].'_id == count($this -> data[\''.$namespace[2].'\']) - 1)';							default:									$this -> tpl -> error(E_USER_ERROR, 'unknown OPT section command: '.$namespace[3], 113);						}				case 'capture':										return '$this -> capture[\''.$namespace[2].'\']';				case 'get':						return '$_GET[\''.$namespace[2].'\']';				case 'post':						return '$_POST[\''.$namespace[2].'\']';				case 'cookie':						return '$_COOKIE[\''.$namespace[2].'\']';				case 'session':						return '$_SESSION[\''.$namespace[2].'\']';				case 'server':						return '$_SERVER[\''.$namespace[2].'\']';				case 'env':						return '$_ENV[\''.$namespace[2].'\']';				case 'request':						return '$_REQUEST[\''.$namespace[2].'\']';				case 'now':						return 'time()';				case 'const':						if(defined($namespace[2]))						{							return $namespace[2];						}						else						{							$this -> tpl -> error(E_USER_ERROR, 'unknown constant: '.$namespace[2], 114);						}				case 'version':						return 'OPT_VERSION';				default:						$this -> tpl -> error(E_USER_ERROR, 'unknown OPT command: '.$namespace[1], 115);				}		} // end compile_function();				/*		 * INSTRUCTION WRITING TOOLS		 */				# NESTING_LEVEL		public function check_nesting_level($name)		{			if(!isset($this -> nesting_level[$name]))			{				$this -> nesting_level[$name] = 0;			}					if($this -> nesting_level[$name] > OPT_MAX_NESTING_LEVEL)			{				$this -> tpl -> error(E_USER_ERROR, 'nesting level too deep for '.$name.' element (max level: '.OPT_MAX_NESTING_LEVEL.')', 116);			}		} // end check_nesting_level();		# /NESTING_LEVEL		public function get_dynamic($cpl, $code)		{			# OUTPUT_CACHING			if($cpl -> tpl -> get_status() == true)			{			# /OUTPUT_CACHING				return $code;			}			# OUTPUT_CACHING			return '\'; $this -> cache_output[] = ob_get_contents(); /* #@#DYNAMIC#@# */ '.$code.' /* #@#END DYNAMIC#@# */ ob_start(); '.$cpl -> tpl -> capture_to.' \'';			# /OUTPUT_CACHING		} // end get_dynamic();		public function parametrize($matches, &$config)		{			if($matches[3]{0} == '=')			{				// use non-named parameter parsing				$params = array();				if(count($config) == 0)				{					// no parameters passed. Now the script wonders, why someone has called this method.					$config = array();					return NULL;				}				elseif(count($config) == 1)				{					// only one parameter needed, take all the string as it					$params[0] = $matches[4];				}				else				{					// split the param string into parameters					$quotes = 0;					$pi = 0;					$params[$pi] = '';					$test = 1;					for($i = 0; $i < strlen($matches[4]); $i++)					{										if($i - 1 >= 0)						{							$test = $matches[4]{$i - 1} != '\\';						}												if($matches[4]{$i} == '"' &&  $test)						{							$quotes = !$quotes;						}						if($matches[4]{$i} == ';' && $quotes == 0)						{							$pi++;							$params[$pi] = '';							continue;						}						$params[$pi] .= $matches[4]{$i};					}				}								$pi = 0;				$optional = 0;				// process everything				foreach($config as $name => $par)				{					if($par[0] == OPT_PARAM_OPTIONAL)					{						$optional = 1;					}										if(!isset($params[$pi]))					{						// parameter not set						if($optional == 1)						{							// pass the default value							$config[$name] = $par[2];												}						else						{							return -1;												}							}					else					{						// parameter set						$params[$pi] = trim($params[$pi]);						if($params[$pi] == '!x')						{							// force the default value							$config[$name] == $par[2];							$pi++;							continue;						}						// check the format of the parameter						switch($par[1])						{							case OPT_PARAM_ID:								if(preg_match('/[a-zA-Z\_]{1}[a-zA-Z0-9\_]*/', $params[$pi]))								{									$config[$name] = trim($params[$pi], '"');								}								else								{									return $pi;								}								break;							case OPT_PARAM_EXPRESSION:								$config[$name] = $this -> compile_expression($params[$pi]);								break;							case OPT_PARAM_ASSIGN_EXPR:								$config[$name] = $this -> compile_expression($params[$pi], true);								$config[$name] = $config[$name][0];								break;							case OPT_PARAM_STRING:								if($params[$pi]{0} == '"' && $params[$pi]{strlen($params[$pi]) - 1} == '"')								{									$config[$name] = trim($params[$pi], '"');								}								elseif(preg_match('/[a-zA-Z\_]?[a-zA-Z0-9\_]+/', $params[$pi]))								{									$config[$name] = $params[$pi];								}								else								{									return $pi;								}								break;							case OPT_PARAM_NUMBER:								if(preg_match('/(0[xX][0-9a-fA-F]+)|([0-9]+(\.[0-9]+)?)/', $params[$pi]))								{									$config[$name] = $params[$pi];								}								else								{									return $pi;								}								break;							case OPT_PARAM_VARIABLE:								if(preg_match('/\@([a-zA-Z0-9\_]+)/', $params[$pi], $got))								{									$config[$name] = '$this -> vars[\''.$got[1].'\']';								}								else								{									return $pi;								}								break;							default:								$this -> tpl -> error(E_USER_ERROR, 'Invalid parameter type: '.$par[1].' for `'.$name.'`. Check your instruction code.', 117);								}								}					$pi++;							}			}			else			{				// use named parameters				preg_match_all('#([a-zA-Z0-9\_]+)\="((.*?)[^\\\\])"#s', $matches[4], $found);								foreach($config as $name => $par)				{					if(($pi = array_search($name, $found[1])) !== FALSE)					{						// ok, the parameter is defined... try to parse it						switch($par[1])						{							case OPT_PARAM_ID:								if(preg_match('/[a-zA-Z\_]?[a-zA-Z0-9\_]+/', $found[2][$pi]))								{									$config[$name] = $found[2][$pi];								}								else								{									return $i;								}								break;							case OPT_PARAM_EXPRESSION:								$config[$name] =  $this -> compile_expression($found[2][$pi]);								break;							case OPT_PARAM_ASSIGN_EXPR:								$config[$name] = $this -> compile_expression($found[2][$pi], true);								$config[$name] = $config[$name][0];								break;							case OPT_PARAM_STRING:								$config[$name] = preg_replace('#[^\\]\\"#is', '"', $found[2][$pi]);								break;							case OPT_PARAM_NUMBER:								if(preg_match('/(0[xX][0-9a-fA-F]+)|([0-9]+(\.[0-9]+)?)/', $found[2][$pi]))								{									$config[$name] = $found[2][$pi];								}								else								{									return $pi;								}								break;							case OPT_PARAM_VARIABLE:								if(preg_match('/\@([a-zA-Z0-9\_]+)/', $found[2][$pi], $got))								{									$config[$name] = '$this -> vars[\''.$got[1].'\']';								}								else								{									return $pi;								}								break;							default:								$this -> tpl -> error(E_USER_ERROR, 'Invalid parameter type: '.$par[1].' for `'.$name.'`. Check your instruction code.', 117);								}									}					else					{						// set default value						if($par[0] == OPT_PARAM_REQUIRED)						{							return -1;						}						else						{							$config[$name] = $par[2];						}					}								}			}			return NULL;		} // end parametrize();		public function parametrize_error($name, $number)		{			if($number === NULL)			{				return 0;			}			if($number < 0)			{				$this -> tpl -> error(E_USER_ERROR, 'Wrong parameter count for \''.$name.'\' instruction!', 118);			}			else			{				$this -> tpl -> error(E_USER_ERROR, 'Invalid parameter #'.($number+1).' in \''.$name.'\' instruction!', 119);			}		} // end parametrize_error();	}?>